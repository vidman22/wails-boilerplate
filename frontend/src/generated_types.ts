import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  bigint: { input: any; output: any; }
  date: { input: any; output: any; }
  float8: { input: any; output: any; }
  jsonb: { input: any; output: any; }
  numeric: { input: any; output: any; }
  seed_float: { input: any; output: any; }
  time: { input: any; output: any; }
  timestamptz: { input: any; output: any; }
  timetz: { input: any; output: any; }
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntArrayComparisonExp = {
  /** is the array contained in the given array value */
  _contained_in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** does the array contain the given value */
  _contains?: InputMaybe<Array<Scalars['Int']['input']>>;
  _eq?: InputMaybe<Array<Scalars['Int']['input']>>;
  _gt?: InputMaybe<Array<Scalars['Int']['input']>>;
  _gte?: InputMaybe<Array<Scalars['Int']['input']>>;
  _in?: InputMaybe<Array<Array<Scalars['Int']['input']>>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Array<Scalars['Int']['input']>>;
  _lte?: InputMaybe<Array<Scalars['Int']['input']>>;
  _neq?: InputMaybe<Array<Scalars['Int']['input']>>;
  _nin?: InputMaybe<Array<Array<Scalars['Int']['input']>>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "activity_set_assignments" */
export type ActivitySetAssignments = {
  __typename?: 'activity_set_assignments';
  activitySetId: Scalars['Int']['output'];
  activitySetResponseId: Scalars['Int']['output'];
  assigneeId: Scalars['Int']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  date: Scalars['date']['output'];
  dueAt: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  time: Scalars['timetz']['output'];
  timezone: Scalars['String']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "activity_set_assignments" */
export type ActivitySetAssignmentsAggregate = {
  __typename?: 'activity_set_assignments_aggregate';
  aggregate?: Maybe<ActivitySetAssignmentsAggregateFields>;
  nodes: Array<ActivitySetAssignments>;
};

/** aggregate fields of "activity_set_assignments" */
export type ActivitySetAssignmentsAggregateFields = {
  __typename?: 'activity_set_assignments_aggregate_fields';
  avg?: Maybe<ActivitySetAssignmentsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ActivitySetAssignmentsMaxFields>;
  min?: Maybe<ActivitySetAssignmentsMinFields>;
  stddev?: Maybe<ActivitySetAssignmentsStddevFields>;
  stddev_pop?: Maybe<ActivitySetAssignmentsStddevPopFields>;
  stddev_samp?: Maybe<ActivitySetAssignmentsStddevSampFields>;
  sum?: Maybe<ActivitySetAssignmentsSumFields>;
  var_pop?: Maybe<ActivitySetAssignmentsVarPopFields>;
  var_samp?: Maybe<ActivitySetAssignmentsVarSampFields>;
  variance?: Maybe<ActivitySetAssignmentsVarianceFields>;
};


/** aggregate fields of "activity_set_assignments" */
export type ActivitySetAssignmentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ActivitySetAssignmentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ActivitySetAssignmentsAvgFields = {
  __typename?: 'activity_set_assignments_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  assigneeId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "activity_set_assignments". All fields are combined with a logical 'AND'. */
export type ActivitySetAssignmentsBoolExp = {
  _and?: InputMaybe<Array<ActivitySetAssignmentsBoolExp>>;
  _not?: InputMaybe<ActivitySetAssignmentsBoolExp>;
  _or?: InputMaybe<Array<ActivitySetAssignmentsBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  activitySetResponseId?: InputMaybe<IntComparisonExp>;
  assigneeId?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  date?: InputMaybe<DateComparisonExp>;
  dueAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  time?: InputMaybe<TimetzComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "activity_set_assignments" */
export enum ActivitySetAssignmentsConstraint {
  /** unique or primary key constraint on columns "id" */
  ActivitySetAssignmentsPkey = 'activity_set_assignments_pkey'
}

/** input type for incrementing numeric columns in table "activity_set_assignments" */
export type ActivitySetAssignmentsIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  assigneeId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "activity_set_assignments" */
export type ActivitySetAssignmentsInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  assigneeId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  date?: InputMaybe<Scalars['date']['input']>;
  dueAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  time?: InputMaybe<Scalars['timetz']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ActivitySetAssignmentsMaxFields = {
  __typename?: 'activity_set_assignments_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  assigneeId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  date?: Maybe<Scalars['date']['output']>;
  dueAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  time?: Maybe<Scalars['timetz']['output']>;
  timezone?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type ActivitySetAssignmentsMinFields = {
  __typename?: 'activity_set_assignments_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  assigneeId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  date?: Maybe<Scalars['date']['output']>;
  dueAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  time?: Maybe<Scalars['timetz']['output']>;
  timezone?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "activity_set_assignments" */
export type ActivitySetAssignmentsMutationResponse = {
  __typename?: 'activity_set_assignments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ActivitySetAssignments>;
};

/** on_conflict condition type for table "activity_set_assignments" */
export type ActivitySetAssignmentsOnConflict = {
  constraint: ActivitySetAssignmentsConstraint;
  update_columns?: Array<ActivitySetAssignmentsUpdateColumn>;
  where?: InputMaybe<ActivitySetAssignmentsBoolExp>;
};

/** Ordering options when selecting data from "activity_set_assignments". */
export type ActivitySetAssignmentsOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  activitySetResponseId?: InputMaybe<OrderBy>;
  assigneeId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  date?: InputMaybe<OrderBy>;
  dueAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  time?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: activity_set_assignments */
export type ActivitySetAssignmentsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "activity_set_assignments" */
export enum ActivitySetAssignmentsSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  AssigneeId = 'assigneeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Date = 'date',
  /** column name */
  DueAt = 'dueAt',
  /** column name */
  Id = 'id',
  /** column name */
  Time = 'time',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "activity_set_assignments" */
export type ActivitySetAssignmentsSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  assigneeId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  date?: InputMaybe<Scalars['date']['input']>;
  dueAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  time?: InputMaybe<Scalars['timetz']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type ActivitySetAssignmentsStddevFields = {
  __typename?: 'activity_set_assignments_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  assigneeId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ActivitySetAssignmentsStddevPopFields = {
  __typename?: 'activity_set_assignments_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  assigneeId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ActivitySetAssignmentsStddevSampFields = {
  __typename?: 'activity_set_assignments_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  assigneeId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "activity_set_assignments" */
export type ActivitySetAssignmentsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ActivitySetAssignmentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ActivitySetAssignmentsStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  assigneeId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  date?: InputMaybe<Scalars['date']['input']>;
  dueAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  time?: InputMaybe<Scalars['timetz']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type ActivitySetAssignmentsSumFields = {
  __typename?: 'activity_set_assignments_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  assigneeId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "activity_set_assignments" */
export enum ActivitySetAssignmentsUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  AssigneeId = 'assigneeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Date = 'date',
  /** column name */
  DueAt = 'dueAt',
  /** column name */
  Id = 'id',
  /** column name */
  Time = 'time',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ActivitySetAssignmentsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ActivitySetAssignmentsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ActivitySetAssignmentsSetInput>;
  /** filter the rows which have to be updated */
  where: ActivitySetAssignmentsBoolExp;
};

/** aggregate var_pop on columns */
export type ActivitySetAssignmentsVarPopFields = {
  __typename?: 'activity_set_assignments_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  assigneeId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ActivitySetAssignmentsVarSampFields = {
  __typename?: 'activity_set_assignments_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  assigneeId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ActivitySetAssignmentsVarianceFields = {
  __typename?: 'activity_set_assignments_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  assigneeId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "activity_set_reports" */
export type ActivitySetReports = {
  __typename?: 'activity_set_reports';
  /** An object relationship */
  activitySet: ActivitySets;
  activitySetId: Scalars['Int']['output'];
  comment: Scalars['String']['output'];
  createdBy: Scalars['Int']['output'];
  data: Scalars['jsonb']['output'];
  reason: Scalars['String']['output'];
  suggestion?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "activity_set_reports" */
export type ActivitySetReportsDataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "activity_set_reports" */
export type ActivitySetReportsAggregate = {
  __typename?: 'activity_set_reports_aggregate';
  aggregate?: Maybe<ActivitySetReportsAggregateFields>;
  nodes: Array<ActivitySetReports>;
};

/** aggregate fields of "activity_set_reports" */
export type ActivitySetReportsAggregateFields = {
  __typename?: 'activity_set_reports_aggregate_fields';
  avg?: Maybe<ActivitySetReportsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ActivitySetReportsMaxFields>;
  min?: Maybe<ActivitySetReportsMinFields>;
  stddev?: Maybe<ActivitySetReportsStddevFields>;
  stddev_pop?: Maybe<ActivitySetReportsStddevPopFields>;
  stddev_samp?: Maybe<ActivitySetReportsStddevSampFields>;
  sum?: Maybe<ActivitySetReportsSumFields>;
  var_pop?: Maybe<ActivitySetReportsVarPopFields>;
  var_samp?: Maybe<ActivitySetReportsVarSampFields>;
  variance?: Maybe<ActivitySetReportsVarianceFields>;
};


/** aggregate fields of "activity_set_reports" */
export type ActivitySetReportsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ActivitySetReportsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ActivitySetReportsAppendInput = {
  data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type ActivitySetReportsAvgFields = {
  __typename?: 'activity_set_reports_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "activity_set_reports". All fields are combined with a logical 'AND'. */
export type ActivitySetReportsBoolExp = {
  _and?: InputMaybe<Array<ActivitySetReportsBoolExp>>;
  _not?: InputMaybe<ActivitySetReportsBoolExp>;
  _or?: InputMaybe<Array<ActivitySetReportsBoolExp>>;
  activitySet?: InputMaybe<ActivitySetsBoolExp>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  comment?: InputMaybe<StringComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  data?: InputMaybe<JsonbComparisonExp>;
  reason?: InputMaybe<StringComparisonExp>;
  suggestion?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "activity_set_reports" */
export enum ActivitySetReportsConstraint {
  /** unique or primary key constraint on columns "activity_set_id", "created_by" */
  ActivitySetReportsActivitySetIdCreatedByKey = 'activity_set_reports_activity_set_id_created_by_key',
  /** unique or primary key constraint on columns "activity_set_id", "created_by" */
  ActivitySetReportsPkey = 'activity_set_reports_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ActivitySetReportsDeleteAtPathInput = {
  data?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ActivitySetReportsDeleteElemInput = {
  data?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ActivitySetReportsDeleteKeyInput = {
  data?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "activity_set_reports" */
export type ActivitySetReportsIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "activity_set_reports" */
export type ActivitySetReportsInsertInput = {
  activitySet?: InputMaybe<ActivitySetsObjRelInsertInput>;
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  suggestion?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type ActivitySetReportsMaxFields = {
  __typename?: 'activity_set_reports_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  comment?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  suggestion?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type ActivitySetReportsMinFields = {
  __typename?: 'activity_set_reports_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  comment?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  suggestion?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "activity_set_reports" */
export type ActivitySetReportsMutationResponse = {
  __typename?: 'activity_set_reports_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ActivitySetReports>;
};

/** on_conflict condition type for table "activity_set_reports" */
export type ActivitySetReportsOnConflict = {
  constraint: ActivitySetReportsConstraint;
  update_columns?: Array<ActivitySetReportsUpdateColumn>;
  where?: InputMaybe<ActivitySetReportsBoolExp>;
};

/** Ordering options when selecting data from "activity_set_reports". */
export type ActivitySetReportsOrderBy = {
  activitySet?: InputMaybe<ActivitySetsOrderBy>;
  activitySetId?: InputMaybe<OrderBy>;
  comment?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  data?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  suggestion?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: activity_set_reports */
export type ActivitySetReportsPkColumnsInput = {
  activitySetId: Scalars['Int']['input'];
  createdBy: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ActivitySetReportsPrependInput = {
  data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "activity_set_reports" */
export enum ActivitySetReportsSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  Comment = 'comment',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Data = 'data',
  /** column name */
  Reason = 'reason',
  /** column name */
  Suggestion = 'suggestion'
}

/** input type for updating data in table "activity_set_reports" */
export type ActivitySetReportsSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  suggestion?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type ActivitySetReportsStddevFields = {
  __typename?: 'activity_set_reports_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ActivitySetReportsStddevPopFields = {
  __typename?: 'activity_set_reports_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ActivitySetReportsStddevSampFields = {
  __typename?: 'activity_set_reports_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "activity_set_reports" */
export type ActivitySetReportsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ActivitySetReportsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ActivitySetReportsStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  suggestion?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type ActivitySetReportsSumFields = {
  __typename?: 'activity_set_reports_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "activity_set_reports" */
export enum ActivitySetReportsUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  Comment = 'comment',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Data = 'data',
  /** column name */
  Reason = 'reason',
  /** column name */
  Suggestion = 'suggestion'
}

export type ActivitySetReportsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<ActivitySetReportsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<ActivitySetReportsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<ActivitySetReportsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<ActivitySetReportsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ActivitySetReportsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<ActivitySetReportsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ActivitySetReportsSetInput>;
  /** filter the rows which have to be updated */
  where: ActivitySetReportsBoolExp;
};

/** aggregate var_pop on columns */
export type ActivitySetReportsVarPopFields = {
  __typename?: 'activity_set_reports_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ActivitySetReportsVarSampFields = {
  __typename?: 'activity_set_reports_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ActivitySetReportsVarianceFields = {
  __typename?: 'activity_set_reports_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponses = {
  __typename?: 'activity_set_responses';
  activitySetId: Scalars['Int']['output'];
  /** An object relationship */
  activity_set: ActivitySets;
  /** An array relationship */
  anagramResponses: Array<AnagramResponses>;
  /** An aggregate relationship */
  anagramResponses_aggregate: AnagramResponsesAggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  endTime?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  fillInTheBlankResponses: Array<FillInTheBlankResponses>;
  /** An aggregate relationship */
  fillInTheBlankResponses_aggregate: FillInTheBlankResponsesAggregate;
  hasSeenVocab: Scalars['Boolean']['output'];
  id: Scalars['Int']['output'];
  /** An array relationship */
  matchingResponses: Array<MatchingResponses>;
  /** An aggregate relationship */
  matchingResponses_aggregate: MatchingResponsesAggregate;
  mcPercentage?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  multipleChoiceResponses: Array<MultipleChoiceResponses>;
  /** An aggregate relationship */
  multipleChoiceResponses_aggregate: MultipleChoiceResponsesAggregate;
  /** An array relationship */
  openAnswerResponses: Array<OpenAnswerResponses>;
  /** An aggregate relationship */
  openAnswerResponses_aggregate: OpenAnswerResponsesAggregate;
  percentage?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  phraseResponses: Array<PhraseResponses>;
  /** An aggregate relationship */
  phraseResponses_aggregate: PhraseResponsesAggregate;
  startTime?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesAnagramResponsesArgs = {
  distinct_on?: InputMaybe<Array<AnagramResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramResponsesOrderBy>>;
  where?: InputMaybe<AnagramResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesAnagramResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnagramResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramResponsesOrderBy>>;
  where?: InputMaybe<AnagramResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesFillInTheBlankResponsesArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankResponsesOrderBy>>;
  where?: InputMaybe<FillInTheBlankResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesFillInTheBlankResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankResponsesOrderBy>>;
  where?: InputMaybe<FillInTheBlankResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesMatchingResponsesArgs = {
  distinct_on?: InputMaybe<Array<MatchingResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingResponsesOrderBy>>;
  where?: InputMaybe<MatchingResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesMatchingResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingResponsesOrderBy>>;
  where?: InputMaybe<MatchingResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesMultipleChoiceResponsesArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceResponsesOrderBy>>;
  where?: InputMaybe<MultipleChoiceResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesMultipleChoiceResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceResponsesOrderBy>>;
  where?: InputMaybe<MultipleChoiceResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesOpenAnswerResponsesArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswerResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswerResponsesOrderBy>>;
  where?: InputMaybe<OpenAnswerResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesOpenAnswerResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswerResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswerResponsesOrderBy>>;
  where?: InputMaybe<OpenAnswerResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesPhraseResponsesArgs = {
  distinct_on?: InputMaybe<Array<PhraseResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhraseResponsesOrderBy>>;
  where?: InputMaybe<PhraseResponsesBoolExp>;
};


/** columns and relationships of "activity_set_responses" */
export type ActivitySetResponsesPhraseResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PhraseResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhraseResponsesOrderBy>>;
  where?: InputMaybe<PhraseResponsesBoolExp>;
};

/** aggregated selection of "activity_set_responses" */
export type ActivitySetResponsesAggregate = {
  __typename?: 'activity_set_responses_aggregate';
  aggregate?: Maybe<ActivitySetResponsesAggregateFields>;
  nodes: Array<ActivitySetResponses>;
};

export type ActivitySetResponsesAggregateBoolExp = {
  bool_and?: InputMaybe<ActivitySetResponsesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<ActivitySetResponsesAggregateBoolExpBoolOr>;
  count?: InputMaybe<ActivitySetResponsesAggregateBoolExpCount>;
};

export type ActivitySetResponsesAggregateBoolExpBoolAnd = {
  arguments: ActivitySetResponsesSelectColumnActivitySetResponsesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ActivitySetResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ActivitySetResponsesAggregateBoolExpBoolOr = {
  arguments: ActivitySetResponsesSelectColumnActivitySetResponsesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ActivitySetResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ActivitySetResponsesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ActivitySetResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ActivitySetResponsesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "activity_set_responses" */
export type ActivitySetResponsesAggregateFields = {
  __typename?: 'activity_set_responses_aggregate_fields';
  avg?: Maybe<ActivitySetResponsesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ActivitySetResponsesMaxFields>;
  min?: Maybe<ActivitySetResponsesMinFields>;
  stddev?: Maybe<ActivitySetResponsesStddevFields>;
  stddev_pop?: Maybe<ActivitySetResponsesStddevPopFields>;
  stddev_samp?: Maybe<ActivitySetResponsesStddevSampFields>;
  sum?: Maybe<ActivitySetResponsesSumFields>;
  var_pop?: Maybe<ActivitySetResponsesVarPopFields>;
  var_samp?: Maybe<ActivitySetResponsesVarSampFields>;
  variance?: Maybe<ActivitySetResponsesVarianceFields>;
};


/** aggregate fields of "activity_set_responses" */
export type ActivitySetResponsesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ActivitySetResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "activity_set_responses" */
export type ActivitySetResponsesAggregateOrderBy = {
  avg?: InputMaybe<ActivitySetResponsesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ActivitySetResponsesMaxOrderBy>;
  min?: InputMaybe<ActivitySetResponsesMinOrderBy>;
  stddev?: InputMaybe<ActivitySetResponsesStddevOrderBy>;
  stddev_pop?: InputMaybe<ActivitySetResponsesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<ActivitySetResponsesStddevSampOrderBy>;
  sum?: InputMaybe<ActivitySetResponsesSumOrderBy>;
  var_pop?: InputMaybe<ActivitySetResponsesVarPopOrderBy>;
  var_samp?: InputMaybe<ActivitySetResponsesVarSampOrderBy>;
  variance?: InputMaybe<ActivitySetResponsesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "activity_set_responses" */
export type ActivitySetResponsesArrRelInsertInput = {
  data: Array<ActivitySetResponsesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ActivitySetResponsesOnConflict>;
};

/** aggregate avg on columns */
export type ActivitySetResponsesAvgFields = {
  __typename?: 'activity_set_responses_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mcPercentage?: Maybe<Scalars['Float']['output']>;
  percentage?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "activity_set_responses" */
export type ActivitySetResponsesAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "activity_set_responses". All fields are combined with a logical 'AND'. */
export type ActivitySetResponsesBoolExp = {
  _and?: InputMaybe<Array<ActivitySetResponsesBoolExp>>;
  _not?: InputMaybe<ActivitySetResponsesBoolExp>;
  _or?: InputMaybe<Array<ActivitySetResponsesBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  activity_set?: InputMaybe<ActivitySetsBoolExp>;
  anagramResponses?: InputMaybe<AnagramResponsesBoolExp>;
  anagramResponses_aggregate?: InputMaybe<AnagramResponsesAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  endTime?: InputMaybe<TimestamptzComparisonExp>;
  fillInTheBlankResponses?: InputMaybe<FillInTheBlankResponsesBoolExp>;
  fillInTheBlankResponses_aggregate?: InputMaybe<FillInTheBlankResponsesAggregateBoolExp>;
  hasSeenVocab?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  matchingResponses?: InputMaybe<MatchingResponsesBoolExp>;
  matchingResponses_aggregate?: InputMaybe<MatchingResponsesAggregateBoolExp>;
  mcPercentage?: InputMaybe<IntComparisonExp>;
  multipleChoiceResponses?: InputMaybe<MultipleChoiceResponsesBoolExp>;
  multipleChoiceResponses_aggregate?: InputMaybe<MultipleChoiceResponsesAggregateBoolExp>;
  openAnswerResponses?: InputMaybe<OpenAnswerResponsesBoolExp>;
  openAnswerResponses_aggregate?: InputMaybe<OpenAnswerResponsesAggregateBoolExp>;
  percentage?: InputMaybe<IntComparisonExp>;
  phraseResponses?: InputMaybe<PhraseResponsesBoolExp>;
  phraseResponses_aggregate?: InputMaybe<PhraseResponsesAggregateBoolExp>;
  startTime?: InputMaybe<TimestamptzComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "activity_set_responses" */
export enum ActivitySetResponsesConstraint {
  /** unique or primary key constraint on columns "id" */
  ActivitySetResponsesPkey = 'activity_set_responses_pkey'
}

/** input type for incrementing numeric columns in table "activity_set_responses" */
export type ActivitySetResponsesIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  mcPercentage?: InputMaybe<Scalars['Int']['input']>;
  percentage?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "activity_set_responses" */
export type ActivitySetResponsesInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  activity_set?: InputMaybe<ActivitySetsObjRelInsertInput>;
  anagramResponses?: InputMaybe<AnagramResponsesArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  endTime?: InputMaybe<Scalars['timestamptz']['input']>;
  fillInTheBlankResponses?: InputMaybe<FillInTheBlankResponsesArrRelInsertInput>;
  hasSeenVocab?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  matchingResponses?: InputMaybe<MatchingResponsesArrRelInsertInput>;
  mcPercentage?: InputMaybe<Scalars['Int']['input']>;
  multipleChoiceResponses?: InputMaybe<MultipleChoiceResponsesArrRelInsertInput>;
  openAnswerResponses?: InputMaybe<OpenAnswerResponsesArrRelInsertInput>;
  percentage?: InputMaybe<Scalars['Int']['input']>;
  phraseResponses?: InputMaybe<PhraseResponsesArrRelInsertInput>;
  startTime?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ActivitySetResponsesMaxFields = {
  __typename?: 'activity_set_responses_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  endTime?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  mcPercentage?: Maybe<Scalars['Int']['output']>;
  percentage?: Maybe<Scalars['Int']['output']>;
  startTime?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "activity_set_responses" */
export type ActivitySetResponsesMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  endTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
  startTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ActivitySetResponsesMinFields = {
  __typename?: 'activity_set_responses_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  endTime?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  mcPercentage?: Maybe<Scalars['Int']['output']>;
  percentage?: Maybe<Scalars['Int']['output']>;
  startTime?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "activity_set_responses" */
export type ActivitySetResponsesMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  endTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
  startTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "activity_set_responses" */
export type ActivitySetResponsesMutationResponse = {
  __typename?: 'activity_set_responses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ActivitySetResponses>;
};

/** on_conflict condition type for table "activity_set_responses" */
export type ActivitySetResponsesOnConflict = {
  constraint: ActivitySetResponsesConstraint;
  update_columns?: Array<ActivitySetResponsesUpdateColumn>;
  where?: InputMaybe<ActivitySetResponsesBoolExp>;
};

/** Ordering options when selecting data from "activity_set_responses". */
export type ActivitySetResponsesOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  activity_set?: InputMaybe<ActivitySetsOrderBy>;
  anagramResponses_aggregate?: InputMaybe<AnagramResponsesAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  endTime?: InputMaybe<OrderBy>;
  fillInTheBlankResponses_aggregate?: InputMaybe<FillInTheBlankResponsesAggregateOrderBy>;
  hasSeenVocab?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingResponses_aggregate?: InputMaybe<MatchingResponsesAggregateOrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  multipleChoiceResponses_aggregate?: InputMaybe<MultipleChoiceResponsesAggregateOrderBy>;
  openAnswerResponses_aggregate?: InputMaybe<OpenAnswerResponsesAggregateOrderBy>;
  percentage?: InputMaybe<OrderBy>;
  phraseResponses_aggregate?: InputMaybe<PhraseResponsesAggregateOrderBy>;
  startTime?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: activity_set_responses */
export type ActivitySetResponsesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "activity_set_responses" */
export enum ActivitySetResponsesSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  HasSeenVocab = 'hasSeenVocab',
  /** column name */
  Id = 'id',
  /** column name */
  McPercentage = 'mcPercentage',
  /** column name */
  Percentage = 'percentage',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "activity_set_responses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "activity_set_responses" */
export enum ActivitySetResponsesSelectColumnActivitySetResponsesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  HasSeenVocab = 'hasSeenVocab'
}

/** select "activity_set_responses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "activity_set_responses" */
export enum ActivitySetResponsesSelectColumnActivitySetResponsesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  HasSeenVocab = 'hasSeenVocab'
}

/** input type for updating data in table "activity_set_responses" */
export type ActivitySetResponsesSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  endTime?: InputMaybe<Scalars['timestamptz']['input']>;
  hasSeenVocab?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  mcPercentage?: InputMaybe<Scalars['Int']['input']>;
  percentage?: InputMaybe<Scalars['Int']['input']>;
  startTime?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type ActivitySetResponsesStddevFields = {
  __typename?: 'activity_set_responses_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mcPercentage?: Maybe<Scalars['Float']['output']>;
  percentage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "activity_set_responses" */
export type ActivitySetResponsesStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type ActivitySetResponsesStddevPopFields = {
  __typename?: 'activity_set_responses_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mcPercentage?: Maybe<Scalars['Float']['output']>;
  percentage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "activity_set_responses" */
export type ActivitySetResponsesStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type ActivitySetResponsesStddevSampFields = {
  __typename?: 'activity_set_responses_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mcPercentage?: Maybe<Scalars['Float']['output']>;
  percentage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "activity_set_responses" */
export type ActivitySetResponsesStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "activity_set_responses" */
export type ActivitySetResponsesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ActivitySetResponsesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ActivitySetResponsesStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  endTime?: InputMaybe<Scalars['timestamptz']['input']>;
  hasSeenVocab?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  mcPercentage?: InputMaybe<Scalars['Int']['input']>;
  percentage?: InputMaybe<Scalars['Int']['input']>;
  startTime?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type ActivitySetResponsesSumFields = {
  __typename?: 'activity_set_responses_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  mcPercentage?: Maybe<Scalars['Int']['output']>;
  percentage?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "activity_set_responses" */
export type ActivitySetResponsesSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
};

/** update columns of table "activity_set_responses" */
export enum ActivitySetResponsesUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  HasSeenVocab = 'hasSeenVocab',
  /** column name */
  Id = 'id',
  /** column name */
  McPercentage = 'mcPercentage',
  /** column name */
  Percentage = 'percentage',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ActivitySetResponsesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ActivitySetResponsesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ActivitySetResponsesSetInput>;
  /** filter the rows which have to be updated */
  where: ActivitySetResponsesBoolExp;
};

/** aggregate var_pop on columns */
export type ActivitySetResponsesVarPopFields = {
  __typename?: 'activity_set_responses_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mcPercentage?: Maybe<Scalars['Float']['output']>;
  percentage?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "activity_set_responses" */
export type ActivitySetResponsesVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type ActivitySetResponsesVarSampFields = {
  __typename?: 'activity_set_responses_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mcPercentage?: Maybe<Scalars['Float']['output']>;
  percentage?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "activity_set_responses" */
export type ActivitySetResponsesVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ActivitySetResponsesVarianceFields = {
  __typename?: 'activity_set_responses_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mcPercentage?: Maybe<Scalars['Float']['output']>;
  percentage?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "activity_set_responses" */
export type ActivitySetResponsesVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mcPercentage?: InputMaybe<OrderBy>;
  percentage?: InputMaybe<OrderBy>;
};

/** columns and relationships of "activity_sets" */
export type ActivitySets = {
  __typename?: 'activity_sets';
  /** An array relationship */
  activitySetResponses: Array<ActivitySetResponses>;
  /** An aggregate relationship */
  activitySetResponses_aggregate: ActivitySetResponsesAggregate;
  /** An array relationship */
  anagrams: Array<Anagrams>;
  /** An aggregate relationship */
  anagrams_aggregate: AnagramsAggregate;
  /** An array relationship */
  course_activities: Array<CourseActivities>;
  /** An aggregate relationship */
  course_activities_aggregate: CourseActivitiesAggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  description: Scalars['String']['output'];
  /** An array relationship */
  fillInTheBlanks: Array<FillInTheBlanks>;
  /** An aggregate relationship */
  fillInTheBlanks_aggregate: FillInTheBlanksAggregate;
  forkedFrom?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** An object relationship */
  image?: Maybe<Images>;
  imageId?: Maybe<Scalars['Int']['output']>;
  isPrivate: Scalars['Boolean']['output'];
  learnerLanguage?: Maybe<Scalars['Int']['output']>;
  level: CefrLevelsEnum;
  /** An object relationship */
  listening?: Maybe<Listenings>;
  listeningId?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  matchings: Array<Matchings>;
  /** An aggregate relationship */
  matchings_aggregate: MatchingsAggregate;
  /** An array relationship */
  multipleChoices: Array<MultipleChoices>;
  /** An aggregate relationship */
  multipleChoices_aggregate: MultipleChoicesAggregate;
  /** An array relationship */
  openAnswers: Array<OpenAnswers>;
  /** An aggregate relationship */
  openAnswers_aggregate: OpenAnswersAggregate;
  /** An array relationship */
  phrases: Array<Phrases>;
  /** An aggregate relationship */
  phrases_aggregate: PhrasesAggregate;
  /** An object relationship */
  reading?: Maybe<Readings>;
  readingId?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  subject: Subjects;
  subjectId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  vocabularyId?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  vocabularySet?: Maybe<VocabularySets>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsActivitySetResponsesArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetResponsesOrderBy>>;
  where?: InputMaybe<ActivitySetResponsesBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsActivitySetResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetResponsesOrderBy>>;
  where?: InputMaybe<ActivitySetResponsesBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsAnagramsArgs = {
  distinct_on?: InputMaybe<Array<AnagramsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramsOrderBy>>;
  where?: InputMaybe<AnagramsBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsAnagramsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnagramsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramsOrderBy>>;
  where?: InputMaybe<AnagramsBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsCourseActivitiesArgs = {
  distinct_on?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseActivitiesOrderBy>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsCourseActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseActivitiesOrderBy>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsFillInTheBlanksArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlanksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlanksOrderBy>>;
  where?: InputMaybe<FillInTheBlanksBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsFillInTheBlanksAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlanksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlanksOrderBy>>;
  where?: InputMaybe<FillInTheBlanksBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsMatchingsArgs = {
  distinct_on?: InputMaybe<Array<MatchingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingsOrderBy>>;
  where?: InputMaybe<MatchingsBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsMatchingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingsOrderBy>>;
  where?: InputMaybe<MatchingsBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsMultipleChoicesArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoicesOrderBy>>;
  where?: InputMaybe<MultipleChoicesBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsMultipleChoicesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoicesOrderBy>>;
  where?: InputMaybe<MultipleChoicesBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsOpenAnswersArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswersOrderBy>>;
  where?: InputMaybe<OpenAnswersBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsOpenAnswersAggregateArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswersOrderBy>>;
  where?: InputMaybe<OpenAnswersBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsPhrasesArgs = {
  distinct_on?: InputMaybe<Array<PhrasesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhrasesOrderBy>>;
  where?: InputMaybe<PhrasesBoolExp>;
};


/** columns and relationships of "activity_sets" */
export type ActivitySetsPhrasesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PhrasesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhrasesOrderBy>>;
  where?: InputMaybe<PhrasesBoolExp>;
};

/** aggregated selection of "activity_sets" */
export type ActivitySetsAggregate = {
  __typename?: 'activity_sets_aggregate';
  aggregate?: Maybe<ActivitySetsAggregateFields>;
  nodes: Array<ActivitySets>;
};

/** aggregate fields of "activity_sets" */
export type ActivitySetsAggregateFields = {
  __typename?: 'activity_sets_aggregate_fields';
  avg?: Maybe<ActivitySetsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ActivitySetsMaxFields>;
  min?: Maybe<ActivitySetsMinFields>;
  stddev?: Maybe<ActivitySetsStddevFields>;
  stddev_pop?: Maybe<ActivitySetsStddevPopFields>;
  stddev_samp?: Maybe<ActivitySetsStddevSampFields>;
  sum?: Maybe<ActivitySetsSumFields>;
  var_pop?: Maybe<ActivitySetsVarPopFields>;
  var_samp?: Maybe<ActivitySetsVarSampFields>;
  variance?: Maybe<ActivitySetsVarianceFields>;
};


/** aggregate fields of "activity_sets" */
export type ActivitySetsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ActivitySetsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ActivitySetsAvgFields = {
  __typename?: 'activity_sets_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  forkedFrom?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  listeningId?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  vocabularyId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "activity_sets". All fields are combined with a logical 'AND'. */
export type ActivitySetsBoolExp = {
  _and?: InputMaybe<Array<ActivitySetsBoolExp>>;
  _not?: InputMaybe<ActivitySetsBoolExp>;
  _or?: InputMaybe<Array<ActivitySetsBoolExp>>;
  activitySetResponses?: InputMaybe<ActivitySetResponsesBoolExp>;
  activitySetResponses_aggregate?: InputMaybe<ActivitySetResponsesAggregateBoolExp>;
  anagrams?: InputMaybe<AnagramsBoolExp>;
  anagrams_aggregate?: InputMaybe<AnagramsAggregateBoolExp>;
  course_activities?: InputMaybe<CourseActivitiesBoolExp>;
  course_activities_aggregate?: InputMaybe<CourseActivitiesAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  fillInTheBlanks?: InputMaybe<FillInTheBlanksBoolExp>;
  fillInTheBlanks_aggregate?: InputMaybe<FillInTheBlanksAggregateBoolExp>;
  forkedFrom?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  image?: InputMaybe<ImagesBoolExp>;
  imageId?: InputMaybe<IntComparisonExp>;
  isPrivate?: InputMaybe<BooleanComparisonExp>;
  learnerLanguage?: InputMaybe<IntComparisonExp>;
  level?: InputMaybe<CefrLevelsEnumComparisonExp>;
  listening?: InputMaybe<ListeningsBoolExp>;
  listeningId?: InputMaybe<IntComparisonExp>;
  matchings?: InputMaybe<MatchingsBoolExp>;
  matchings_aggregate?: InputMaybe<MatchingsAggregateBoolExp>;
  multipleChoices?: InputMaybe<MultipleChoicesBoolExp>;
  multipleChoices_aggregate?: InputMaybe<MultipleChoicesAggregateBoolExp>;
  openAnswers?: InputMaybe<OpenAnswersBoolExp>;
  openAnswers_aggregate?: InputMaybe<OpenAnswersAggregateBoolExp>;
  phrases?: InputMaybe<PhrasesBoolExp>;
  phrases_aggregate?: InputMaybe<PhrasesAggregateBoolExp>;
  reading?: InputMaybe<ReadingsBoolExp>;
  readingId?: InputMaybe<IntComparisonExp>;
  subject?: InputMaybe<SubjectsBoolExp>;
  subjectId?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  vocabularyId?: InputMaybe<IntComparisonExp>;
  vocabularySet?: InputMaybe<VocabularySetsBoolExp>;
};

/** unique or primary key constraints on table "activity_sets" */
export enum ActivitySetsConstraint {
  /** unique or primary key constraint on columns "id" */
  ActivitySetPkey = 'activity_set_pkey'
}

/** input type for incrementing numeric columns in table "activity_sets" */
export type ActivitySetsIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  forkedFrom?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  learnerLanguage?: InputMaybe<Scalars['Int']['input']>;
  listeningId?: InputMaybe<Scalars['Int']['input']>;
  readingId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  vocabularyId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "activity_sets" */
export type ActivitySetsInsertInput = {
  activitySetResponses?: InputMaybe<ActivitySetResponsesArrRelInsertInput>;
  anagrams?: InputMaybe<AnagramsArrRelInsertInput>;
  course_activities?: InputMaybe<CourseActivitiesArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fillInTheBlanks?: InputMaybe<FillInTheBlanksArrRelInsertInput>;
  forkedFrom?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<ImagesObjRelInsertInput>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  learnerLanguage?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<CefrLevelsEnum>;
  listening?: InputMaybe<ListeningsObjRelInsertInput>;
  listeningId?: InputMaybe<Scalars['Int']['input']>;
  matchings?: InputMaybe<MatchingsArrRelInsertInput>;
  multipleChoices?: InputMaybe<MultipleChoicesArrRelInsertInput>;
  openAnswers?: InputMaybe<OpenAnswersArrRelInsertInput>;
  phrases?: InputMaybe<PhrasesArrRelInsertInput>;
  reading?: InputMaybe<ReadingsObjRelInsertInput>;
  readingId?: InputMaybe<Scalars['Int']['input']>;
  subject?: InputMaybe<SubjectsObjRelInsertInput>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  vocabularyId?: InputMaybe<Scalars['Int']['input']>;
  vocabularySet?: InputMaybe<VocabularySetsObjRelInsertInput>;
};

/** aggregate max on columns */
export type ActivitySetsMaxFields = {
  __typename?: 'activity_sets_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  forkedFrom?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  learnerLanguage?: Maybe<Scalars['Int']['output']>;
  listeningId?: Maybe<Scalars['Int']['output']>;
  readingId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  vocabularyId?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type ActivitySetsMinFields = {
  __typename?: 'activity_sets_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  forkedFrom?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  learnerLanguage?: Maybe<Scalars['Int']['output']>;
  listeningId?: Maybe<Scalars['Int']['output']>;
  readingId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  vocabularyId?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "activity_sets" */
export type ActivitySetsMutationResponse = {
  __typename?: 'activity_sets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ActivitySets>;
};

/** input type for inserting object relation for remote table "activity_sets" */
export type ActivitySetsObjRelInsertInput = {
  data: ActivitySetsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ActivitySetsOnConflict>;
};

/** on_conflict condition type for table "activity_sets" */
export type ActivitySetsOnConflict = {
  constraint: ActivitySetsConstraint;
  update_columns?: Array<ActivitySetsUpdateColumn>;
  where?: InputMaybe<ActivitySetsBoolExp>;
};

/** Ordering options when selecting data from "activity_sets". */
export type ActivitySetsOrderBy = {
  activitySetResponses_aggregate?: InputMaybe<ActivitySetResponsesAggregateOrderBy>;
  anagrams_aggregate?: InputMaybe<AnagramsAggregateOrderBy>;
  course_activities_aggregate?: InputMaybe<CourseActivitiesAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  fillInTheBlanks_aggregate?: InputMaybe<FillInTheBlanksAggregateOrderBy>;
  forkedFrom?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  image?: InputMaybe<ImagesOrderBy>;
  imageId?: InputMaybe<OrderBy>;
  isPrivate?: InputMaybe<OrderBy>;
  learnerLanguage?: InputMaybe<OrderBy>;
  level?: InputMaybe<OrderBy>;
  listening?: InputMaybe<ListeningsOrderBy>;
  listeningId?: InputMaybe<OrderBy>;
  matchings_aggregate?: InputMaybe<MatchingsAggregateOrderBy>;
  multipleChoices_aggregate?: InputMaybe<MultipleChoicesAggregateOrderBy>;
  openAnswers_aggregate?: InputMaybe<OpenAnswersAggregateOrderBy>;
  phrases_aggregate?: InputMaybe<PhrasesAggregateOrderBy>;
  reading?: InputMaybe<ReadingsOrderBy>;
  readingId?: InputMaybe<OrderBy>;
  subject?: InputMaybe<SubjectsOrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  vocabularyId?: InputMaybe<OrderBy>;
  vocabularySet?: InputMaybe<VocabularySetsOrderBy>;
};

/** primary key columns input for table: activity_sets */
export type ActivitySetsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "activity_sets" */
export enum ActivitySetsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  ForkedFrom = 'forkedFrom',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  LearnerLanguage = 'learnerLanguage',
  /** column name */
  Level = 'level',
  /** column name */
  ListeningId = 'listeningId',
  /** column name */
  ReadingId = 'readingId',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VocabularyId = 'vocabularyId'
}

/** input type for updating data in table "activity_sets" */
export type ActivitySetsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  forkedFrom?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  learnerLanguage?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<CefrLevelsEnum>;
  listeningId?: InputMaybe<Scalars['Int']['input']>;
  readingId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  vocabularyId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ActivitySetsStddevFields = {
  __typename?: 'activity_sets_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  forkedFrom?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  listeningId?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  vocabularyId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ActivitySetsStddevPopFields = {
  __typename?: 'activity_sets_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  forkedFrom?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  listeningId?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  vocabularyId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ActivitySetsStddevSampFields = {
  __typename?: 'activity_sets_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  forkedFrom?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  listeningId?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  vocabularyId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "activity_sets" */
export type ActivitySetsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ActivitySetsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ActivitySetsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  forkedFrom?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  learnerLanguage?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<CefrLevelsEnum>;
  listeningId?: InputMaybe<Scalars['Int']['input']>;
  readingId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  vocabularyId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ActivitySetsSumFields = {
  __typename?: 'activity_sets_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  forkedFrom?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  learnerLanguage?: Maybe<Scalars['Int']['output']>;
  listeningId?: Maybe<Scalars['Int']['output']>;
  readingId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  vocabularyId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "activity_sets" */
export enum ActivitySetsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  ForkedFrom = 'forkedFrom',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  LearnerLanguage = 'learnerLanguage',
  /** column name */
  Level = 'level',
  /** column name */
  ListeningId = 'listeningId',
  /** column name */
  ReadingId = 'readingId',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VocabularyId = 'vocabularyId'
}

export type ActivitySetsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ActivitySetsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ActivitySetsSetInput>;
  /** filter the rows which have to be updated */
  where: ActivitySetsBoolExp;
};

/** aggregate var_pop on columns */
export type ActivitySetsVarPopFields = {
  __typename?: 'activity_sets_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  forkedFrom?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  listeningId?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  vocabularyId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ActivitySetsVarSampFields = {
  __typename?: 'activity_sets_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  forkedFrom?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  listeningId?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  vocabularyId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ActivitySetsVarianceFields = {
  __typename?: 'activity_sets_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  forkedFrom?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  listeningId?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  vocabularyId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "addresses" */
export type Addresses = {
  __typename?: 'addresses';
  city: Scalars['String']['output'];
  country: Scalars['String']['output'];
  effectiveAt: Scalars['date']['output'];
  id: Scalars['Int']['output'];
  line1: Scalars['String']['output'];
  line2?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  postalCode: Scalars['String']['output'];
  postedAt: Scalars['date']['output'];
  state: Scalars['String']['output'];
  userId: Scalars['Int']['output'];
};

/** aggregated selection of "addresses" */
export type AddressesAggregate = {
  __typename?: 'addresses_aggregate';
  aggregate?: Maybe<AddressesAggregateFields>;
  nodes: Array<Addresses>;
};

export type AddressesAggregateBoolExp = {
  count?: InputMaybe<AddressesAggregateBoolExpCount>;
};

export type AddressesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<AddressesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AddressesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "addresses" */
export type AddressesAggregateFields = {
  __typename?: 'addresses_aggregate_fields';
  avg?: Maybe<AddressesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AddressesMaxFields>;
  min?: Maybe<AddressesMinFields>;
  stddev?: Maybe<AddressesStddevFields>;
  stddev_pop?: Maybe<AddressesStddevPopFields>;
  stddev_samp?: Maybe<AddressesStddevSampFields>;
  sum?: Maybe<AddressesSumFields>;
  var_pop?: Maybe<AddressesVarPopFields>;
  var_samp?: Maybe<AddressesVarSampFields>;
  variance?: Maybe<AddressesVarianceFields>;
};


/** aggregate fields of "addresses" */
export type AddressesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AddressesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "addresses" */
export type AddressesAggregateOrderBy = {
  avg?: InputMaybe<AddressesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<AddressesMaxOrderBy>;
  min?: InputMaybe<AddressesMinOrderBy>;
  stddev?: InputMaybe<AddressesStddevOrderBy>;
  stddev_pop?: InputMaybe<AddressesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<AddressesStddevSampOrderBy>;
  sum?: InputMaybe<AddressesSumOrderBy>;
  var_pop?: InputMaybe<AddressesVarPopOrderBy>;
  var_samp?: InputMaybe<AddressesVarSampOrderBy>;
  variance?: InputMaybe<AddressesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "addresses" */
export type AddressesArrRelInsertInput = {
  data: Array<AddressesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<AddressesOnConflict>;
};

/** aggregate avg on columns */
export type AddressesAvgFields = {
  __typename?: 'addresses_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "addresses" */
export type AddressesAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "addresses". All fields are combined with a logical 'AND'. */
export type AddressesBoolExp = {
  _and?: InputMaybe<Array<AddressesBoolExp>>;
  _not?: InputMaybe<AddressesBoolExp>;
  _or?: InputMaybe<Array<AddressesBoolExp>>;
  city?: InputMaybe<StringComparisonExp>;
  country?: InputMaybe<StringComparisonExp>;
  effectiveAt?: InputMaybe<DateComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  line1?: InputMaybe<StringComparisonExp>;
  line2?: InputMaybe<StringComparisonExp>;
  phone?: InputMaybe<StringComparisonExp>;
  postalCode?: InputMaybe<StringComparisonExp>;
  postedAt?: InputMaybe<DateComparisonExp>;
  state?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "addresses" */
export enum AddressesConstraint {
  /** unique or primary key constraint on columns "id" */
  AddressesPkey = 'addresses_pkey'
}

/** input type for incrementing numeric columns in table "addresses" */
export type AddressesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "addresses" */
export type AddressesInsertInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  effectiveAt?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  line1?: InputMaybe<Scalars['String']['input']>;
  line2?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  postedAt?: InputMaybe<Scalars['date']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type AddressesMaxFields = {
  __typename?: 'addresses_max_fields';
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  effectiveAt?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  line1?: Maybe<Scalars['String']['output']>;
  line2?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  postalCode?: Maybe<Scalars['String']['output']>;
  postedAt?: Maybe<Scalars['date']['output']>;
  state?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "addresses" */
export type AddressesMaxOrderBy = {
  city?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  effectiveAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  line1?: InputMaybe<OrderBy>;
  line2?: InputMaybe<OrderBy>;
  phone?: InputMaybe<OrderBy>;
  postalCode?: InputMaybe<OrderBy>;
  postedAt?: InputMaybe<OrderBy>;
  state?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type AddressesMinFields = {
  __typename?: 'addresses_min_fields';
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  effectiveAt?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  line1?: Maybe<Scalars['String']['output']>;
  line2?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  postalCode?: Maybe<Scalars['String']['output']>;
  postedAt?: Maybe<Scalars['date']['output']>;
  state?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "addresses" */
export type AddressesMinOrderBy = {
  city?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  effectiveAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  line1?: InputMaybe<OrderBy>;
  line2?: InputMaybe<OrderBy>;
  phone?: InputMaybe<OrderBy>;
  postalCode?: InputMaybe<OrderBy>;
  postedAt?: InputMaybe<OrderBy>;
  state?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "addresses" */
export type AddressesMutationResponse = {
  __typename?: 'addresses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Addresses>;
};

/** on_conflict condition type for table "addresses" */
export type AddressesOnConflict = {
  constraint: AddressesConstraint;
  update_columns?: Array<AddressesUpdateColumn>;
  where?: InputMaybe<AddressesBoolExp>;
};

/** Ordering options when selecting data from "addresses". */
export type AddressesOrderBy = {
  city?: InputMaybe<OrderBy>;
  country?: InputMaybe<OrderBy>;
  effectiveAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  line1?: InputMaybe<OrderBy>;
  line2?: InputMaybe<OrderBy>;
  phone?: InputMaybe<OrderBy>;
  postalCode?: InputMaybe<OrderBy>;
  postedAt?: InputMaybe<OrderBy>;
  state?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: addresses */
export type AddressesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "addresses" */
export enum AddressesSelectColumn {
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  EffectiveAt = 'effectiveAt',
  /** column name */
  Id = 'id',
  /** column name */
  Line1 = 'line1',
  /** column name */
  Line2 = 'line2',
  /** column name */
  Phone = 'phone',
  /** column name */
  PostalCode = 'postalCode',
  /** column name */
  PostedAt = 'postedAt',
  /** column name */
  State = 'state',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "addresses" */
export type AddressesSetInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  effectiveAt?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  line1?: InputMaybe<Scalars['String']['input']>;
  line2?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  postedAt?: InputMaybe<Scalars['date']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type AddressesStddevFields = {
  __typename?: 'addresses_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "addresses" */
export type AddressesStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type AddressesStddevPopFields = {
  __typename?: 'addresses_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "addresses" */
export type AddressesStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type AddressesStddevSampFields = {
  __typename?: 'addresses_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "addresses" */
export type AddressesStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "addresses" */
export type AddressesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AddressesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AddressesStreamCursorValueInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  effectiveAt?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  line1?: InputMaybe<Scalars['String']['input']>;
  line2?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  postedAt?: InputMaybe<Scalars['date']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type AddressesSumFields = {
  __typename?: 'addresses_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "addresses" */
export type AddressesSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** update columns of table "addresses" */
export enum AddressesUpdateColumn {
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  EffectiveAt = 'effectiveAt',
  /** column name */
  Id = 'id',
  /** column name */
  Line1 = 'line1',
  /** column name */
  Line2 = 'line2',
  /** column name */
  Phone = 'phone',
  /** column name */
  PostalCode = 'postalCode',
  /** column name */
  PostedAt = 'postedAt',
  /** column name */
  State = 'state',
  /** column name */
  UserId = 'userId'
}

export type AddressesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AddressesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AddressesSetInput>;
  /** filter the rows which have to be updated */
  where: AddressesBoolExp;
};

/** aggregate var_pop on columns */
export type AddressesVarPopFields = {
  __typename?: 'addresses_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "addresses" */
export type AddressesVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type AddressesVarSampFields = {
  __typename?: 'addresses_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "addresses" */
export type AddressesVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type AddressesVarianceFields = {
  __typename?: 'addresses_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "addresses" */
export type AddressesVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "anagram_responses" */
export type AnagramResponses = {
  __typename?: 'anagram_responses';
  activitySetResponseId: Scalars['Int']['output'];
  /** An object relationship */
  anagram: Anagrams;
  anagramId: Scalars['Int']['output'];
  answer: Scalars['String']['output'];
  createdBy: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  isCorrect: Scalars['Boolean']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "anagram_responses" */
export type AnagramResponsesAggregate = {
  __typename?: 'anagram_responses_aggregate';
  aggregate?: Maybe<AnagramResponsesAggregateFields>;
  nodes: Array<AnagramResponses>;
};

export type AnagramResponsesAggregateBoolExp = {
  bool_and?: InputMaybe<AnagramResponsesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<AnagramResponsesAggregateBoolExpBoolOr>;
  count?: InputMaybe<AnagramResponsesAggregateBoolExpCount>;
};

export type AnagramResponsesAggregateBoolExpBoolAnd = {
  arguments: AnagramResponsesSelectColumnAnagramResponsesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AnagramResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type AnagramResponsesAggregateBoolExpBoolOr = {
  arguments: AnagramResponsesSelectColumnAnagramResponsesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AnagramResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type AnagramResponsesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<AnagramResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AnagramResponsesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "anagram_responses" */
export type AnagramResponsesAggregateFields = {
  __typename?: 'anagram_responses_aggregate_fields';
  avg?: Maybe<AnagramResponsesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AnagramResponsesMaxFields>;
  min?: Maybe<AnagramResponsesMinFields>;
  stddev?: Maybe<AnagramResponsesStddevFields>;
  stddev_pop?: Maybe<AnagramResponsesStddevPopFields>;
  stddev_samp?: Maybe<AnagramResponsesStddevSampFields>;
  sum?: Maybe<AnagramResponsesSumFields>;
  var_pop?: Maybe<AnagramResponsesVarPopFields>;
  var_samp?: Maybe<AnagramResponsesVarSampFields>;
  variance?: Maybe<AnagramResponsesVarianceFields>;
};


/** aggregate fields of "anagram_responses" */
export type AnagramResponsesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AnagramResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "anagram_responses" */
export type AnagramResponsesAggregateOrderBy = {
  avg?: InputMaybe<AnagramResponsesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<AnagramResponsesMaxOrderBy>;
  min?: InputMaybe<AnagramResponsesMinOrderBy>;
  stddev?: InputMaybe<AnagramResponsesStddevOrderBy>;
  stddev_pop?: InputMaybe<AnagramResponsesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<AnagramResponsesStddevSampOrderBy>;
  sum?: InputMaybe<AnagramResponsesSumOrderBy>;
  var_pop?: InputMaybe<AnagramResponsesVarPopOrderBy>;
  var_samp?: InputMaybe<AnagramResponsesVarSampOrderBy>;
  variance?: InputMaybe<AnagramResponsesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "anagram_responses" */
export type AnagramResponsesArrRelInsertInput = {
  data: Array<AnagramResponsesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<AnagramResponsesOnConflict>;
};

/** aggregate avg on columns */
export type AnagramResponsesAvgFields = {
  __typename?: 'anagram_responses_avg_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  anagramId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "anagram_responses" */
export type AnagramResponsesAvgOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "anagram_responses". All fields are combined with a logical 'AND'. */
export type AnagramResponsesBoolExp = {
  _and?: InputMaybe<Array<AnagramResponsesBoolExp>>;
  _not?: InputMaybe<AnagramResponsesBoolExp>;
  _or?: InputMaybe<Array<AnagramResponsesBoolExp>>;
  activitySetResponseId?: InputMaybe<IntComparisonExp>;
  anagram?: InputMaybe<AnagramsBoolExp>;
  anagramId?: InputMaybe<IntComparisonExp>;
  answer?: InputMaybe<StringComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isCorrect?: InputMaybe<BooleanComparisonExp>;
  updated_at?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "anagram_responses" */
export enum AnagramResponsesConstraint {
  /** unique or primary key constraint on columns "id" */
  AnagramResponsesPkey = 'anagram_responses_pkey'
}

/** input type for incrementing numeric columns in table "anagram_responses" */
export type AnagramResponsesIncInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  anagramId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "anagram_responses" */
export type AnagramResponsesInsertInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  anagram?: InputMaybe<AnagramsObjRelInsertInput>;
  anagramId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type AnagramResponsesMaxFields = {
  __typename?: 'anagram_responses_max_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  anagramId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "anagram_responses" */
export type AnagramResponsesMaxOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type AnagramResponsesMinFields = {
  __typename?: 'anagram_responses_min_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  anagramId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "anagram_responses" */
export type AnagramResponsesMinOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "anagram_responses" */
export type AnagramResponsesMutationResponse = {
  __typename?: 'anagram_responses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AnagramResponses>;
};

/** on_conflict condition type for table "anagram_responses" */
export type AnagramResponsesOnConflict = {
  constraint: AnagramResponsesConstraint;
  update_columns?: Array<AnagramResponsesUpdateColumn>;
  where?: InputMaybe<AnagramResponsesBoolExp>;
};

/** Ordering options when selecting data from "anagram_responses". */
export type AnagramResponsesOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagram?: InputMaybe<AnagramsOrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCorrect?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: anagram_responses */
export type AnagramResponsesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "anagram_responses" */
export enum AnagramResponsesSelectColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  AnagramId = 'anagramId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "anagram_responses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "anagram_responses" */
export enum AnagramResponsesSelectColumnAnagramResponsesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** select "anagram_responses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "anagram_responses" */
export enum AnagramResponsesSelectColumnAnagramResponsesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** input type for updating data in table "anagram_responses" */
export type AnagramResponsesSetInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  anagramId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type AnagramResponsesStddevFields = {
  __typename?: 'anagram_responses_stddev_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  anagramId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "anagram_responses" */
export type AnagramResponsesStddevOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type AnagramResponsesStddevPopFields = {
  __typename?: 'anagram_responses_stddev_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  anagramId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "anagram_responses" */
export type AnagramResponsesStddevPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type AnagramResponsesStddevSampFields = {
  __typename?: 'anagram_responses_stddev_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  anagramId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "anagram_responses" */
export type AnagramResponsesStddevSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "anagram_responses" */
export type AnagramResponsesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AnagramResponsesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AnagramResponsesStreamCursorValueInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  anagramId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type AnagramResponsesSumFields = {
  __typename?: 'anagram_responses_sum_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  anagramId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "anagram_responses" */
export type AnagramResponsesSumOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** update columns of table "anagram_responses" */
export enum AnagramResponsesUpdateColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  AnagramId = 'anagramId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type AnagramResponsesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AnagramResponsesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AnagramResponsesSetInput>;
  /** filter the rows which have to be updated */
  where: AnagramResponsesBoolExp;
};

/** aggregate var_pop on columns */
export type AnagramResponsesVarPopFields = {
  __typename?: 'anagram_responses_var_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  anagramId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "anagram_responses" */
export type AnagramResponsesVarPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type AnagramResponsesVarSampFields = {
  __typename?: 'anagram_responses_var_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  anagramId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "anagram_responses" */
export type AnagramResponsesVarSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type AnagramResponsesVarianceFields = {
  __typename?: 'anagram_responses_variance_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  anagramId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "anagram_responses" */
export type AnagramResponsesVarianceOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  anagramId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "anagrams" */
export type Anagrams = {
  __typename?: 'anagrams';
  activitySetId: Scalars['Int']['output'];
  audio?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** An object relationship */
  image?: Maybe<Images>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  word: Scalars['String']['output'];
};

/** aggregated selection of "anagrams" */
export type AnagramsAggregate = {
  __typename?: 'anagrams_aggregate';
  aggregate?: Maybe<AnagramsAggregateFields>;
  nodes: Array<Anagrams>;
};

export type AnagramsAggregateBoolExp = {
  count?: InputMaybe<AnagramsAggregateBoolExpCount>;
};

export type AnagramsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<AnagramsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AnagramsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "anagrams" */
export type AnagramsAggregateFields = {
  __typename?: 'anagrams_aggregate_fields';
  avg?: Maybe<AnagramsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AnagramsMaxFields>;
  min?: Maybe<AnagramsMinFields>;
  stddev?: Maybe<AnagramsStddevFields>;
  stddev_pop?: Maybe<AnagramsStddevPopFields>;
  stddev_samp?: Maybe<AnagramsStddevSampFields>;
  sum?: Maybe<AnagramsSumFields>;
  var_pop?: Maybe<AnagramsVarPopFields>;
  var_samp?: Maybe<AnagramsVarSampFields>;
  variance?: Maybe<AnagramsVarianceFields>;
};


/** aggregate fields of "anagrams" */
export type AnagramsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AnagramsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "anagrams" */
export type AnagramsAggregateOrderBy = {
  avg?: InputMaybe<AnagramsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<AnagramsMaxOrderBy>;
  min?: InputMaybe<AnagramsMinOrderBy>;
  stddev?: InputMaybe<AnagramsStddevOrderBy>;
  stddev_pop?: InputMaybe<AnagramsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<AnagramsStddevSampOrderBy>;
  sum?: InputMaybe<AnagramsSumOrderBy>;
  var_pop?: InputMaybe<AnagramsVarPopOrderBy>;
  var_samp?: InputMaybe<AnagramsVarSampOrderBy>;
  variance?: InputMaybe<AnagramsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "anagrams" */
export type AnagramsArrRelInsertInput = {
  data: Array<AnagramsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<AnagramsOnConflict>;
};

/** aggregate avg on columns */
export type AnagramsAvgFields = {
  __typename?: 'anagrams_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "anagrams" */
export type AnagramsAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "anagrams". All fields are combined with a logical 'AND'. */
export type AnagramsBoolExp = {
  _and?: InputMaybe<Array<AnagramsBoolExp>>;
  _not?: InputMaybe<AnagramsBoolExp>;
  _or?: InputMaybe<Array<AnagramsBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  audio?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  image?: InputMaybe<ImagesBoolExp>;
  imageId?: InputMaybe<IntComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  word?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "anagrams" */
export enum AnagramsConstraint {
  /** unique or primary key constraint on columns "id" */
  AnagramsPkey = 'anagrams_pkey'
}

/** input type for incrementing numeric columns in table "anagrams" */
export type AnagramsIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "anagrams" */
export type AnagramsInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audio?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<ImagesObjRelInsertInput>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type AnagramsMaxFields = {
  __typename?: 'anagrams_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  audio?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  word?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "anagrams" */
export type AnagramsMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audio?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type AnagramsMinFields = {
  __typename?: 'anagrams_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  audio?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  word?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "anagrams" */
export type AnagramsMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audio?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "anagrams" */
export type AnagramsMutationResponse = {
  __typename?: 'anagrams_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Anagrams>;
};

/** input type for inserting object relation for remote table "anagrams" */
export type AnagramsObjRelInsertInput = {
  data: AnagramsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<AnagramsOnConflict>;
};

/** on_conflict condition type for table "anagrams" */
export type AnagramsOnConflict = {
  constraint: AnagramsConstraint;
  update_columns?: Array<AnagramsUpdateColumn>;
  where?: InputMaybe<AnagramsBoolExp>;
};

/** Ordering options when selecting data from "anagrams". */
export type AnagramsOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audio?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  image?: InputMaybe<ImagesOrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: anagrams */
export type AnagramsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "anagrams" */
export enum AnagramsSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  Audio = 'audio',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Word = 'word'
}

/** input type for updating data in table "anagrams" */
export type AnagramsSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audio?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type AnagramsStddevFields = {
  __typename?: 'anagrams_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "anagrams" */
export type AnagramsStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type AnagramsStddevPopFields = {
  __typename?: 'anagrams_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "anagrams" */
export type AnagramsStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type AnagramsStddevSampFields = {
  __typename?: 'anagrams_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "anagrams" */
export type AnagramsStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "anagrams" */
export type AnagramsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AnagramsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AnagramsStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audio?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type AnagramsSumFields = {
  __typename?: 'anagrams_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "anagrams" */
export type AnagramsSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** update columns of table "anagrams" */
export enum AnagramsUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  Audio = 'audio',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Word = 'word'
}

export type AnagramsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AnagramsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AnagramsSetInput>;
  /** filter the rows which have to be updated */
  where: AnagramsBoolExp;
};

/** aggregate var_pop on columns */
export type AnagramsVarPopFields = {
  __typename?: 'anagrams_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "anagrams" */
export type AnagramsVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type AnagramsVarSampFields = {
  __typename?: 'anagrams_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "anagrams" */
export type AnagramsVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type AnagramsVarianceFields = {
  __typename?: 'anagrams_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "anagrams" */
export type AnagramsVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** columns and relationships of "annotations" */
export type Annotations = {
  __typename?: 'annotations';
  /** An array relationship */
  classAnnotations: Array<ClassAnnotations>;
  /** An aggregate relationship */
  classAnnotations_aggregate: ClassAnnotationsAggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  from: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  readingId: Scalars['Int']['output'];
  text: Scalars['String']['output'];
  to: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
};


/** columns and relationships of "annotations" */
export type AnnotationsClassAnnotationsArgs = {
  distinct_on?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassAnnotationsOrderBy>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};


/** columns and relationships of "annotations" */
export type AnnotationsClassAnnotationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassAnnotationsOrderBy>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};

/** aggregated selection of "annotations" */
export type AnnotationsAggregate = {
  __typename?: 'annotations_aggregate';
  aggregate?: Maybe<AnnotationsAggregateFields>;
  nodes: Array<Annotations>;
};

/** aggregate fields of "annotations" */
export type AnnotationsAggregateFields = {
  __typename?: 'annotations_aggregate_fields';
  avg?: Maybe<AnnotationsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AnnotationsMaxFields>;
  min?: Maybe<AnnotationsMinFields>;
  stddev?: Maybe<AnnotationsStddevFields>;
  stddev_pop?: Maybe<AnnotationsStddevPopFields>;
  stddev_samp?: Maybe<AnnotationsStddevSampFields>;
  sum?: Maybe<AnnotationsSumFields>;
  var_pop?: Maybe<AnnotationsVarPopFields>;
  var_samp?: Maybe<AnnotationsVarSampFields>;
  variance?: Maybe<AnnotationsVarianceFields>;
};


/** aggregate fields of "annotations" */
export type AnnotationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AnnotationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type AnnotationsAvgFields = {
  __typename?: 'annotations_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  from?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  to?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "annotations". All fields are combined with a logical 'AND'. */
export type AnnotationsBoolExp = {
  _and?: InputMaybe<Array<AnnotationsBoolExp>>;
  _not?: InputMaybe<AnnotationsBoolExp>;
  _or?: InputMaybe<Array<AnnotationsBoolExp>>;
  classAnnotations?: InputMaybe<ClassAnnotationsBoolExp>;
  classAnnotations_aggregate?: InputMaybe<ClassAnnotationsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  from?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  readingId?: InputMaybe<IntComparisonExp>;
  text?: InputMaybe<StringComparisonExp>;
  to?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "annotations" */
export enum AnnotationsConstraint {
  /** unique or primary key constraint on columns "id" */
  AnnotationsPkey = 'annotations_pkey'
}

/** input type for incrementing numeric columns in table "annotations" */
export type AnnotationsIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  from?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  readingId?: InputMaybe<Scalars['Int']['input']>;
  to?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "annotations" */
export type AnnotationsInsertInput = {
  classAnnotations?: InputMaybe<ClassAnnotationsArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  from?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  readingId?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  to?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type AnnotationsMaxFields = {
  __typename?: 'annotations_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  from?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  readingId?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  to?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type AnnotationsMinFields = {
  __typename?: 'annotations_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  from?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  readingId?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  to?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "annotations" */
export type AnnotationsMutationResponse = {
  __typename?: 'annotations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Annotations>;
};

/** input type for inserting object relation for remote table "annotations" */
export type AnnotationsObjRelInsertInput = {
  data: AnnotationsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<AnnotationsOnConflict>;
};

/** on_conflict condition type for table "annotations" */
export type AnnotationsOnConflict = {
  constraint: AnnotationsConstraint;
  update_columns?: Array<AnnotationsUpdateColumn>;
  where?: InputMaybe<AnnotationsBoolExp>;
};

/** Ordering options when selecting data from "annotations". */
export type AnnotationsOrderBy = {
  classAnnotations_aggregate?: InputMaybe<ClassAnnotationsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  from?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  readingId?: InputMaybe<OrderBy>;
  text?: InputMaybe<OrderBy>;
  to?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: annotations */
export type AnnotationsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "annotations" */
export enum AnnotationsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  From = 'from',
  /** column name */
  Id = 'id',
  /** column name */
  ReadingId = 'readingId',
  /** column name */
  Text = 'text',
  /** column name */
  To = 'to',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "annotations" */
export type AnnotationsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  from?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  readingId?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  to?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type AnnotationsStddevFields = {
  __typename?: 'annotations_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  from?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  to?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type AnnotationsStddevPopFields = {
  __typename?: 'annotations_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  from?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  to?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type AnnotationsStddevSampFields = {
  __typename?: 'annotations_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  from?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  to?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "annotations" */
export type AnnotationsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AnnotationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AnnotationsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  from?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  readingId?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  to?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type AnnotationsSumFields = {
  __typename?: 'annotations_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  from?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  readingId?: Maybe<Scalars['Int']['output']>;
  to?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "annotations" */
export enum AnnotationsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  From = 'from',
  /** column name */
  Id = 'id',
  /** column name */
  ReadingId = 'readingId',
  /** column name */
  Text = 'text',
  /** column name */
  To = 'to',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type AnnotationsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AnnotationsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AnnotationsSetInput>;
  /** filter the rows which have to be updated */
  where: AnnotationsBoolExp;
};

/** aggregate var_pop on columns */
export type AnnotationsVarPopFields = {
  __typename?: 'annotations_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  from?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  to?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type AnnotationsVarSampFields = {
  __typename?: 'annotations_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  from?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  to?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type AnnotationsVarianceFields = {
  __typename?: 'annotations_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  from?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  readingId?: Maybe<Scalars['Float']['output']>;
  to?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "application_reviews" */
export type ApplicationReviews = {
  __typename?: 'application_reviews';
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  mainReasonUnapproved?: Maybe<Scalars['String']['output']>;
  requestBioChange: Scalars['Boolean']['output'];
  requestCredentialChange: Scalars['Boolean']['output'];
  requestImageChange: Scalars['Boolean']['output'];
  requestSubjectChange: Scalars['Boolean']['output'];
  requestVideoChange: Scalars['Boolean']['output'];
  teacherId: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "application_reviews" */
export type ApplicationReviewsAggregate = {
  __typename?: 'application_reviews_aggregate';
  aggregate?: Maybe<ApplicationReviewsAggregateFields>;
  nodes: Array<ApplicationReviews>;
};

/** aggregate fields of "application_reviews" */
export type ApplicationReviewsAggregateFields = {
  __typename?: 'application_reviews_aggregate_fields';
  avg?: Maybe<ApplicationReviewsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationReviewsMaxFields>;
  min?: Maybe<ApplicationReviewsMinFields>;
  stddev?: Maybe<ApplicationReviewsStddevFields>;
  stddev_pop?: Maybe<ApplicationReviewsStddevPopFields>;
  stddev_samp?: Maybe<ApplicationReviewsStddevSampFields>;
  sum?: Maybe<ApplicationReviewsSumFields>;
  var_pop?: Maybe<ApplicationReviewsVarPopFields>;
  var_samp?: Maybe<ApplicationReviewsVarSampFields>;
  variance?: Maybe<ApplicationReviewsVarianceFields>;
};


/** aggregate fields of "application_reviews" */
export type ApplicationReviewsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationReviewsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ApplicationReviewsAvgFields = {
  __typename?: 'application_reviews_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "application_reviews". All fields are combined with a logical 'AND'. */
export type ApplicationReviewsBoolExp = {
  _and?: InputMaybe<Array<ApplicationReviewsBoolExp>>;
  _not?: InputMaybe<ApplicationReviewsBoolExp>;
  _or?: InputMaybe<Array<ApplicationReviewsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  mainReasonUnapproved?: InputMaybe<StringComparisonExp>;
  requestBioChange?: InputMaybe<BooleanComparisonExp>;
  requestCredentialChange?: InputMaybe<BooleanComparisonExp>;
  requestImageChange?: InputMaybe<BooleanComparisonExp>;
  requestSubjectChange?: InputMaybe<BooleanComparisonExp>;
  requestVideoChange?: InputMaybe<BooleanComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "application_reviews" */
export enum ApplicationReviewsConstraint {
  /** unique or primary key constraint on columns "id" */
  ApplicationReviewPkey = 'application_review_pkey',
  /** unique or primary key constraint on columns "teacher_id" */
  ApplicationReviewsTeacherIdKey = 'application_reviews_teacher_id_key'
}

/** input type for incrementing numeric columns in table "application_reviews" */
export type ApplicationReviewsIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "application_reviews" */
export type ApplicationReviewsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  mainReasonUnapproved?: InputMaybe<Scalars['String']['input']>;
  requestBioChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestCredentialChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestImageChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestSubjectChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestVideoChange?: InputMaybe<Scalars['Boolean']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ApplicationReviewsMaxFields = {
  __typename?: 'application_reviews_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  mainReasonUnapproved?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type ApplicationReviewsMinFields = {
  __typename?: 'application_reviews_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  mainReasonUnapproved?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "application_reviews" */
export type ApplicationReviewsMutationResponse = {
  __typename?: 'application_reviews_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationReviews>;
};

/** input type for inserting object relation for remote table "application_reviews" */
export type ApplicationReviewsObjRelInsertInput = {
  data: ApplicationReviewsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationReviewsOnConflict>;
};

/** on_conflict condition type for table "application_reviews" */
export type ApplicationReviewsOnConflict = {
  constraint: ApplicationReviewsConstraint;
  update_columns?: Array<ApplicationReviewsUpdateColumn>;
  where?: InputMaybe<ApplicationReviewsBoolExp>;
};

/** Ordering options when selecting data from "application_reviews". */
export type ApplicationReviewsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mainReasonUnapproved?: InputMaybe<OrderBy>;
  requestBioChange?: InputMaybe<OrderBy>;
  requestCredentialChange?: InputMaybe<OrderBy>;
  requestImageChange?: InputMaybe<OrderBy>;
  requestSubjectChange?: InputMaybe<OrderBy>;
  requestVideoChange?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: application_reviews */
export type ApplicationReviewsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "application_reviews" */
export enum ApplicationReviewsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  MainReasonUnapproved = 'mainReasonUnapproved',
  /** column name */
  RequestBioChange = 'requestBioChange',
  /** column name */
  RequestCredentialChange = 'requestCredentialChange',
  /** column name */
  RequestImageChange = 'requestImageChange',
  /** column name */
  RequestSubjectChange = 'requestSubjectChange',
  /** column name */
  RequestVideoChange = 'requestVideoChange',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "application_reviews" */
export type ApplicationReviewsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  mainReasonUnapproved?: InputMaybe<Scalars['String']['input']>;
  requestBioChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestCredentialChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestImageChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestSubjectChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestVideoChange?: InputMaybe<Scalars['Boolean']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type ApplicationReviewsStddevFields = {
  __typename?: 'application_reviews_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ApplicationReviewsStddevPopFields = {
  __typename?: 'application_reviews_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ApplicationReviewsStddevSampFields = {
  __typename?: 'application_reviews_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "application_reviews" */
export type ApplicationReviewsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ApplicationReviewsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationReviewsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  mainReasonUnapproved?: InputMaybe<Scalars['String']['input']>;
  requestBioChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestCredentialChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestImageChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestSubjectChange?: InputMaybe<Scalars['Boolean']['input']>;
  requestVideoChange?: InputMaybe<Scalars['Boolean']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type ApplicationReviewsSumFields = {
  __typename?: 'application_reviews_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "application_reviews" */
export enum ApplicationReviewsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  MainReasonUnapproved = 'mainReasonUnapproved',
  /** column name */
  RequestBioChange = 'requestBioChange',
  /** column name */
  RequestCredentialChange = 'requestCredentialChange',
  /** column name */
  RequestImageChange = 'requestImageChange',
  /** column name */
  RequestSubjectChange = 'requestSubjectChange',
  /** column name */
  RequestVideoChange = 'requestVideoChange',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ApplicationReviewsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ApplicationReviewsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationReviewsSetInput>;
  /** filter the rows which have to be updated */
  where: ApplicationReviewsBoolExp;
};

/** aggregate var_pop on columns */
export type ApplicationReviewsVarPopFields = {
  __typename?: 'application_reviews_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ApplicationReviewsVarSampFields = {
  __typename?: 'application_reviews_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ApplicationReviewsVarianceFields = {
  __typename?: 'application_reviews_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "availability_times" */
export type AvailabilityTimes = {
  __typename?: 'availability_times';
  createdAt: Scalars['timestamptz']['output'];
  day: Scalars['Int']['output'];
  deletedAt?: Maybe<Scalars['date']['output']>;
  id: Scalars['Int']['output'];
  isClass?: Maybe<Scalars['Boolean']['output']>;
  isFree?: Maybe<Scalars['Boolean']['output']>;
  teacherId: Scalars['Int']['output'];
  time: Scalars['time']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
};

/** aggregated selection of "availability_times" */
export type AvailabilityTimesAggregate = {
  __typename?: 'availability_times_aggregate';
  aggregate?: Maybe<AvailabilityTimesAggregateFields>;
  nodes: Array<AvailabilityTimes>;
};

/** aggregate fields of "availability_times" */
export type AvailabilityTimesAggregateFields = {
  __typename?: 'availability_times_aggregate_fields';
  avg?: Maybe<AvailabilityTimesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AvailabilityTimesMaxFields>;
  min?: Maybe<AvailabilityTimesMinFields>;
  stddev?: Maybe<AvailabilityTimesStddevFields>;
  stddev_pop?: Maybe<AvailabilityTimesStddevPopFields>;
  stddev_samp?: Maybe<AvailabilityTimesStddevSampFields>;
  sum?: Maybe<AvailabilityTimesSumFields>;
  var_pop?: Maybe<AvailabilityTimesVarPopFields>;
  var_samp?: Maybe<AvailabilityTimesVarSampFields>;
  variance?: Maybe<AvailabilityTimesVarianceFields>;
};


/** aggregate fields of "availability_times" */
export type AvailabilityTimesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AvailabilityTimesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type AvailabilityTimesAvgFields = {
  __typename?: 'availability_times_avg_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "availability_times". All fields are combined with a logical 'AND'. */
export type AvailabilityTimesBoolExp = {
  _and?: InputMaybe<Array<AvailabilityTimesBoolExp>>;
  _not?: InputMaybe<AvailabilityTimesBoolExp>;
  _or?: InputMaybe<Array<AvailabilityTimesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  day?: InputMaybe<IntComparisonExp>;
  deletedAt?: InputMaybe<DateComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isClass?: InputMaybe<BooleanComparisonExp>;
  isFree?: InputMaybe<BooleanComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
  time?: InputMaybe<TimeComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "availability_times" */
export enum AvailabilityTimesConstraint {
  /** unique or primary key constraint on columns "teacher_id", "time", "day" */
  AvailabilityTemplatesDayTimeTeacherIdKey = 'availability_templates_day_time_teacher_id_key',
  /** unique or primary key constraint on columns "id" */
  AvailabilityTemplatesPkey = 'availability_templates_pkey'
}

/** input type for incrementing numeric columns in table "availability_times" */
export type AvailabilityTimesIncInput = {
  day?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "availability_times" */
export type AvailabilityTimesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isClass?: InputMaybe<Scalars['Boolean']['input']>;
  isFree?: InputMaybe<Scalars['Boolean']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  time?: InputMaybe<Scalars['time']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type AvailabilityTimesMaxFields = {
  __typename?: 'availability_times_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type AvailabilityTimesMinFields = {
  __typename?: 'availability_times_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "availability_times" */
export type AvailabilityTimesMutationResponse = {
  __typename?: 'availability_times_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AvailabilityTimes>;
};

/** input type for inserting object relation for remote table "availability_times" */
export type AvailabilityTimesObjRelInsertInput = {
  data: AvailabilityTimesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<AvailabilityTimesOnConflict>;
};

/** on_conflict condition type for table "availability_times" */
export type AvailabilityTimesOnConflict = {
  constraint: AvailabilityTimesConstraint;
  update_columns?: Array<AvailabilityTimesUpdateColumn>;
  where?: InputMaybe<AvailabilityTimesBoolExp>;
};

/** Ordering options when selecting data from "availability_times". */
export type AvailabilityTimesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  day?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isClass?: InputMaybe<OrderBy>;
  isFree?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  time?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: availability_times */
export type AvailabilityTimesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "availability_times" */
export enum AvailabilityTimesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Day = 'day',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsClass = 'isClass',
  /** column name */
  IsFree = 'isFree',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "availability_times" */
export type AvailabilityTimesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isClass?: InputMaybe<Scalars['Boolean']['input']>;
  isFree?: InputMaybe<Scalars['Boolean']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  time?: InputMaybe<Scalars['time']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type AvailabilityTimesStddevFields = {
  __typename?: 'availability_times_stddev_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type AvailabilityTimesStddevPopFields = {
  __typename?: 'availability_times_stddev_pop_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type AvailabilityTimesStddevSampFields = {
  __typename?: 'availability_times_stddev_samp_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "availability_times" */
export type AvailabilityTimesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AvailabilityTimesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AvailabilityTimesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isClass?: InputMaybe<Scalars['Boolean']['input']>;
  isFree?: InputMaybe<Scalars['Boolean']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  time?: InputMaybe<Scalars['time']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type AvailabilityTimesSumFields = {
  __typename?: 'availability_times_sum_fields';
  day?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "availability_times" */
export enum AvailabilityTimesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Day = 'day',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsClass = 'isClass',
  /** column name */
  IsFree = 'isFree',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type AvailabilityTimesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AvailabilityTimesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AvailabilityTimesSetInput>;
  /** filter the rows which have to be updated */
  where: AvailabilityTimesBoolExp;
};

/** aggregate var_pop on columns */
export type AvailabilityTimesVarPopFields = {
  __typename?: 'availability_times_var_pop_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type AvailabilityTimesVarSampFields = {
  __typename?: 'availability_times_var_samp_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type AvailabilityTimesVarianceFields = {
  __typename?: 'availability_times_variance_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type BigintComparisonExp = {
  _eq?: InputMaybe<Scalars['bigint']['input']>;
  _gt?: InputMaybe<Scalars['bigint']['input']>;
  _gte?: InputMaybe<Scalars['bigint']['input']>;
  _in?: InputMaybe<Array<Scalars['bigint']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['bigint']['input']>;
  _lte?: InputMaybe<Scalars['bigint']['input']>;
  _neq?: InputMaybe<Scalars['bigint']['input']>;
  _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;
};

/** columns and relationships of "cefr_levels" */
export type CefrLevels = {
  __typename?: 'cefr_levels';
  description: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

/** aggregated selection of "cefr_levels" */
export type CefrLevelsAggregate = {
  __typename?: 'cefr_levels_aggregate';
  aggregate?: Maybe<CefrLevelsAggregateFields>;
  nodes: Array<CefrLevels>;
};

/** aggregate fields of "cefr_levels" */
export type CefrLevelsAggregateFields = {
  __typename?: 'cefr_levels_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<CefrLevelsMaxFields>;
  min?: Maybe<CefrLevelsMinFields>;
};


/** aggregate fields of "cefr_levels" */
export type CefrLevelsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CefrLevelsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "cefr_levels". All fields are combined with a logical 'AND'. */
export type CefrLevelsBoolExp = {
  _and?: InputMaybe<Array<CefrLevelsBoolExp>>;
  _not?: InputMaybe<CefrLevelsBoolExp>;
  _or?: InputMaybe<Array<CefrLevelsBoolExp>>;
  description?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "cefr_levels" */
export enum CefrLevelsConstraint {
  /** unique or primary key constraint on columns "value" */
  CefrLevelsPkey = 'cefr_levels_pkey'
}

export enum CefrLevelsEnum {
  /** Beginner */
  A1 = 'A1',
  /** Elementary */
  A2 = 'A2',
  /** Intermediate */
  B1 = 'B1',
  /** Upper-Intermediate */
  B2 = 'B2',
  /** Advanced */
  C1 = 'C1',
  /** Proficient */
  C2 = 'C2',
  /** Native */
  Native = 'Native'
}

/** Boolean expression to compare columns of type "cefr_levels_enum". All fields are combined with logical 'AND'. */
export type CefrLevelsEnumComparisonExp = {
  _eq?: InputMaybe<CefrLevelsEnum>;
  _in?: InputMaybe<Array<CefrLevelsEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<CefrLevelsEnum>;
  _nin?: InputMaybe<Array<CefrLevelsEnum>>;
};

/** input type for inserting data into table "cefr_levels" */
export type CefrLevelsInsertInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type CefrLevelsMaxFields = {
  __typename?: 'cefr_levels_max_fields';
  description?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type CefrLevelsMinFields = {
  __typename?: 'cefr_levels_min_fields';
  description?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "cefr_levels" */
export type CefrLevelsMutationResponse = {
  __typename?: 'cefr_levels_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CefrLevels>;
};

/** on_conflict condition type for table "cefr_levels" */
export type CefrLevelsOnConflict = {
  constraint: CefrLevelsConstraint;
  update_columns?: Array<CefrLevelsUpdateColumn>;
  where?: InputMaybe<CefrLevelsBoolExp>;
};

/** Ordering options when selecting data from "cefr_levels". */
export type CefrLevelsOrderBy = {
  description?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: cefr_levels */
export type CefrLevelsPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "cefr_levels" */
export enum CefrLevelsSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "cefr_levels" */
export type CefrLevelsSetInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "cefr_levels" */
export type CefrLevelsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CefrLevelsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CefrLevelsStreamCursorValueInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "cefr_levels" */
export enum CefrLevelsUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Value = 'value'
}

export type CefrLevelsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CefrLevelsSetInput>;
  /** filter the rows which have to be updated */
  where: CefrLevelsBoolExp;
};

/** columns and relationships of "class_activity_sets" */
export type ClassActivitySets = {
  __typename?: 'class_activity_sets';
  /** An object relationship */
  activitySet: ActivitySets;
  activitySetId: Scalars['Int']['output'];
  /** An object relationship */
  class: Classes;
  classId: Scalars['Int']['output'];
};

/** aggregated selection of "class_activity_sets" */
export type ClassActivitySetsAggregate = {
  __typename?: 'class_activity_sets_aggregate';
  aggregate?: Maybe<ClassActivitySetsAggregateFields>;
  nodes: Array<ClassActivitySets>;
};

export type ClassActivitySetsAggregateBoolExp = {
  count?: InputMaybe<ClassActivitySetsAggregateBoolExpCount>;
};

export type ClassActivitySetsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ClassActivitySetsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ClassActivitySetsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "class_activity_sets" */
export type ClassActivitySetsAggregateFields = {
  __typename?: 'class_activity_sets_aggregate_fields';
  avg?: Maybe<ClassActivitySetsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ClassActivitySetsMaxFields>;
  min?: Maybe<ClassActivitySetsMinFields>;
  stddev?: Maybe<ClassActivitySetsStddevFields>;
  stddev_pop?: Maybe<ClassActivitySetsStddevPopFields>;
  stddev_samp?: Maybe<ClassActivitySetsStddevSampFields>;
  sum?: Maybe<ClassActivitySetsSumFields>;
  var_pop?: Maybe<ClassActivitySetsVarPopFields>;
  var_samp?: Maybe<ClassActivitySetsVarSampFields>;
  variance?: Maybe<ClassActivitySetsVarianceFields>;
};


/** aggregate fields of "class_activity_sets" */
export type ClassActivitySetsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClassActivitySetsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "class_activity_sets" */
export type ClassActivitySetsAggregateOrderBy = {
  avg?: InputMaybe<ClassActivitySetsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ClassActivitySetsMaxOrderBy>;
  min?: InputMaybe<ClassActivitySetsMinOrderBy>;
  stddev?: InputMaybe<ClassActivitySetsStddevOrderBy>;
  stddev_pop?: InputMaybe<ClassActivitySetsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<ClassActivitySetsStddevSampOrderBy>;
  sum?: InputMaybe<ClassActivitySetsSumOrderBy>;
  var_pop?: InputMaybe<ClassActivitySetsVarPopOrderBy>;
  var_samp?: InputMaybe<ClassActivitySetsVarSampOrderBy>;
  variance?: InputMaybe<ClassActivitySetsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "class_activity_sets" */
export type ClassActivitySetsArrRelInsertInput = {
  data: Array<ClassActivitySetsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ClassActivitySetsOnConflict>;
};

/** aggregate avg on columns */
export type ClassActivitySetsAvgFields = {
  __typename?: 'class_activity_sets_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "class_activity_sets" */
export type ClassActivitySetsAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "class_activity_sets". All fields are combined with a logical 'AND'. */
export type ClassActivitySetsBoolExp = {
  _and?: InputMaybe<Array<ClassActivitySetsBoolExp>>;
  _not?: InputMaybe<ClassActivitySetsBoolExp>;
  _or?: InputMaybe<Array<ClassActivitySetsBoolExp>>;
  activitySet?: InputMaybe<ActivitySetsBoolExp>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  class?: InputMaybe<ClassesBoolExp>;
  classId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "class_activity_sets" */
export enum ClassActivitySetsConstraint {
  /** unique or primary key constraint on columns "activity_set_id", "class_id" */
  ClassActivitySetsPkey = 'class_activity_sets_pkey'
}

/** input type for incrementing numeric columns in table "class_activity_sets" */
export type ClassActivitySetsIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "class_activity_sets" */
export type ClassActivitySetsInsertInput = {
  activitySet?: InputMaybe<ActivitySetsObjRelInsertInput>;
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  class?: InputMaybe<ClassesObjRelInsertInput>;
  classId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ClassActivitySetsMaxFields = {
  __typename?: 'class_activity_sets_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "class_activity_sets" */
export type ClassActivitySetsMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ClassActivitySetsMinFields = {
  __typename?: 'class_activity_sets_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "class_activity_sets" */
export type ClassActivitySetsMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "class_activity_sets" */
export type ClassActivitySetsMutationResponse = {
  __typename?: 'class_activity_sets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ClassActivitySets>;
};

/** on_conflict condition type for table "class_activity_sets" */
export type ClassActivitySetsOnConflict = {
  constraint: ClassActivitySetsConstraint;
  update_columns?: Array<ClassActivitySetsUpdateColumn>;
  where?: InputMaybe<ClassActivitySetsBoolExp>;
};

/** Ordering options when selecting data from "class_activity_sets". */
export type ClassActivitySetsOrderBy = {
  activitySet?: InputMaybe<ActivitySetsOrderBy>;
  activitySetId?: InputMaybe<OrderBy>;
  class?: InputMaybe<ClassesOrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: class_activity_sets */
export type ClassActivitySetsPkColumnsInput = {
  activitySetId: Scalars['Int']['input'];
  classId: Scalars['Int']['input'];
};

/** select columns of table "class_activity_sets" */
export enum ClassActivitySetsSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  ClassId = 'classId'
}

/** input type for updating data in table "class_activity_sets" */
export type ClassActivitySetsSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ClassActivitySetsStddevFields = {
  __typename?: 'class_activity_sets_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "class_activity_sets" */
export type ClassActivitySetsStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type ClassActivitySetsStddevPopFields = {
  __typename?: 'class_activity_sets_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "class_activity_sets" */
export type ClassActivitySetsStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type ClassActivitySetsStddevSampFields = {
  __typename?: 'class_activity_sets_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "class_activity_sets" */
export type ClassActivitySetsStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "class_activity_sets" */
export type ClassActivitySetsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ClassActivitySetsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClassActivitySetsStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ClassActivitySetsSumFields = {
  __typename?: 'class_activity_sets_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "class_activity_sets" */
export type ClassActivitySetsSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** update columns of table "class_activity_sets" */
export enum ClassActivitySetsUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  ClassId = 'classId'
}

export type ClassActivitySetsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ClassActivitySetsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClassActivitySetsSetInput>;
  /** filter the rows which have to be updated */
  where: ClassActivitySetsBoolExp;
};

/** aggregate var_pop on columns */
export type ClassActivitySetsVarPopFields = {
  __typename?: 'class_activity_sets_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "class_activity_sets" */
export type ClassActivitySetsVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type ClassActivitySetsVarSampFields = {
  __typename?: 'class_activity_sets_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "class_activity_sets" */
export type ClassActivitySetsVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ClassActivitySetsVarianceFields = {
  __typename?: 'class_activity_sets_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "class_activity_sets" */
export type ClassActivitySetsVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "class_annotations" */
export type ClassAnnotations = {
  __typename?: 'class_annotations';
  /** An object relationship */
  annotation: Annotations;
  annotationId: Scalars['Int']['output'];
  /** An object relationship */
  class: Classes;
  classId: Scalars['Int']['output'];
};

/** aggregated selection of "class_annotations" */
export type ClassAnnotationsAggregate = {
  __typename?: 'class_annotations_aggregate';
  aggregate?: Maybe<ClassAnnotationsAggregateFields>;
  nodes: Array<ClassAnnotations>;
};

export type ClassAnnotationsAggregateBoolExp = {
  count?: InputMaybe<ClassAnnotationsAggregateBoolExpCount>;
};

export type ClassAnnotationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ClassAnnotationsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "class_annotations" */
export type ClassAnnotationsAggregateFields = {
  __typename?: 'class_annotations_aggregate_fields';
  avg?: Maybe<ClassAnnotationsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ClassAnnotationsMaxFields>;
  min?: Maybe<ClassAnnotationsMinFields>;
  stddev?: Maybe<ClassAnnotationsStddevFields>;
  stddev_pop?: Maybe<ClassAnnotationsStddevPopFields>;
  stddev_samp?: Maybe<ClassAnnotationsStddevSampFields>;
  sum?: Maybe<ClassAnnotationsSumFields>;
  var_pop?: Maybe<ClassAnnotationsVarPopFields>;
  var_samp?: Maybe<ClassAnnotationsVarSampFields>;
  variance?: Maybe<ClassAnnotationsVarianceFields>;
};


/** aggregate fields of "class_annotations" */
export type ClassAnnotationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "class_annotations" */
export type ClassAnnotationsAggregateOrderBy = {
  avg?: InputMaybe<ClassAnnotationsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ClassAnnotationsMaxOrderBy>;
  min?: InputMaybe<ClassAnnotationsMinOrderBy>;
  stddev?: InputMaybe<ClassAnnotationsStddevOrderBy>;
  stddev_pop?: InputMaybe<ClassAnnotationsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<ClassAnnotationsStddevSampOrderBy>;
  sum?: InputMaybe<ClassAnnotationsSumOrderBy>;
  var_pop?: InputMaybe<ClassAnnotationsVarPopOrderBy>;
  var_samp?: InputMaybe<ClassAnnotationsVarSampOrderBy>;
  variance?: InputMaybe<ClassAnnotationsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "class_annotations" */
export type ClassAnnotationsArrRelInsertInput = {
  data: Array<ClassAnnotationsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ClassAnnotationsOnConflict>;
};

/** aggregate avg on columns */
export type ClassAnnotationsAvgFields = {
  __typename?: 'class_annotations_avg_fields';
  annotationId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "class_annotations" */
export type ClassAnnotationsAvgOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "class_annotations". All fields are combined with a logical 'AND'. */
export type ClassAnnotationsBoolExp = {
  _and?: InputMaybe<Array<ClassAnnotationsBoolExp>>;
  _not?: InputMaybe<ClassAnnotationsBoolExp>;
  _or?: InputMaybe<Array<ClassAnnotationsBoolExp>>;
  annotation?: InputMaybe<AnnotationsBoolExp>;
  annotationId?: InputMaybe<IntComparisonExp>;
  class?: InputMaybe<ClassesBoolExp>;
  classId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "class_annotations" */
export enum ClassAnnotationsConstraint {
  /** unique or primary key constraint on columns "class_id", "annotation_id" */
  ClassAnnotationsPkey = 'class_annotations_pkey'
}

/** input type for incrementing numeric columns in table "class_annotations" */
export type ClassAnnotationsIncInput = {
  annotationId?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "class_annotations" */
export type ClassAnnotationsInsertInput = {
  annotation?: InputMaybe<AnnotationsObjRelInsertInput>;
  annotationId?: InputMaybe<Scalars['Int']['input']>;
  class?: InputMaybe<ClassesObjRelInsertInput>;
  classId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ClassAnnotationsMaxFields = {
  __typename?: 'class_annotations_max_fields';
  annotationId?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "class_annotations" */
export type ClassAnnotationsMaxOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ClassAnnotationsMinFields = {
  __typename?: 'class_annotations_min_fields';
  annotationId?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "class_annotations" */
export type ClassAnnotationsMinOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "class_annotations" */
export type ClassAnnotationsMutationResponse = {
  __typename?: 'class_annotations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ClassAnnotations>;
};

/** on_conflict condition type for table "class_annotations" */
export type ClassAnnotationsOnConflict = {
  constraint: ClassAnnotationsConstraint;
  update_columns?: Array<ClassAnnotationsUpdateColumn>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};

/** Ordering options when selecting data from "class_annotations". */
export type ClassAnnotationsOrderBy = {
  annotation?: InputMaybe<AnnotationsOrderBy>;
  annotationId?: InputMaybe<OrderBy>;
  class?: InputMaybe<ClassesOrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: class_annotations */
export type ClassAnnotationsPkColumnsInput = {
  annotationId: Scalars['Int']['input'];
  classId: Scalars['Int']['input'];
};

/** select columns of table "class_annotations" */
export enum ClassAnnotationsSelectColumn {
  /** column name */
  AnnotationId = 'annotationId',
  /** column name */
  ClassId = 'classId'
}

/** input type for updating data in table "class_annotations" */
export type ClassAnnotationsSetInput = {
  annotationId?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ClassAnnotationsStddevFields = {
  __typename?: 'class_annotations_stddev_fields';
  annotationId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "class_annotations" */
export type ClassAnnotationsStddevOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type ClassAnnotationsStddevPopFields = {
  __typename?: 'class_annotations_stddev_pop_fields';
  annotationId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "class_annotations" */
export type ClassAnnotationsStddevPopOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type ClassAnnotationsStddevSampFields = {
  __typename?: 'class_annotations_stddev_samp_fields';
  annotationId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "class_annotations" */
export type ClassAnnotationsStddevSampOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "class_annotations" */
export type ClassAnnotationsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ClassAnnotationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClassAnnotationsStreamCursorValueInput = {
  annotationId?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ClassAnnotationsSumFields = {
  __typename?: 'class_annotations_sum_fields';
  annotationId?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "class_annotations" */
export type ClassAnnotationsSumOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** update columns of table "class_annotations" */
export enum ClassAnnotationsUpdateColumn {
  /** column name */
  AnnotationId = 'annotationId',
  /** column name */
  ClassId = 'classId'
}

export type ClassAnnotationsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ClassAnnotationsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClassAnnotationsSetInput>;
  /** filter the rows which have to be updated */
  where: ClassAnnotationsBoolExp;
};

/** aggregate var_pop on columns */
export type ClassAnnotationsVarPopFields = {
  __typename?: 'class_annotations_var_pop_fields';
  annotationId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "class_annotations" */
export type ClassAnnotationsVarPopOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type ClassAnnotationsVarSampFields = {
  __typename?: 'class_annotations_var_samp_fields';
  annotationId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "class_annotations" */
export type ClassAnnotationsVarSampOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ClassAnnotationsVarianceFields = {
  __typename?: 'class_annotations_variance_fields';
  annotationId?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "class_annotations" */
export type ClassAnnotationsVarianceOrderBy = {
  annotationId?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "class_courses" */
export type ClassCourses = {
  __typename?: 'class_courses';
  /** An object relationship */
  class: Classes;
  classId: Scalars['Int']['output'];
  /** An object relationship */
  course: Courses;
  courseId: Scalars['Int']['output'];
};

/** aggregated selection of "class_courses" */
export type ClassCoursesAggregate = {
  __typename?: 'class_courses_aggregate';
  aggregate?: Maybe<ClassCoursesAggregateFields>;
  nodes: Array<ClassCourses>;
};

export type ClassCoursesAggregateBoolExp = {
  count?: InputMaybe<ClassCoursesAggregateBoolExpCount>;
};

export type ClassCoursesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ClassCoursesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ClassCoursesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "class_courses" */
export type ClassCoursesAggregateFields = {
  __typename?: 'class_courses_aggregate_fields';
  avg?: Maybe<ClassCoursesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ClassCoursesMaxFields>;
  min?: Maybe<ClassCoursesMinFields>;
  stddev?: Maybe<ClassCoursesStddevFields>;
  stddev_pop?: Maybe<ClassCoursesStddevPopFields>;
  stddev_samp?: Maybe<ClassCoursesStddevSampFields>;
  sum?: Maybe<ClassCoursesSumFields>;
  var_pop?: Maybe<ClassCoursesVarPopFields>;
  var_samp?: Maybe<ClassCoursesVarSampFields>;
  variance?: Maybe<ClassCoursesVarianceFields>;
};


/** aggregate fields of "class_courses" */
export type ClassCoursesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClassCoursesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "class_courses" */
export type ClassCoursesAggregateOrderBy = {
  avg?: InputMaybe<ClassCoursesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ClassCoursesMaxOrderBy>;
  min?: InputMaybe<ClassCoursesMinOrderBy>;
  stddev?: InputMaybe<ClassCoursesStddevOrderBy>;
  stddev_pop?: InputMaybe<ClassCoursesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<ClassCoursesStddevSampOrderBy>;
  sum?: InputMaybe<ClassCoursesSumOrderBy>;
  var_pop?: InputMaybe<ClassCoursesVarPopOrderBy>;
  var_samp?: InputMaybe<ClassCoursesVarSampOrderBy>;
  variance?: InputMaybe<ClassCoursesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "class_courses" */
export type ClassCoursesArrRelInsertInput = {
  data: Array<ClassCoursesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ClassCoursesOnConflict>;
};

/** aggregate avg on columns */
export type ClassCoursesAvgFields = {
  __typename?: 'class_courses_avg_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "class_courses" */
export type ClassCoursesAvgOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "class_courses". All fields are combined with a logical 'AND'. */
export type ClassCoursesBoolExp = {
  _and?: InputMaybe<Array<ClassCoursesBoolExp>>;
  _not?: InputMaybe<ClassCoursesBoolExp>;
  _or?: InputMaybe<Array<ClassCoursesBoolExp>>;
  class?: InputMaybe<ClassesBoolExp>;
  classId?: InputMaybe<IntComparisonExp>;
  course?: InputMaybe<CoursesBoolExp>;
  courseId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "class_courses" */
export enum ClassCoursesConstraint {
  /** unique or primary key constraint on columns "course_id", "class_id" */
  ClassCoursesPkey = 'class_courses_pkey'
}

/** input type for incrementing numeric columns in table "class_courses" */
export type ClassCoursesIncInput = {
  classId?: InputMaybe<Scalars['Int']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "class_courses" */
export type ClassCoursesInsertInput = {
  class?: InputMaybe<ClassesObjRelInsertInput>;
  classId?: InputMaybe<Scalars['Int']['input']>;
  course?: InputMaybe<CoursesObjRelInsertInput>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ClassCoursesMaxFields = {
  __typename?: 'class_courses_max_fields';
  classId?: Maybe<Scalars['Int']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "class_courses" */
export type ClassCoursesMaxOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ClassCoursesMinFields = {
  __typename?: 'class_courses_min_fields';
  classId?: Maybe<Scalars['Int']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "class_courses" */
export type ClassCoursesMinOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "class_courses" */
export type ClassCoursesMutationResponse = {
  __typename?: 'class_courses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ClassCourses>;
};

/** on_conflict condition type for table "class_courses" */
export type ClassCoursesOnConflict = {
  constraint: ClassCoursesConstraint;
  update_columns?: Array<ClassCoursesUpdateColumn>;
  where?: InputMaybe<ClassCoursesBoolExp>;
};

/** Ordering options when selecting data from "class_courses". */
export type ClassCoursesOrderBy = {
  class?: InputMaybe<ClassesOrderBy>;
  classId?: InputMaybe<OrderBy>;
  course?: InputMaybe<CoursesOrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: class_courses */
export type ClassCoursesPkColumnsInput = {
  classId: Scalars['Int']['input'];
  courseId: Scalars['Int']['input'];
};

/** select columns of table "class_courses" */
export enum ClassCoursesSelectColumn {
  /** column name */
  ClassId = 'classId',
  /** column name */
  CourseId = 'courseId'
}

/** input type for updating data in table "class_courses" */
export type ClassCoursesSetInput = {
  classId?: InputMaybe<Scalars['Int']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ClassCoursesStddevFields = {
  __typename?: 'class_courses_stddev_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "class_courses" */
export type ClassCoursesStddevOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type ClassCoursesStddevPopFields = {
  __typename?: 'class_courses_stddev_pop_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "class_courses" */
export type ClassCoursesStddevPopOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type ClassCoursesStddevSampFields = {
  __typename?: 'class_courses_stddev_samp_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "class_courses" */
export type ClassCoursesStddevSampOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "class_courses" */
export type ClassCoursesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ClassCoursesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClassCoursesStreamCursorValueInput = {
  classId?: InputMaybe<Scalars['Int']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ClassCoursesSumFields = {
  __typename?: 'class_courses_sum_fields';
  classId?: Maybe<Scalars['Int']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "class_courses" */
export type ClassCoursesSumOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** update columns of table "class_courses" */
export enum ClassCoursesUpdateColumn {
  /** column name */
  ClassId = 'classId',
  /** column name */
  CourseId = 'courseId'
}

export type ClassCoursesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ClassCoursesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClassCoursesSetInput>;
  /** filter the rows which have to be updated */
  where: ClassCoursesBoolExp;
};

/** aggregate var_pop on columns */
export type ClassCoursesVarPopFields = {
  __typename?: 'class_courses_var_pop_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "class_courses" */
export type ClassCoursesVarPopOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type ClassCoursesVarSampFields = {
  __typename?: 'class_courses_var_samp_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "class_courses" */
export type ClassCoursesVarSampOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ClassCoursesVarianceFields = {
  __typename?: 'class_courses_variance_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "class_courses" */
export type ClassCoursesVarianceOrderBy = {
  classId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "class_sessions" */
export type ClassSessions = {
  __typename?: 'class_sessions';
  callCompleted?: Maybe<Scalars['timestamptz']['output']>;
  callInitiated: Scalars['timestamptz']['output'];
  expectedStartTime: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  room: Scalars['String']['output'];
  sdp?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  slot: Slots;
  slotId: Scalars['Int']['output'];
  status: SessionStatusesEnum;
  streamUrl?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  studentClassSessions: Array<StudentClassSessions>;
  /** An aggregate relationship */
  studentClassSessions_aggregate: StudentClassSessionsAggregate;
  /** An object relationship */
  teacher: Users;
  teacherId: Scalars['Int']['output'];
};


/** columns and relationships of "class_sessions" */
export type ClassSessionsSdpArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "class_sessions" */
export type ClassSessionsStudentClassSessionsArgs = {
  distinct_on?: InputMaybe<Array<StudentClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassSessionsOrderBy>>;
  where?: InputMaybe<StudentClassSessionsBoolExp>;
};


/** columns and relationships of "class_sessions" */
export type ClassSessionsStudentClassSessionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassSessionsOrderBy>>;
  where?: InputMaybe<StudentClassSessionsBoolExp>;
};

/** aggregated selection of "class_sessions" */
export type ClassSessionsAggregate = {
  __typename?: 'class_sessions_aggregate';
  aggregate?: Maybe<ClassSessionsAggregateFields>;
  nodes: Array<ClassSessions>;
};

/** aggregate fields of "class_sessions" */
export type ClassSessionsAggregateFields = {
  __typename?: 'class_sessions_aggregate_fields';
  avg?: Maybe<ClassSessionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ClassSessionsMaxFields>;
  min?: Maybe<ClassSessionsMinFields>;
  stddev?: Maybe<ClassSessionsStddevFields>;
  stddev_pop?: Maybe<ClassSessionsStddevPopFields>;
  stddev_samp?: Maybe<ClassSessionsStddevSampFields>;
  sum?: Maybe<ClassSessionsSumFields>;
  var_pop?: Maybe<ClassSessionsVarPopFields>;
  var_samp?: Maybe<ClassSessionsVarSampFields>;
  variance?: Maybe<ClassSessionsVarianceFields>;
};


/** aggregate fields of "class_sessions" */
export type ClassSessionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClassSessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ClassSessionsAppendInput = {
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type ClassSessionsAvgFields = {
  __typename?: 'class_sessions_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "class_sessions". All fields are combined with a logical 'AND'. */
export type ClassSessionsBoolExp = {
  _and?: InputMaybe<Array<ClassSessionsBoolExp>>;
  _not?: InputMaybe<ClassSessionsBoolExp>;
  _or?: InputMaybe<Array<ClassSessionsBoolExp>>;
  callCompleted?: InputMaybe<TimestamptzComparisonExp>;
  callInitiated?: InputMaybe<TimestamptzComparisonExp>;
  expectedStartTime?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  room?: InputMaybe<StringComparisonExp>;
  sdp?: InputMaybe<JsonbComparisonExp>;
  slot?: InputMaybe<SlotsBoolExp>;
  slotId?: InputMaybe<IntComparisonExp>;
  status?: InputMaybe<SessionStatusesEnumComparisonExp>;
  streamUrl?: InputMaybe<StringComparisonExp>;
  studentClassSessions?: InputMaybe<StudentClassSessionsBoolExp>;
  studentClassSessions_aggregate?: InputMaybe<StudentClassSessionsAggregateBoolExp>;
  teacher?: InputMaybe<UsersBoolExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "class_sessions" */
export enum ClassSessionsConstraint {
  /** unique or primary key constraint on columns "id" */
  ClassSessionsPkey = 'class_sessions_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ClassSessionsDeleteAtPathInput = {
  sdp?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ClassSessionsDeleteElemInput = {
  sdp?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ClassSessionsDeleteKeyInput = {
  sdp?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "class_sessions" */
export type ClassSessionsIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "class_sessions" */
export type ClassSessionsInsertInput = {
  callCompleted?: InputMaybe<Scalars['timestamptz']['input']>;
  callInitiated?: InputMaybe<Scalars['timestamptz']['input']>;
  expectedStartTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  room?: InputMaybe<Scalars['String']['input']>;
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
  slot?: InputMaybe<SlotsObjRelInsertInput>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<SessionStatusesEnum>;
  streamUrl?: InputMaybe<Scalars['String']['input']>;
  studentClassSessions?: InputMaybe<StudentClassSessionsArrRelInsertInput>;
  teacher?: InputMaybe<UsersObjRelInsertInput>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ClassSessionsMaxFields = {
  __typename?: 'class_sessions_max_fields';
  callCompleted?: Maybe<Scalars['timestamptz']['output']>;
  callInitiated?: Maybe<Scalars['timestamptz']['output']>;
  expectedStartTime?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  room?: Maybe<Scalars['String']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
  streamUrl?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type ClassSessionsMinFields = {
  __typename?: 'class_sessions_min_fields';
  callCompleted?: Maybe<Scalars['timestamptz']['output']>;
  callInitiated?: Maybe<Scalars['timestamptz']['output']>;
  expectedStartTime?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  room?: Maybe<Scalars['String']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
  streamUrl?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "class_sessions" */
export type ClassSessionsMutationResponse = {
  __typename?: 'class_sessions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ClassSessions>;
};

/** input type for inserting object relation for remote table "class_sessions" */
export type ClassSessionsObjRelInsertInput = {
  data: ClassSessionsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ClassSessionsOnConflict>;
};

/** on_conflict condition type for table "class_sessions" */
export type ClassSessionsOnConflict = {
  constraint: ClassSessionsConstraint;
  update_columns?: Array<ClassSessionsUpdateColumn>;
  where?: InputMaybe<ClassSessionsBoolExp>;
};

/** Ordering options when selecting data from "class_sessions". */
export type ClassSessionsOrderBy = {
  callCompleted?: InputMaybe<OrderBy>;
  callInitiated?: InputMaybe<OrderBy>;
  expectedStartTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  room?: InputMaybe<OrderBy>;
  sdp?: InputMaybe<OrderBy>;
  slot?: InputMaybe<SlotsOrderBy>;
  slotId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  streamUrl?: InputMaybe<OrderBy>;
  studentClassSessions_aggregate?: InputMaybe<StudentClassSessionsAggregateOrderBy>;
  teacher?: InputMaybe<UsersOrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: class_sessions */
export type ClassSessionsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ClassSessionsPrependInput = {
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "class_sessions" */
export enum ClassSessionsSelectColumn {
  /** column name */
  CallCompleted = 'callCompleted',
  /** column name */
  CallInitiated = 'callInitiated',
  /** column name */
  ExpectedStartTime = 'expectedStartTime',
  /** column name */
  Id = 'id',
  /** column name */
  Room = 'room',
  /** column name */
  Sdp = 'sdp',
  /** column name */
  SlotId = 'slotId',
  /** column name */
  Status = 'status',
  /** column name */
  StreamUrl = 'streamUrl',
  /** column name */
  TeacherId = 'teacherId'
}

/** input type for updating data in table "class_sessions" */
export type ClassSessionsSetInput = {
  callCompleted?: InputMaybe<Scalars['timestamptz']['input']>;
  callInitiated?: InputMaybe<Scalars['timestamptz']['input']>;
  expectedStartTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  room?: InputMaybe<Scalars['String']['input']>;
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<SessionStatusesEnum>;
  streamUrl?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ClassSessionsStddevFields = {
  __typename?: 'class_sessions_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ClassSessionsStddevPopFields = {
  __typename?: 'class_sessions_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ClassSessionsStddevSampFields = {
  __typename?: 'class_sessions_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "class_sessions" */
export type ClassSessionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ClassSessionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClassSessionsStreamCursorValueInput = {
  callCompleted?: InputMaybe<Scalars['timestamptz']['input']>;
  callInitiated?: InputMaybe<Scalars['timestamptz']['input']>;
  expectedStartTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  room?: InputMaybe<Scalars['String']['input']>;
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<SessionStatusesEnum>;
  streamUrl?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ClassSessionsSumFields = {
  __typename?: 'class_sessions_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "class_sessions" */
export enum ClassSessionsUpdateColumn {
  /** column name */
  CallCompleted = 'callCompleted',
  /** column name */
  CallInitiated = 'callInitiated',
  /** column name */
  ExpectedStartTime = 'expectedStartTime',
  /** column name */
  Id = 'id',
  /** column name */
  Room = 'room',
  /** column name */
  Sdp = 'sdp',
  /** column name */
  SlotId = 'slotId',
  /** column name */
  Status = 'status',
  /** column name */
  StreamUrl = 'streamUrl',
  /** column name */
  TeacherId = 'teacherId'
}

export type ClassSessionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<ClassSessionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<ClassSessionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<ClassSessionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<ClassSessionsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ClassSessionsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<ClassSessionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClassSessionsSetInput>;
  /** filter the rows which have to be updated */
  where: ClassSessionsBoolExp;
};

/** aggregate var_pop on columns */
export type ClassSessionsVarPopFields = {
  __typename?: 'class_sessions_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ClassSessionsVarSampFields = {
  __typename?: 'class_sessions_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ClassSessionsVarianceFields = {
  __typename?: 'class_sessions_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "class_slot_bookings" */
export type ClassSlotBookings = {
  __typename?: 'class_slot_bookings';
  slotId: Scalars['Int']['output'];
  /** An object relationship */
  student: Users;
  studentId: Scalars['Int']['output'];
};

/** aggregated selection of "class_slot_bookings" */
export type ClassSlotBookingsAggregate = {
  __typename?: 'class_slot_bookings_aggregate';
  aggregate?: Maybe<ClassSlotBookingsAggregateFields>;
  nodes: Array<ClassSlotBookings>;
};

export type ClassSlotBookingsAggregateBoolExp = {
  count?: InputMaybe<ClassSlotBookingsAggregateBoolExpCount>;
};

export type ClassSlotBookingsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ClassSlotBookingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ClassSlotBookingsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "class_slot_bookings" */
export type ClassSlotBookingsAggregateFields = {
  __typename?: 'class_slot_bookings_aggregate_fields';
  avg?: Maybe<ClassSlotBookingsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ClassSlotBookingsMaxFields>;
  min?: Maybe<ClassSlotBookingsMinFields>;
  stddev?: Maybe<ClassSlotBookingsStddevFields>;
  stddev_pop?: Maybe<ClassSlotBookingsStddevPopFields>;
  stddev_samp?: Maybe<ClassSlotBookingsStddevSampFields>;
  sum?: Maybe<ClassSlotBookingsSumFields>;
  var_pop?: Maybe<ClassSlotBookingsVarPopFields>;
  var_samp?: Maybe<ClassSlotBookingsVarSampFields>;
  variance?: Maybe<ClassSlotBookingsVarianceFields>;
};


/** aggregate fields of "class_slot_bookings" */
export type ClassSlotBookingsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClassSlotBookingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "class_slot_bookings" */
export type ClassSlotBookingsAggregateOrderBy = {
  avg?: InputMaybe<ClassSlotBookingsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ClassSlotBookingsMaxOrderBy>;
  min?: InputMaybe<ClassSlotBookingsMinOrderBy>;
  stddev?: InputMaybe<ClassSlotBookingsStddevOrderBy>;
  stddev_pop?: InputMaybe<ClassSlotBookingsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<ClassSlotBookingsStddevSampOrderBy>;
  sum?: InputMaybe<ClassSlotBookingsSumOrderBy>;
  var_pop?: InputMaybe<ClassSlotBookingsVarPopOrderBy>;
  var_samp?: InputMaybe<ClassSlotBookingsVarSampOrderBy>;
  variance?: InputMaybe<ClassSlotBookingsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "class_slot_bookings" */
export type ClassSlotBookingsArrRelInsertInput = {
  data: Array<ClassSlotBookingsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ClassSlotBookingsOnConflict>;
};

/** aggregate avg on columns */
export type ClassSlotBookingsAvgFields = {
  __typename?: 'class_slot_bookings_avg_fields';
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsAvgOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "class_slot_bookings". All fields are combined with a logical 'AND'. */
export type ClassSlotBookingsBoolExp = {
  _and?: InputMaybe<Array<ClassSlotBookingsBoolExp>>;
  _not?: InputMaybe<ClassSlotBookingsBoolExp>;
  _or?: InputMaybe<Array<ClassSlotBookingsBoolExp>>;
  slotId?: InputMaybe<IntComparisonExp>;
  student?: InputMaybe<UsersBoolExp>;
  studentId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "class_slot_bookings" */
export enum ClassSlotBookingsConstraint {
  /** unique or primary key constraint on columns "student_id", "slot_id" */
  ClassSlotBookingsPkey = 'class_slot_bookings_pkey'
}

/** input type for incrementing numeric columns in table "class_slot_bookings" */
export type ClassSlotBookingsIncInput = {
  slotId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "class_slot_bookings" */
export type ClassSlotBookingsInsertInput = {
  slotId?: InputMaybe<Scalars['Int']['input']>;
  student?: InputMaybe<UsersObjRelInsertInput>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ClassSlotBookingsMaxFields = {
  __typename?: 'class_slot_bookings_max_fields';
  slotId?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsMaxOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ClassSlotBookingsMinFields = {
  __typename?: 'class_slot_bookings_min_fields';
  slotId?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsMinOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "class_slot_bookings" */
export type ClassSlotBookingsMutationResponse = {
  __typename?: 'class_slot_bookings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ClassSlotBookings>;
};

/** on_conflict condition type for table "class_slot_bookings" */
export type ClassSlotBookingsOnConflict = {
  constraint: ClassSlotBookingsConstraint;
  update_columns?: Array<ClassSlotBookingsUpdateColumn>;
  where?: InputMaybe<ClassSlotBookingsBoolExp>;
};

/** Ordering options when selecting data from "class_slot_bookings". */
export type ClassSlotBookingsOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  student?: InputMaybe<UsersOrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: class_slot_bookings */
export type ClassSlotBookingsPkColumnsInput = {
  slotId: Scalars['Int']['input'];
  studentId: Scalars['Int']['input'];
};

/** select columns of table "class_slot_bookings" */
export enum ClassSlotBookingsSelectColumn {
  /** column name */
  SlotId = 'slotId',
  /** column name */
  StudentId = 'studentId'
}

/** input type for updating data in table "class_slot_bookings" */
export type ClassSlotBookingsSetInput = {
  slotId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ClassSlotBookingsStddevFields = {
  __typename?: 'class_slot_bookings_stddev_fields';
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsStddevOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type ClassSlotBookingsStddevPopFields = {
  __typename?: 'class_slot_bookings_stddev_pop_fields';
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsStddevPopOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type ClassSlotBookingsStddevSampFields = {
  __typename?: 'class_slot_bookings_stddev_samp_fields';
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsStddevSampOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "class_slot_bookings" */
export type ClassSlotBookingsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ClassSlotBookingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClassSlotBookingsStreamCursorValueInput = {
  slotId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ClassSlotBookingsSumFields = {
  __typename?: 'class_slot_bookings_sum_fields';
  slotId?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsSumOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** update columns of table "class_slot_bookings" */
export enum ClassSlotBookingsUpdateColumn {
  /** column name */
  SlotId = 'slotId',
  /** column name */
  StudentId = 'studentId'
}

export type ClassSlotBookingsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ClassSlotBookingsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClassSlotBookingsSetInput>;
  /** filter the rows which have to be updated */
  where: ClassSlotBookingsBoolExp;
};

/** aggregate var_pop on columns */
export type ClassSlotBookingsVarPopFields = {
  __typename?: 'class_slot_bookings_var_pop_fields';
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsVarPopOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type ClassSlotBookingsVarSampFields = {
  __typename?: 'class_slot_bookings_var_samp_fields';
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsVarSampOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ClassSlotBookingsVarianceFields = {
  __typename?: 'class_slot_bookings_variance_fields';
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "class_slot_bookings" */
export type ClassSlotBookingsVarianceOrderBy = {
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "classes" */
export type Classes = {
  __typename?: 'classes';
  /** An array relationship */
  classActivitySets: Array<ClassActivitySets>;
  /** An aggregate relationship */
  classActivitySets_aggregate: ClassActivitySetsAggregate;
  /** An array relationship */
  classAnnotations: Array<ClassAnnotations>;
  /** An aggregate relationship */
  classAnnotations_aggregate: ClassAnnotationsAggregate;
  /** An array relationship */
  classCourses: Array<ClassCourses>;
  /** An aggregate relationship */
  classCourses_aggregate: ClassCoursesAggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  description: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** An array relationship */
  studentClasses: Array<StudentClasses>;
  /** An aggregate relationship */
  studentClasses_aggregate: StudentClassesAggregate;
  subjectId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: Users;
};


/** columns and relationships of "classes" */
export type ClassesClassActivitySetsArgs = {
  distinct_on?: InputMaybe<Array<ClassActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassActivitySetsOrderBy>>;
  where?: InputMaybe<ClassActivitySetsBoolExp>;
};


/** columns and relationships of "classes" */
export type ClassesClassActivitySetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassActivitySetsOrderBy>>;
  where?: InputMaybe<ClassActivitySetsBoolExp>;
};


/** columns and relationships of "classes" */
export type ClassesClassAnnotationsArgs = {
  distinct_on?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassAnnotationsOrderBy>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};


/** columns and relationships of "classes" */
export type ClassesClassAnnotationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassAnnotationsOrderBy>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};


/** columns and relationships of "classes" */
export type ClassesClassCoursesArgs = {
  distinct_on?: InputMaybe<Array<ClassCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassCoursesOrderBy>>;
  where?: InputMaybe<ClassCoursesBoolExp>;
};


/** columns and relationships of "classes" */
export type ClassesClassCoursesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassCoursesOrderBy>>;
  where?: InputMaybe<ClassCoursesBoolExp>;
};


/** columns and relationships of "classes" */
export type ClassesStudentClassesArgs = {
  distinct_on?: InputMaybe<Array<StudentClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassesOrderBy>>;
  where?: InputMaybe<StudentClassesBoolExp>;
};


/** columns and relationships of "classes" */
export type ClassesStudentClassesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassesOrderBy>>;
  where?: InputMaybe<StudentClassesBoolExp>;
};

/** aggregated selection of "classes" */
export type ClassesAggregate = {
  __typename?: 'classes_aggregate';
  aggregate?: Maybe<ClassesAggregateFields>;
  nodes: Array<Classes>;
};

/** aggregate fields of "classes" */
export type ClassesAggregateFields = {
  __typename?: 'classes_aggregate_fields';
  avg?: Maybe<ClassesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ClassesMaxFields>;
  min?: Maybe<ClassesMinFields>;
  stddev?: Maybe<ClassesStddevFields>;
  stddev_pop?: Maybe<ClassesStddevPopFields>;
  stddev_samp?: Maybe<ClassesStddevSampFields>;
  sum?: Maybe<ClassesSumFields>;
  var_pop?: Maybe<ClassesVarPopFields>;
  var_samp?: Maybe<ClassesVarSampFields>;
  variance?: Maybe<ClassesVarianceFields>;
};


/** aggregate fields of "classes" */
export type ClassesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClassesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ClassesAvgFields = {
  __typename?: 'classes_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "classes". All fields are combined with a logical 'AND'. */
export type ClassesBoolExp = {
  _and?: InputMaybe<Array<ClassesBoolExp>>;
  _not?: InputMaybe<ClassesBoolExp>;
  _or?: InputMaybe<Array<ClassesBoolExp>>;
  classActivitySets?: InputMaybe<ClassActivitySetsBoolExp>;
  classActivitySets_aggregate?: InputMaybe<ClassActivitySetsAggregateBoolExp>;
  classAnnotations?: InputMaybe<ClassAnnotationsBoolExp>;
  classAnnotations_aggregate?: InputMaybe<ClassAnnotationsAggregateBoolExp>;
  classCourses?: InputMaybe<ClassCoursesBoolExp>;
  classCourses_aggregate?: InputMaybe<ClassCoursesAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  studentClasses?: InputMaybe<StudentClassesBoolExp>;
  studentClasses_aggregate?: InputMaybe<StudentClassesAggregateBoolExp>;
  subjectId?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "classes" */
export enum ClassesConstraint {
  /** unique or primary key constraint on columns "id" */
  ClassesPkey = 'classes_pkey'
}

/** input type for incrementing numeric columns in table "classes" */
export type ClassesIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "classes" */
export type ClassesInsertInput = {
  classActivitySets?: InputMaybe<ClassActivitySetsArrRelInsertInput>;
  classAnnotations?: InputMaybe<ClassAnnotationsArrRelInsertInput>;
  classCourses?: InputMaybe<ClassCoursesArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  studentClasses?: InputMaybe<StudentClassesArrRelInsertInput>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type ClassesMaxFields = {
  __typename?: 'classes_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type ClassesMinFields = {
  __typename?: 'classes_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "classes" */
export type ClassesMutationResponse = {
  __typename?: 'classes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Classes>;
};

/** input type for inserting object relation for remote table "classes" */
export type ClassesObjRelInsertInput = {
  data: ClassesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ClassesOnConflict>;
};

/** on_conflict condition type for table "classes" */
export type ClassesOnConflict = {
  constraint: ClassesConstraint;
  update_columns?: Array<ClassesUpdateColumn>;
  where?: InputMaybe<ClassesBoolExp>;
};

/** Ordering options when selecting data from "classes". */
export type ClassesOrderBy = {
  classActivitySets_aggregate?: InputMaybe<ClassActivitySetsAggregateOrderBy>;
  classAnnotations_aggregate?: InputMaybe<ClassAnnotationsAggregateOrderBy>;
  classCourses_aggregate?: InputMaybe<ClassCoursesAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  studentClasses_aggregate?: InputMaybe<StudentClassesAggregateOrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: classes */
export type ClassesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "classes" */
export enum ClassesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "classes" */
export type ClassesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type ClassesStddevFields = {
  __typename?: 'classes_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ClassesStddevPopFields = {
  __typename?: 'classes_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ClassesStddevSampFields = {
  __typename?: 'classes_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "classes" */
export type ClassesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ClassesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClassesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type ClassesSumFields = {
  __typename?: 'classes_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "classes" */
export enum ClassesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ClassesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ClassesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClassesSetInput>;
  /** filter the rows which have to be updated */
  where: ClassesBoolExp;
};

/** aggregate var_pop on columns */
export type ClassesVarPopFields = {
  __typename?: 'classes_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ClassesVarSampFields = {
  __typename?: 'classes_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ClassesVarianceFields = {
  __typename?: 'classes_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** A join table between courses and activities */
export type CourseActivities = {
  __typename?: 'course_activities';
  /** An object relationship */
  activitySet: ActivitySets;
  activitySetId: Scalars['Int']['output'];
  /** An object relationship */
  course: Courses;
  courseId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  order: Scalars['Int']['output'];
};

/** aggregated selection of "course_activities" */
export type CourseActivitiesAggregate = {
  __typename?: 'course_activities_aggregate';
  aggregate?: Maybe<CourseActivitiesAggregateFields>;
  nodes: Array<CourseActivities>;
};

export type CourseActivitiesAggregateBoolExp = {
  count?: InputMaybe<CourseActivitiesAggregateBoolExpCount>;
};

export type CourseActivitiesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<CourseActivitiesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "course_activities" */
export type CourseActivitiesAggregateFields = {
  __typename?: 'course_activities_aggregate_fields';
  avg?: Maybe<CourseActivitiesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<CourseActivitiesMaxFields>;
  min?: Maybe<CourseActivitiesMinFields>;
  stddev?: Maybe<CourseActivitiesStddevFields>;
  stddev_pop?: Maybe<CourseActivitiesStddevPopFields>;
  stddev_samp?: Maybe<CourseActivitiesStddevSampFields>;
  sum?: Maybe<CourseActivitiesSumFields>;
  var_pop?: Maybe<CourseActivitiesVarPopFields>;
  var_samp?: Maybe<CourseActivitiesVarSampFields>;
  variance?: Maybe<CourseActivitiesVarianceFields>;
};


/** aggregate fields of "course_activities" */
export type CourseActivitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "course_activities" */
export type CourseActivitiesAggregateOrderBy = {
  avg?: InputMaybe<CourseActivitiesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CourseActivitiesMaxOrderBy>;
  min?: InputMaybe<CourseActivitiesMinOrderBy>;
  stddev?: InputMaybe<CourseActivitiesStddevOrderBy>;
  stddev_pop?: InputMaybe<CourseActivitiesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<CourseActivitiesStddevSampOrderBy>;
  sum?: InputMaybe<CourseActivitiesSumOrderBy>;
  var_pop?: InputMaybe<CourseActivitiesVarPopOrderBy>;
  var_samp?: InputMaybe<CourseActivitiesVarSampOrderBy>;
  variance?: InputMaybe<CourseActivitiesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "course_activities" */
export type CourseActivitiesArrRelInsertInput = {
  data: Array<CourseActivitiesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<CourseActivitiesOnConflict>;
};

/** aggregate avg on columns */
export type CourseActivitiesAvgFields = {
  __typename?: 'course_activities_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "course_activities" */
export type CourseActivitiesAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "course_activities". All fields are combined with a logical 'AND'. */
export type CourseActivitiesBoolExp = {
  _and?: InputMaybe<Array<CourseActivitiesBoolExp>>;
  _not?: InputMaybe<CourseActivitiesBoolExp>;
  _or?: InputMaybe<Array<CourseActivitiesBoolExp>>;
  activitySet?: InputMaybe<ActivitySetsBoolExp>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  course?: InputMaybe<CoursesBoolExp>;
  courseId?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "course_activities" */
export enum CourseActivitiesConstraint {
  /** unique or primary key constraint on columns "id" */
  CourseActivitiesPkey = 'course_activities_pkey'
}

/** input type for incrementing numeric columns in table "course_activities" */
export type CourseActivitiesIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "course_activities" */
export type CourseActivitiesInsertInput = {
  activitySet?: InputMaybe<ActivitySetsObjRelInsertInput>;
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  course?: InputMaybe<CoursesObjRelInsertInput>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type CourseActivitiesMaxFields = {
  __typename?: 'course_activities_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "course_activities" */
export type CourseActivitiesMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type CourseActivitiesMinFields = {
  __typename?: 'course_activities_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "course_activities" */
export type CourseActivitiesMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "course_activities" */
export type CourseActivitiesMutationResponse = {
  __typename?: 'course_activities_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CourseActivities>;
};

/** on_conflict condition type for table "course_activities" */
export type CourseActivitiesOnConflict = {
  constraint: CourseActivitiesConstraint;
  update_columns?: Array<CourseActivitiesUpdateColumn>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};

/** Ordering options when selecting data from "course_activities". */
export type CourseActivitiesOrderBy = {
  activitySet?: InputMaybe<ActivitySetsOrderBy>;
  activitySetId?: InputMaybe<OrderBy>;
  course?: InputMaybe<CoursesOrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: course_activities */
export type CourseActivitiesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "course_activities" */
export enum CourseActivitiesSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  Id = 'id',
  /** column name */
  Order = 'order'
}

/** input type for updating data in table "course_activities" */
export type CourseActivitiesSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type CourseActivitiesStddevFields = {
  __typename?: 'course_activities_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "course_activities" */
export type CourseActivitiesStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type CourseActivitiesStddevPopFields = {
  __typename?: 'course_activities_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "course_activities" */
export type CourseActivitiesStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type CourseActivitiesStddevSampFields = {
  __typename?: 'course_activities_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "course_activities" */
export type CourseActivitiesStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "course_activities" */
export type CourseActivitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CourseActivitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CourseActivitiesStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type CourseActivitiesSumFields = {
  __typename?: 'course_activities_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "course_activities" */
export type CourseActivitiesSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** update columns of table "course_activities" */
export enum CourseActivitiesUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  Id = 'id',
  /** column name */
  Order = 'order'
}

export type CourseActivitiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CourseActivitiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CourseActivitiesSetInput>;
  /** filter the rows which have to be updated */
  where: CourseActivitiesBoolExp;
};

/** aggregate var_pop on columns */
export type CourseActivitiesVarPopFields = {
  __typename?: 'course_activities_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "course_activities" */
export type CourseActivitiesVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type CourseActivitiesVarSampFields = {
  __typename?: 'course_activities_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "course_activities" */
export type CourseActivitiesVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type CourseActivitiesVarianceFields = {
  __typename?: 'course_activities_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "course_activities" */
export type CourseActivitiesVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** columns and relationships of "course_reviews" */
export type CourseReviews = {
  __typename?: 'course_reviews';
  courseId: Scalars['Int']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  rating: Scalars['Int']['output'];
  review: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: Users;
};

/** aggregated selection of "course_reviews" */
export type CourseReviewsAggregate = {
  __typename?: 'course_reviews_aggregate';
  aggregate?: Maybe<CourseReviewsAggregateFields>;
  nodes: Array<CourseReviews>;
};

export type CourseReviewsAggregateBoolExp = {
  count?: InputMaybe<CourseReviewsAggregateBoolExpCount>;
};

export type CourseReviewsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<CourseReviewsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<CourseReviewsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "course_reviews" */
export type CourseReviewsAggregateFields = {
  __typename?: 'course_reviews_aggregate_fields';
  avg?: Maybe<CourseReviewsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<CourseReviewsMaxFields>;
  min?: Maybe<CourseReviewsMinFields>;
  stddev?: Maybe<CourseReviewsStddevFields>;
  stddev_pop?: Maybe<CourseReviewsStddevPopFields>;
  stddev_samp?: Maybe<CourseReviewsStddevSampFields>;
  sum?: Maybe<CourseReviewsSumFields>;
  var_pop?: Maybe<CourseReviewsVarPopFields>;
  var_samp?: Maybe<CourseReviewsVarSampFields>;
  variance?: Maybe<CourseReviewsVarianceFields>;
};


/** aggregate fields of "course_reviews" */
export type CourseReviewsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CourseReviewsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "course_reviews" */
export type CourseReviewsAggregateOrderBy = {
  avg?: InputMaybe<CourseReviewsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CourseReviewsMaxOrderBy>;
  min?: InputMaybe<CourseReviewsMinOrderBy>;
  stddev?: InputMaybe<CourseReviewsStddevOrderBy>;
  stddev_pop?: InputMaybe<CourseReviewsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<CourseReviewsStddevSampOrderBy>;
  sum?: InputMaybe<CourseReviewsSumOrderBy>;
  var_pop?: InputMaybe<CourseReviewsVarPopOrderBy>;
  var_samp?: InputMaybe<CourseReviewsVarSampOrderBy>;
  variance?: InputMaybe<CourseReviewsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "course_reviews" */
export type CourseReviewsArrRelInsertInput = {
  data: Array<CourseReviewsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<CourseReviewsOnConflict>;
};

/** aggregate avg on columns */
export type CourseReviewsAvgFields = {
  __typename?: 'course_reviews_avg_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  rating?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "course_reviews" */
export type CourseReviewsAvgOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "course_reviews". All fields are combined with a logical 'AND'. */
export type CourseReviewsBoolExp = {
  _and?: InputMaybe<Array<CourseReviewsBoolExp>>;
  _not?: InputMaybe<CourseReviewsBoolExp>;
  _or?: InputMaybe<Array<CourseReviewsBoolExp>>;
  courseId?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  rating?: InputMaybe<IntComparisonExp>;
  review?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "course_reviews" */
export enum CourseReviewsConstraint {
  /** unique or primary key constraint on columns "id" */
  CourseReviewsPkey = 'course_reviews_pkey'
}

/** input type for incrementing numeric columns in table "course_reviews" */
export type CourseReviewsIncInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  rating?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "course_reviews" */
export type CourseReviewsInsertInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  rating?: InputMaybe<Scalars['Int']['input']>;
  review?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type CourseReviewsMaxFields = {
  __typename?: 'course_reviews_max_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  rating?: Maybe<Scalars['Int']['output']>;
  review?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "course_reviews" */
export type CourseReviewsMaxOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
  review?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type CourseReviewsMinFields = {
  __typename?: 'course_reviews_min_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  rating?: Maybe<Scalars['Int']['output']>;
  review?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "course_reviews" */
export type CourseReviewsMinOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
  review?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "course_reviews" */
export type CourseReviewsMutationResponse = {
  __typename?: 'course_reviews_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CourseReviews>;
};

/** on_conflict condition type for table "course_reviews" */
export type CourseReviewsOnConflict = {
  constraint: CourseReviewsConstraint;
  update_columns?: Array<CourseReviewsUpdateColumn>;
  where?: InputMaybe<CourseReviewsBoolExp>;
};

/** Ordering options when selecting data from "course_reviews". */
export type CourseReviewsOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
  review?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: course_reviews */
export type CourseReviewsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "course_reviews" */
export enum CourseReviewsSelectColumn {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  Rating = 'rating',
  /** column name */
  Review = 'review',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "course_reviews" */
export type CourseReviewsSetInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  rating?: InputMaybe<Scalars['Int']['input']>;
  review?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type CourseReviewsStddevFields = {
  __typename?: 'course_reviews_stddev_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  rating?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "course_reviews" */
export type CourseReviewsStddevOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type CourseReviewsStddevPopFields = {
  __typename?: 'course_reviews_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  rating?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "course_reviews" */
export type CourseReviewsStddevPopOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type CourseReviewsStddevSampFields = {
  __typename?: 'course_reviews_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  rating?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "course_reviews" */
export type CourseReviewsStddevSampOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "course_reviews" */
export type CourseReviewsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CourseReviewsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CourseReviewsStreamCursorValueInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  rating?: InputMaybe<Scalars['Int']['input']>;
  review?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type CourseReviewsSumFields = {
  __typename?: 'course_reviews_sum_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  rating?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "course_reviews" */
export type CourseReviewsSumOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
};

/** update columns of table "course_reviews" */
export enum CourseReviewsUpdateColumn {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  Rating = 'rating',
  /** column name */
  Review = 'review',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type CourseReviewsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CourseReviewsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CourseReviewsSetInput>;
  /** filter the rows which have to be updated */
  where: CourseReviewsBoolExp;
};

/** aggregate var_pop on columns */
export type CourseReviewsVarPopFields = {
  __typename?: 'course_reviews_var_pop_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  rating?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "course_reviews" */
export type CourseReviewsVarPopOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type CourseReviewsVarSampFields = {
  __typename?: 'course_reviews_var_samp_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  rating?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "course_reviews" */
export type CourseReviewsVarSampOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type CourseReviewsVarianceFields = {
  __typename?: 'course_reviews_variance_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  rating?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "course_reviews" */
export type CourseReviewsVarianceOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  rating?: InputMaybe<OrderBy>;
};

/** columns and relationships of "course_summary" */
export type CourseSummary = {
  __typename?: 'course_summary';
  courseId?: Maybe<Scalars['Int']['output']>;
  numActivitySets?: Maybe<Scalars['bigint']['output']>;
  numExercises?: Maybe<Scalars['bigint']['output']>;
  numListenings?: Maybe<Scalars['bigint']['output']>;
  numReadings?: Maybe<Scalars['bigint']['output']>;
  numVocabularySets?: Maybe<Scalars['bigint']['output']>;
  numVocabularyWords?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "course_summary" */
export type CourseSummaryAggregate = {
  __typename?: 'course_summary_aggregate';
  aggregate?: Maybe<CourseSummaryAggregateFields>;
  nodes: Array<CourseSummary>;
};

/** aggregate fields of "course_summary" */
export type CourseSummaryAggregateFields = {
  __typename?: 'course_summary_aggregate_fields';
  avg?: Maybe<CourseSummaryAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<CourseSummaryMaxFields>;
  min?: Maybe<CourseSummaryMinFields>;
  stddev?: Maybe<CourseSummaryStddevFields>;
  stddev_pop?: Maybe<CourseSummaryStddevPopFields>;
  stddev_samp?: Maybe<CourseSummaryStddevSampFields>;
  sum?: Maybe<CourseSummarySumFields>;
  var_pop?: Maybe<CourseSummaryVarPopFields>;
  var_samp?: Maybe<CourseSummaryVarSampFields>;
  variance?: Maybe<CourseSummaryVarianceFields>;
};


/** aggregate fields of "course_summary" */
export type CourseSummaryAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CourseSummarySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type CourseSummaryAvgFields = {
  __typename?: 'course_summary_avg_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  numActivitySets?: Maybe<Scalars['Float']['output']>;
  numExercises?: Maybe<Scalars['Float']['output']>;
  numListenings?: Maybe<Scalars['Float']['output']>;
  numReadings?: Maybe<Scalars['Float']['output']>;
  numVocabularySets?: Maybe<Scalars['Float']['output']>;
  numVocabularyWords?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "course_summary". All fields are combined with a logical 'AND'. */
export type CourseSummaryBoolExp = {
  _and?: InputMaybe<Array<CourseSummaryBoolExp>>;
  _not?: InputMaybe<CourseSummaryBoolExp>;
  _or?: InputMaybe<Array<CourseSummaryBoolExp>>;
  courseId?: InputMaybe<IntComparisonExp>;
  numActivitySets?: InputMaybe<BigintComparisonExp>;
  numExercises?: InputMaybe<BigintComparisonExp>;
  numListenings?: InputMaybe<BigintComparisonExp>;
  numReadings?: InputMaybe<BigintComparisonExp>;
  numVocabularySets?: InputMaybe<BigintComparisonExp>;
  numVocabularyWords?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type CourseSummaryMaxFields = {
  __typename?: 'course_summary_max_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  numActivitySets?: Maybe<Scalars['bigint']['output']>;
  numExercises?: Maybe<Scalars['bigint']['output']>;
  numListenings?: Maybe<Scalars['bigint']['output']>;
  numReadings?: Maybe<Scalars['bigint']['output']>;
  numVocabularySets?: Maybe<Scalars['bigint']['output']>;
  numVocabularyWords?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type CourseSummaryMinFields = {
  __typename?: 'course_summary_min_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  numActivitySets?: Maybe<Scalars['bigint']['output']>;
  numExercises?: Maybe<Scalars['bigint']['output']>;
  numListenings?: Maybe<Scalars['bigint']['output']>;
  numReadings?: Maybe<Scalars['bigint']['output']>;
  numVocabularySets?: Maybe<Scalars['bigint']['output']>;
  numVocabularyWords?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "course_summary". */
export type CourseSummaryOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  numActivitySets?: InputMaybe<OrderBy>;
  numExercises?: InputMaybe<OrderBy>;
  numListenings?: InputMaybe<OrderBy>;
  numReadings?: InputMaybe<OrderBy>;
  numVocabularySets?: InputMaybe<OrderBy>;
  numVocabularyWords?: InputMaybe<OrderBy>;
};

/** select columns of table "course_summary" */
export enum CourseSummarySelectColumn {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  NumActivitySets = 'numActivitySets',
  /** column name */
  NumExercises = 'numExercises',
  /** column name */
  NumListenings = 'numListenings',
  /** column name */
  NumReadings = 'numReadings',
  /** column name */
  NumVocabularySets = 'numVocabularySets',
  /** column name */
  NumVocabularyWords = 'numVocabularyWords'
}

/** aggregate stddev on columns */
export type CourseSummaryStddevFields = {
  __typename?: 'course_summary_stddev_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  numActivitySets?: Maybe<Scalars['Float']['output']>;
  numExercises?: Maybe<Scalars['Float']['output']>;
  numListenings?: Maybe<Scalars['Float']['output']>;
  numReadings?: Maybe<Scalars['Float']['output']>;
  numVocabularySets?: Maybe<Scalars['Float']['output']>;
  numVocabularyWords?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type CourseSummaryStddevPopFields = {
  __typename?: 'course_summary_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  numActivitySets?: Maybe<Scalars['Float']['output']>;
  numExercises?: Maybe<Scalars['Float']['output']>;
  numListenings?: Maybe<Scalars['Float']['output']>;
  numReadings?: Maybe<Scalars['Float']['output']>;
  numVocabularySets?: Maybe<Scalars['Float']['output']>;
  numVocabularyWords?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type CourseSummaryStddevSampFields = {
  __typename?: 'course_summary_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  numActivitySets?: Maybe<Scalars['Float']['output']>;
  numExercises?: Maybe<Scalars['Float']['output']>;
  numListenings?: Maybe<Scalars['Float']['output']>;
  numReadings?: Maybe<Scalars['Float']['output']>;
  numVocabularySets?: Maybe<Scalars['Float']['output']>;
  numVocabularyWords?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "course_summary" */
export type CourseSummaryStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CourseSummaryStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CourseSummaryStreamCursorValueInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  numActivitySets?: InputMaybe<Scalars['bigint']['input']>;
  numExercises?: InputMaybe<Scalars['bigint']['input']>;
  numListenings?: InputMaybe<Scalars['bigint']['input']>;
  numReadings?: InputMaybe<Scalars['bigint']['input']>;
  numVocabularySets?: InputMaybe<Scalars['bigint']['input']>;
  numVocabularyWords?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type CourseSummarySumFields = {
  __typename?: 'course_summary_sum_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  numActivitySets?: Maybe<Scalars['bigint']['output']>;
  numExercises?: Maybe<Scalars['bigint']['output']>;
  numListenings?: Maybe<Scalars['bigint']['output']>;
  numReadings?: Maybe<Scalars['bigint']['output']>;
  numVocabularySets?: Maybe<Scalars['bigint']['output']>;
  numVocabularyWords?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type CourseSummaryVarPopFields = {
  __typename?: 'course_summary_var_pop_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  numActivitySets?: Maybe<Scalars['Float']['output']>;
  numExercises?: Maybe<Scalars['Float']['output']>;
  numListenings?: Maybe<Scalars['Float']['output']>;
  numReadings?: Maybe<Scalars['Float']['output']>;
  numVocabularySets?: Maybe<Scalars['Float']['output']>;
  numVocabularyWords?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type CourseSummaryVarSampFields = {
  __typename?: 'course_summary_var_samp_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  numActivitySets?: Maybe<Scalars['Float']['output']>;
  numExercises?: Maybe<Scalars['Float']['output']>;
  numListenings?: Maybe<Scalars['Float']['output']>;
  numReadings?: Maybe<Scalars['Float']['output']>;
  numVocabularySets?: Maybe<Scalars['Float']['output']>;
  numVocabularyWords?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type CourseSummaryVarianceFields = {
  __typename?: 'course_summary_variance_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  numActivitySets?: Maybe<Scalars['Float']['output']>;
  numExercises?: Maybe<Scalars['Float']['output']>;
  numListenings?: Maybe<Scalars['Float']['output']>;
  numReadings?: Maybe<Scalars['Float']['output']>;
  numVocabularySets?: Maybe<Scalars['Float']['output']>;
  numVocabularyWords?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "courses" */
export type Courses = {
  __typename?: 'courses';
  /** An array relationship */
  courseActivities: Array<CourseActivities>;
  /** An aggregate relationship */
  courseActivities_aggregate: CourseActivitiesAggregate;
  /** An array relationship */
  courseReviews: Array<CourseReviews>;
  /** An aggregate relationship */
  courseReviews_aggregate: CourseReviewsAggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  description: Scalars['String']['output'];
  /** this is actually the key */
  descriptionUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** An object relationship */
  image?: Maybe<Images>;
  imageId?: Maybe<Scalars['Int']['output']>;
  isBook: Scalars['Boolean']['output'];
  isCategory?: Maybe<Scalars['Boolean']['output']>;
  isPublic?: Maybe<Scalars['Boolean']['output']>;
  learnerLanguage: Scalars['Int']['output'];
  level: CefrLevelsEnum;
  price?: Maybe<Scalars['numeric']['output']>;
  ragKey?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  subject: Subjects;
  subjectId: Scalars['Int']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  /** An array relationship */
  userCourses: Array<UserCourses>;
  /** An aggregate relationship */
  userCourses_aggregate: UserCoursesAggregate;
};


/** columns and relationships of "courses" */
export type CoursesCourseActivitiesArgs = {
  distinct_on?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseActivitiesOrderBy>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


/** columns and relationships of "courses" */
export type CoursesCourseActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseActivitiesOrderBy>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


/** columns and relationships of "courses" */
export type CoursesCourseReviewsArgs = {
  distinct_on?: InputMaybe<Array<CourseReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseReviewsOrderBy>>;
  where?: InputMaybe<CourseReviewsBoolExp>;
};


/** columns and relationships of "courses" */
export type CoursesCourseReviewsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseReviewsOrderBy>>;
  where?: InputMaybe<CourseReviewsBoolExp>;
};


/** columns and relationships of "courses" */
export type CoursesUserCoursesArgs = {
  distinct_on?: InputMaybe<Array<UserCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserCoursesOrderBy>>;
  where?: InputMaybe<UserCoursesBoolExp>;
};


/** columns and relationships of "courses" */
export type CoursesUserCoursesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserCoursesOrderBy>>;
  where?: InputMaybe<UserCoursesBoolExp>;
};

/** aggregated selection of "courses" */
export type CoursesAggregate = {
  __typename?: 'courses_aggregate';
  aggregate?: Maybe<CoursesAggregateFields>;
  nodes: Array<Courses>;
};

/** aggregate fields of "courses" */
export type CoursesAggregateFields = {
  __typename?: 'courses_aggregate_fields';
  avg?: Maybe<CoursesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<CoursesMaxFields>;
  min?: Maybe<CoursesMinFields>;
  stddev?: Maybe<CoursesStddevFields>;
  stddev_pop?: Maybe<CoursesStddevPopFields>;
  stddev_samp?: Maybe<CoursesStddevSampFields>;
  sum?: Maybe<CoursesSumFields>;
  var_pop?: Maybe<CoursesVarPopFields>;
  var_samp?: Maybe<CoursesVarSampFields>;
  variance?: Maybe<CoursesVarianceFields>;
};


/** aggregate fields of "courses" */
export type CoursesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoursesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type CoursesAvgFields = {
  __typename?: 'courses_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "courses". All fields are combined with a logical 'AND'. */
export type CoursesBoolExp = {
  _and?: InputMaybe<Array<CoursesBoolExp>>;
  _not?: InputMaybe<CoursesBoolExp>;
  _or?: InputMaybe<Array<CoursesBoolExp>>;
  courseActivities?: InputMaybe<CourseActivitiesBoolExp>;
  courseActivities_aggregate?: InputMaybe<CourseActivitiesAggregateBoolExp>;
  courseReviews?: InputMaybe<CourseReviewsBoolExp>;
  courseReviews_aggregate?: InputMaybe<CourseReviewsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  descriptionUrl?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  image?: InputMaybe<ImagesBoolExp>;
  imageId?: InputMaybe<IntComparisonExp>;
  isBook?: InputMaybe<BooleanComparisonExp>;
  isCategory?: InputMaybe<BooleanComparisonExp>;
  isPublic?: InputMaybe<BooleanComparisonExp>;
  learnerLanguage?: InputMaybe<IntComparisonExp>;
  level?: InputMaybe<CefrLevelsEnumComparisonExp>;
  price?: InputMaybe<NumericComparisonExp>;
  ragKey?: InputMaybe<StringComparisonExp>;
  subject?: InputMaybe<SubjectsBoolExp>;
  subjectId?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userCourses?: InputMaybe<UserCoursesBoolExp>;
  userCourses_aggregate?: InputMaybe<UserCoursesAggregateBoolExp>;
};

/** unique or primary key constraints on table "courses" */
export enum CoursesConstraint {
  /** unique or primary key constraint on columns "id" */
  CoursesPkey = 'courses_pkey'
}

/** input type for incrementing numeric columns in table "courses" */
export type CoursesIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  learnerLanguage?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['numeric']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "courses" */
export type CoursesInsertInput = {
  courseActivities?: InputMaybe<CourseActivitiesArrRelInsertInput>;
  courseReviews?: InputMaybe<CourseReviewsArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** this is actually the key */
  descriptionUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<ImagesObjRelInsertInput>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isBook?: InputMaybe<Scalars['Boolean']['input']>;
  isCategory?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  learnerLanguage?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<CefrLevelsEnum>;
  price?: InputMaybe<Scalars['numeric']['input']>;
  ragKey?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<SubjectsObjRelInsertInput>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userCourses?: InputMaybe<UserCoursesArrRelInsertInput>;
};

/** aggregate max on columns */
export type CoursesMaxFields = {
  __typename?: 'courses_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** this is actually the key */
  descriptionUrl?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  learnerLanguage?: Maybe<Scalars['Int']['output']>;
  price?: Maybe<Scalars['numeric']['output']>;
  ragKey?: Maybe<Scalars['String']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type CoursesMinFields = {
  __typename?: 'courses_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** this is actually the key */
  descriptionUrl?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  learnerLanguage?: Maybe<Scalars['Int']['output']>;
  price?: Maybe<Scalars['numeric']['output']>;
  ragKey?: Maybe<Scalars['String']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "courses" */
export type CoursesMutationResponse = {
  __typename?: 'courses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Courses>;
};

/** input type for inserting object relation for remote table "courses" */
export type CoursesObjRelInsertInput = {
  data: CoursesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<CoursesOnConflict>;
};

/** on_conflict condition type for table "courses" */
export type CoursesOnConflict = {
  constraint: CoursesConstraint;
  update_columns?: Array<CoursesUpdateColumn>;
  where?: InputMaybe<CoursesBoolExp>;
};

/** Ordering options when selecting data from "courses". */
export type CoursesOrderBy = {
  courseActivities_aggregate?: InputMaybe<CourseActivitiesAggregateOrderBy>;
  courseReviews_aggregate?: InputMaybe<CourseReviewsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  descriptionUrl?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  image?: InputMaybe<ImagesOrderBy>;
  imageId?: InputMaybe<OrderBy>;
  isBook?: InputMaybe<OrderBy>;
  isCategory?: InputMaybe<OrderBy>;
  isPublic?: InputMaybe<OrderBy>;
  learnerLanguage?: InputMaybe<OrderBy>;
  level?: InputMaybe<OrderBy>;
  price?: InputMaybe<OrderBy>;
  ragKey?: InputMaybe<OrderBy>;
  subject?: InputMaybe<SubjectsOrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userCourses_aggregate?: InputMaybe<UserCoursesAggregateOrderBy>;
};

/** primary key columns input for table: courses */
export type CoursesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "courses" */
export enum CoursesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  DescriptionUrl = 'descriptionUrl',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  IsBook = 'isBook',
  /** column name */
  IsCategory = 'isCategory',
  /** column name */
  IsPublic = 'isPublic',
  /** column name */
  LearnerLanguage = 'learnerLanguage',
  /** column name */
  Level = 'level',
  /** column name */
  Price = 'price',
  /** column name */
  RagKey = 'ragKey',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "courses" */
export type CoursesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** this is actually the key */
  descriptionUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isBook?: InputMaybe<Scalars['Boolean']['input']>;
  isCategory?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  learnerLanguage?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<CefrLevelsEnum>;
  price?: InputMaybe<Scalars['numeric']['input']>;
  ragKey?: InputMaybe<Scalars['String']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type CoursesStddevFields = {
  __typename?: 'courses_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type CoursesStddevPopFields = {
  __typename?: 'courses_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type CoursesStddevSampFields = {
  __typename?: 'courses_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "courses" */
export type CoursesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CoursesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoursesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** this is actually the key */
  descriptionUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isBook?: InputMaybe<Scalars['Boolean']['input']>;
  isCategory?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  learnerLanguage?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<CefrLevelsEnum>;
  price?: InputMaybe<Scalars['numeric']['input']>;
  ragKey?: InputMaybe<Scalars['String']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type CoursesSumFields = {
  __typename?: 'courses_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  learnerLanguage?: Maybe<Scalars['Int']['output']>;
  price?: Maybe<Scalars['numeric']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "courses" */
export enum CoursesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  Description = 'description',
  /** column name */
  DescriptionUrl = 'descriptionUrl',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  IsBook = 'isBook',
  /** column name */
  IsCategory = 'isCategory',
  /** column name */
  IsPublic = 'isPublic',
  /** column name */
  LearnerLanguage = 'learnerLanguage',
  /** column name */
  Level = 'level',
  /** column name */
  Price = 'price',
  /** column name */
  RagKey = 'ragKey',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type CoursesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CoursesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoursesSetInput>;
  /** filter the rows which have to be updated */
  where: CoursesBoolExp;
};

/** aggregate var_pop on columns */
export type CoursesVarPopFields = {
  __typename?: 'courses_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type CoursesVarSampFields = {
  __typename?: 'courses_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type CoursesVarianceFields = {
  __typename?: 'courses_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  learnerLanguage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** ordering argument of a cursor */
export enum CursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "daily_stats" */
export type DailyStats = {
  __typename?: 'daily_stats';
  activityCompletionCount: Scalars['Int']['output'];
  activityCreationCount: Scalars['Int']['output'];
  activityResponsesCount: Scalars['Int']['output'];
  bookCompletionCount?: Maybe<Scalars['Int']['output']>;
  bookCreationCount: Scalars['Int']['output'];
  courseCompletionCount: Scalars['Int']['output'];
  courseCreationCount: Scalars['Int']['output'];
  end: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  listeningMinutes?: Maybe<Scalars['Int']['output']>;
  readingMinutes?: Maybe<Scalars['Int']['output']>;
  start: Scalars['timestamptz']['output'];
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  user: Users;
  userId: Scalars['Int']['output'];
  userWordsCount: Scalars['Int']['output'];
  wordCreationCount: Scalars['Int']['output'];
};

/** aggregated selection of "daily_stats" */
export type DailyStatsAggregate = {
  __typename?: 'daily_stats_aggregate';
  aggregate?: Maybe<DailyStatsAggregateFields>;
  nodes: Array<DailyStats>;
};

/** aggregate fields of "daily_stats" */
export type DailyStatsAggregateFields = {
  __typename?: 'daily_stats_aggregate_fields';
  avg?: Maybe<DailyStatsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<DailyStatsMaxFields>;
  min?: Maybe<DailyStatsMinFields>;
  stddev?: Maybe<DailyStatsStddevFields>;
  stddev_pop?: Maybe<DailyStatsStddevPopFields>;
  stddev_samp?: Maybe<DailyStatsStddevSampFields>;
  sum?: Maybe<DailyStatsSumFields>;
  var_pop?: Maybe<DailyStatsVarPopFields>;
  var_samp?: Maybe<DailyStatsVarSampFields>;
  variance?: Maybe<DailyStatsVarianceFields>;
};


/** aggregate fields of "daily_stats" */
export type DailyStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DailyStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type DailyStatsAvgFields = {
  __typename?: 'daily_stats_avg_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinutes?: Maybe<Scalars['Float']['output']>;
  readingMinutes?: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "daily_stats". All fields are combined with a logical 'AND'. */
export type DailyStatsBoolExp = {
  _and?: InputMaybe<Array<DailyStatsBoolExp>>;
  _not?: InputMaybe<DailyStatsBoolExp>;
  _or?: InputMaybe<Array<DailyStatsBoolExp>>;
  activityCompletionCount?: InputMaybe<IntComparisonExp>;
  activityCreationCount?: InputMaybe<IntComparisonExp>;
  activityResponsesCount?: InputMaybe<IntComparisonExp>;
  bookCompletionCount?: InputMaybe<IntComparisonExp>;
  bookCreationCount?: InputMaybe<IntComparisonExp>;
  courseCompletionCount?: InputMaybe<IntComparisonExp>;
  courseCreationCount?: InputMaybe<IntComparisonExp>;
  end?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  listeningMinutes?: InputMaybe<IntComparisonExp>;
  readingMinutes?: InputMaybe<IntComparisonExp>;
  start?: InputMaybe<TimestamptzComparisonExp>;
  total?: InputMaybe<IntComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<IntComparisonExp>;
  userWordsCount?: InputMaybe<IntComparisonExp>;
  wordCreationCount?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "daily_stats" */
export enum DailyStatsConstraint {
  /** unique or primary key constraint on columns "id" */
  DailyStatsPkey = 'daily_stats_pkey',
  /** unique or primary key constraint on columns "user_id", "start" */
  DailyStatsUserIdStartKey = 'daily_stats_user_id_start_key'
}

/** input type for incrementing numeric columns in table "daily_stats" */
export type DailyStatsIncInput = {
  activityCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  activityCreationCount?: InputMaybe<Scalars['Int']['input']>;
  activityResponsesCount?: InputMaybe<Scalars['Int']['input']>;
  bookCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  bookCreationCount?: InputMaybe<Scalars['Int']['input']>;
  courseCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  courseCreationCount?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  listeningMinutes?: InputMaybe<Scalars['Int']['input']>;
  readingMinutes?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userWordsCount?: InputMaybe<Scalars['Int']['input']>;
  wordCreationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "daily_stats" */
export type DailyStatsInsertInput = {
  activityCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  activityCreationCount?: InputMaybe<Scalars['Int']['input']>;
  activityResponsesCount?: InputMaybe<Scalars['Int']['input']>;
  bookCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  bookCreationCount?: InputMaybe<Scalars['Int']['input']>;
  courseCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  courseCreationCount?: InputMaybe<Scalars['Int']['input']>;
  end?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  listeningMinutes?: InputMaybe<Scalars['Int']['input']>;
  readingMinutes?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userWordsCount?: InputMaybe<Scalars['Int']['input']>;
  wordCreationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type DailyStatsMaxFields = {
  __typename?: 'daily_stats_max_fields';
  activityCompletionCount?: Maybe<Scalars['Int']['output']>;
  activityCreationCount?: Maybe<Scalars['Int']['output']>;
  activityResponsesCount?: Maybe<Scalars['Int']['output']>;
  bookCompletionCount?: Maybe<Scalars['Int']['output']>;
  bookCreationCount?: Maybe<Scalars['Int']['output']>;
  courseCompletionCount?: Maybe<Scalars['Int']['output']>;
  courseCreationCount?: Maybe<Scalars['Int']['output']>;
  end?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  listeningMinutes?: Maybe<Scalars['Int']['output']>;
  readingMinutes?: Maybe<Scalars['Int']['output']>;
  start?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  userWordsCount?: Maybe<Scalars['Int']['output']>;
  wordCreationCount?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type DailyStatsMinFields = {
  __typename?: 'daily_stats_min_fields';
  activityCompletionCount?: Maybe<Scalars['Int']['output']>;
  activityCreationCount?: Maybe<Scalars['Int']['output']>;
  activityResponsesCount?: Maybe<Scalars['Int']['output']>;
  bookCompletionCount?: Maybe<Scalars['Int']['output']>;
  bookCreationCount?: Maybe<Scalars['Int']['output']>;
  courseCompletionCount?: Maybe<Scalars['Int']['output']>;
  courseCreationCount?: Maybe<Scalars['Int']['output']>;
  end?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  listeningMinutes?: Maybe<Scalars['Int']['output']>;
  readingMinutes?: Maybe<Scalars['Int']['output']>;
  start?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  userWordsCount?: Maybe<Scalars['Int']['output']>;
  wordCreationCount?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "daily_stats" */
export type DailyStatsMutationResponse = {
  __typename?: 'daily_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DailyStats>;
};

/** on_conflict condition type for table "daily_stats" */
export type DailyStatsOnConflict = {
  constraint: DailyStatsConstraint;
  update_columns?: Array<DailyStatsUpdateColumn>;
  where?: InputMaybe<DailyStatsBoolExp>;
};

/** Ordering options when selecting data from "daily_stats". */
export type DailyStatsOrderBy = {
  activityCompletionCount?: InputMaybe<OrderBy>;
  activityCreationCount?: InputMaybe<OrderBy>;
  activityResponsesCount?: InputMaybe<OrderBy>;
  bookCompletionCount?: InputMaybe<OrderBy>;
  bookCreationCount?: InputMaybe<OrderBy>;
  courseCompletionCount?: InputMaybe<OrderBy>;
  courseCreationCount?: InputMaybe<OrderBy>;
  end?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  listeningMinutes?: InputMaybe<OrderBy>;
  readingMinutes?: InputMaybe<OrderBy>;
  start?: InputMaybe<OrderBy>;
  total?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userWordsCount?: InputMaybe<OrderBy>;
  wordCreationCount?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: daily_stats */
export type DailyStatsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "daily_stats" */
export enum DailyStatsSelectColumn {
  /** column name */
  ActivityCompletionCount = 'activityCompletionCount',
  /** column name */
  ActivityCreationCount = 'activityCreationCount',
  /** column name */
  ActivityResponsesCount = 'activityResponsesCount',
  /** column name */
  BookCompletionCount = 'bookCompletionCount',
  /** column name */
  BookCreationCount = 'bookCreationCount',
  /** column name */
  CourseCompletionCount = 'courseCompletionCount',
  /** column name */
  CourseCreationCount = 'courseCreationCount',
  /** column name */
  End = 'end',
  /** column name */
  Id = 'id',
  /** column name */
  ListeningMinutes = 'listeningMinutes',
  /** column name */
  ReadingMinutes = 'readingMinutes',
  /** column name */
  Start = 'start',
  /** column name */
  UserId = 'userId',
  /** column name */
  UserWordsCount = 'userWordsCount',
  /** column name */
  WordCreationCount = 'wordCreationCount'
}

/** input type for updating data in table "daily_stats" */
export type DailyStatsSetInput = {
  activityCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  activityCreationCount?: InputMaybe<Scalars['Int']['input']>;
  activityResponsesCount?: InputMaybe<Scalars['Int']['input']>;
  bookCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  bookCreationCount?: InputMaybe<Scalars['Int']['input']>;
  courseCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  courseCreationCount?: InputMaybe<Scalars['Int']['input']>;
  end?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  listeningMinutes?: InputMaybe<Scalars['Int']['input']>;
  readingMinutes?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userWordsCount?: InputMaybe<Scalars['Int']['input']>;
  wordCreationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type DailyStatsStddevFields = {
  __typename?: 'daily_stats_stddev_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinutes?: Maybe<Scalars['Float']['output']>;
  readingMinutes?: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type DailyStatsStddevPopFields = {
  __typename?: 'daily_stats_stddev_pop_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinutes?: Maybe<Scalars['Float']['output']>;
  readingMinutes?: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type DailyStatsStddevSampFields = {
  __typename?: 'daily_stats_stddev_samp_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinutes?: Maybe<Scalars['Float']['output']>;
  readingMinutes?: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "daily_stats" */
export type DailyStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: DailyStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DailyStatsStreamCursorValueInput = {
  activityCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  activityCreationCount?: InputMaybe<Scalars['Int']['input']>;
  activityResponsesCount?: InputMaybe<Scalars['Int']['input']>;
  bookCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  bookCreationCount?: InputMaybe<Scalars['Int']['input']>;
  courseCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  courseCreationCount?: InputMaybe<Scalars['Int']['input']>;
  end?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  listeningMinutes?: InputMaybe<Scalars['Int']['input']>;
  readingMinutes?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userWordsCount?: InputMaybe<Scalars['Int']['input']>;
  wordCreationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type DailyStatsSumFields = {
  __typename?: 'daily_stats_sum_fields';
  activityCompletionCount?: Maybe<Scalars['Int']['output']>;
  activityCreationCount?: Maybe<Scalars['Int']['output']>;
  activityResponsesCount?: Maybe<Scalars['Int']['output']>;
  bookCompletionCount?: Maybe<Scalars['Int']['output']>;
  bookCreationCount?: Maybe<Scalars['Int']['output']>;
  courseCompletionCount?: Maybe<Scalars['Int']['output']>;
  courseCreationCount?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  listeningMinutes?: Maybe<Scalars['Int']['output']>;
  readingMinutes?: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  userWordsCount?: Maybe<Scalars['Int']['output']>;
  wordCreationCount?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "daily_stats" */
export enum DailyStatsUpdateColumn {
  /** column name */
  ActivityCompletionCount = 'activityCompletionCount',
  /** column name */
  ActivityCreationCount = 'activityCreationCount',
  /** column name */
  ActivityResponsesCount = 'activityResponsesCount',
  /** column name */
  BookCompletionCount = 'bookCompletionCount',
  /** column name */
  BookCreationCount = 'bookCreationCount',
  /** column name */
  CourseCompletionCount = 'courseCompletionCount',
  /** column name */
  CourseCreationCount = 'courseCreationCount',
  /** column name */
  End = 'end',
  /** column name */
  Id = 'id',
  /** column name */
  ListeningMinutes = 'listeningMinutes',
  /** column name */
  ReadingMinutes = 'readingMinutes',
  /** column name */
  Start = 'start',
  /** column name */
  UserId = 'userId',
  /** column name */
  UserWordsCount = 'userWordsCount',
  /** column name */
  WordCreationCount = 'wordCreationCount'
}

export type DailyStatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DailyStatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DailyStatsSetInput>;
  /** filter the rows which have to be updated */
  where: DailyStatsBoolExp;
};

/** aggregate var_pop on columns */
export type DailyStatsVarPopFields = {
  __typename?: 'daily_stats_var_pop_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinutes?: Maybe<Scalars['Float']['output']>;
  readingMinutes?: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type DailyStatsVarSampFields = {
  __typename?: 'daily_stats_var_samp_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinutes?: Maybe<Scalars['Float']['output']>;
  readingMinutes?: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type DailyStatsVarianceFields = {
  __typename?: 'daily_stats_variance_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinutes?: Maybe<Scalars['Float']['output']>;
  readingMinutes?: Maybe<Scalars['Float']['output']>;
  /** A computed field, executes function "compute_daily_total_stats" */
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type DateComparisonExp = {
  _eq?: InputMaybe<Scalars['date']['input']>;
  _gt?: InputMaybe<Scalars['date']['input']>;
  _gte?: InputMaybe<Scalars['date']['input']>;
  _in?: InputMaybe<Array<Scalars['date']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['date']['input']>;
  _lte?: InputMaybe<Scalars['date']['input']>;
  _neq?: InputMaybe<Scalars['date']['input']>;
  _nin?: InputMaybe<Array<Scalars['date']['input']>>;
};

/** columns and relationships of "dictionaries" */
export type Dictionaries = {
  __typename?: 'dictionaries';
  dictionaryUrl: Scalars['String']['output'];
  fromLanguage: Scalars['Int']['output'];
  /** An object relationship */
  fromLanguageFields: Languages;
  id: Scalars['Int']['output'];
  isDefinition: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  toLanguage?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  toLanguageFields?: Maybe<Languages>;
  /** An array relationship */
  userDictionaries: Array<UserDictionaries>;
  /** An aggregate relationship */
  userDictionaries_aggregate: UserDictionariesAggregate;
};


/** columns and relationships of "dictionaries" */
export type DictionariesUserDictionariesArgs = {
  distinct_on?: InputMaybe<Array<UserDictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDictionariesOrderBy>>;
  where?: InputMaybe<UserDictionariesBoolExp>;
};


/** columns and relationships of "dictionaries" */
export type DictionariesUserDictionariesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserDictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDictionariesOrderBy>>;
  where?: InputMaybe<UserDictionariesBoolExp>;
};

/** aggregated selection of "dictionaries" */
export type DictionariesAggregate = {
  __typename?: 'dictionaries_aggregate';
  aggregate?: Maybe<DictionariesAggregateFields>;
  nodes: Array<Dictionaries>;
};

/** aggregate fields of "dictionaries" */
export type DictionariesAggregateFields = {
  __typename?: 'dictionaries_aggregate_fields';
  avg?: Maybe<DictionariesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<DictionariesMaxFields>;
  min?: Maybe<DictionariesMinFields>;
  stddev?: Maybe<DictionariesStddevFields>;
  stddev_pop?: Maybe<DictionariesStddevPopFields>;
  stddev_samp?: Maybe<DictionariesStddevSampFields>;
  sum?: Maybe<DictionariesSumFields>;
  var_pop?: Maybe<DictionariesVarPopFields>;
  var_samp?: Maybe<DictionariesVarSampFields>;
  variance?: Maybe<DictionariesVarianceFields>;
};


/** aggregate fields of "dictionaries" */
export type DictionariesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DictionariesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type DictionariesAvgFields = {
  __typename?: 'dictionaries_avg_fields';
  fromLanguage?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  toLanguage?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "dictionaries". All fields are combined with a logical 'AND'. */
export type DictionariesBoolExp = {
  _and?: InputMaybe<Array<DictionariesBoolExp>>;
  _not?: InputMaybe<DictionariesBoolExp>;
  _or?: InputMaybe<Array<DictionariesBoolExp>>;
  dictionaryUrl?: InputMaybe<StringComparisonExp>;
  fromLanguage?: InputMaybe<IntComparisonExp>;
  fromLanguageFields?: InputMaybe<LanguagesBoolExp>;
  id?: InputMaybe<IntComparisonExp>;
  isDefinition?: InputMaybe<BooleanComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  toLanguage?: InputMaybe<IntComparisonExp>;
  toLanguageFields?: InputMaybe<LanguagesBoolExp>;
  userDictionaries?: InputMaybe<UserDictionariesBoolExp>;
  userDictionaries_aggregate?: InputMaybe<UserDictionariesAggregateBoolExp>;
};

/** unique or primary key constraints on table "dictionaries" */
export enum DictionariesConstraint {
  /** unique or primary key constraint on columns "id" */
  DictionariesPkey = 'dictionaries_pkey'
}

/** input type for incrementing numeric columns in table "dictionaries" */
export type DictionariesIncInput = {
  fromLanguage?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  toLanguage?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "dictionaries" */
export type DictionariesInsertInput = {
  dictionaryUrl?: InputMaybe<Scalars['String']['input']>;
  fromLanguage?: InputMaybe<Scalars['Int']['input']>;
  fromLanguageFields?: InputMaybe<LanguagesObjRelInsertInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isDefinition?: InputMaybe<Scalars['Boolean']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  toLanguage?: InputMaybe<Scalars['Int']['input']>;
  toLanguageFields?: InputMaybe<LanguagesObjRelInsertInput>;
  userDictionaries?: InputMaybe<UserDictionariesArrRelInsertInput>;
};

/** aggregate max on columns */
export type DictionariesMaxFields = {
  __typename?: 'dictionaries_max_fields';
  dictionaryUrl?: Maybe<Scalars['String']['output']>;
  fromLanguage?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  toLanguage?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type DictionariesMinFields = {
  __typename?: 'dictionaries_min_fields';
  dictionaryUrl?: Maybe<Scalars['String']['output']>;
  fromLanguage?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  toLanguage?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "dictionaries" */
export type DictionariesMutationResponse = {
  __typename?: 'dictionaries_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Dictionaries>;
};

/** on_conflict condition type for table "dictionaries" */
export type DictionariesOnConflict = {
  constraint: DictionariesConstraint;
  update_columns?: Array<DictionariesUpdateColumn>;
  where?: InputMaybe<DictionariesBoolExp>;
};

/** Ordering options when selecting data from "dictionaries". */
export type DictionariesOrderBy = {
  dictionaryUrl?: InputMaybe<OrderBy>;
  fromLanguage?: InputMaybe<OrderBy>;
  fromLanguageFields?: InputMaybe<LanguagesOrderBy>;
  id?: InputMaybe<OrderBy>;
  isDefinition?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  toLanguage?: InputMaybe<OrderBy>;
  toLanguageFields?: InputMaybe<LanguagesOrderBy>;
  userDictionaries_aggregate?: InputMaybe<UserDictionariesAggregateOrderBy>;
};

/** primary key columns input for table: dictionaries */
export type DictionariesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "dictionaries" */
export enum DictionariesSelectColumn {
  /** column name */
  DictionaryUrl = 'dictionaryUrl',
  /** column name */
  FromLanguage = 'fromLanguage',
  /** column name */
  Id = 'id',
  /** column name */
  IsDefinition = 'isDefinition',
  /** column name */
  Title = 'title',
  /** column name */
  ToLanguage = 'toLanguage'
}

/** input type for updating data in table "dictionaries" */
export type DictionariesSetInput = {
  dictionaryUrl?: InputMaybe<Scalars['String']['input']>;
  fromLanguage?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isDefinition?: InputMaybe<Scalars['Boolean']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  toLanguage?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type DictionariesStddevFields = {
  __typename?: 'dictionaries_stddev_fields';
  fromLanguage?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  toLanguage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type DictionariesStddevPopFields = {
  __typename?: 'dictionaries_stddev_pop_fields';
  fromLanguage?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  toLanguage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type DictionariesStddevSampFields = {
  __typename?: 'dictionaries_stddev_samp_fields';
  fromLanguage?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  toLanguage?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "dictionaries" */
export type DictionariesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: DictionariesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DictionariesStreamCursorValueInput = {
  dictionaryUrl?: InputMaybe<Scalars['String']['input']>;
  fromLanguage?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isDefinition?: InputMaybe<Scalars['Boolean']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  toLanguage?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type DictionariesSumFields = {
  __typename?: 'dictionaries_sum_fields';
  fromLanguage?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  toLanguage?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "dictionaries" */
export enum DictionariesUpdateColumn {
  /** column name */
  DictionaryUrl = 'dictionaryUrl',
  /** column name */
  FromLanguage = 'fromLanguage',
  /** column name */
  Id = 'id',
  /** column name */
  IsDefinition = 'isDefinition',
  /** column name */
  Title = 'title',
  /** column name */
  ToLanguage = 'toLanguage'
}

export type DictionariesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DictionariesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DictionariesSetInput>;
  /** filter the rows which have to be updated */
  where: DictionariesBoolExp;
};

/** aggregate var_pop on columns */
export type DictionariesVarPopFields = {
  __typename?: 'dictionaries_var_pop_fields';
  fromLanguage?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  toLanguage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type DictionariesVarSampFields = {
  __typename?: 'dictionaries_var_samp_fields';
  fromLanguage?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  toLanguage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type DictionariesVarianceFields = {
  __typename?: 'dictionaries_variance_fields';
  fromLanguage?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  toLanguage?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "emojis" */
export type Emojis = {
  __typename?: 'emojis';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  tags: Scalars['jsonb']['output'];
  unicode: Scalars['String']['output'];
  url: Scalars['String']['output'];
};


/** columns and relationships of "emojis" */
export type EmojisTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "emojis" */
export type EmojisAggregate = {
  __typename?: 'emojis_aggregate';
  aggregate?: Maybe<EmojisAggregateFields>;
  nodes: Array<Emojis>;
};

/** aggregate fields of "emojis" */
export type EmojisAggregateFields = {
  __typename?: 'emojis_aggregate_fields';
  avg?: Maybe<EmojisAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<EmojisMaxFields>;
  min?: Maybe<EmojisMinFields>;
  stddev?: Maybe<EmojisStddevFields>;
  stddev_pop?: Maybe<EmojisStddevPopFields>;
  stddev_samp?: Maybe<EmojisStddevSampFields>;
  sum?: Maybe<EmojisSumFields>;
  var_pop?: Maybe<EmojisVarPopFields>;
  var_samp?: Maybe<EmojisVarSampFields>;
  variance?: Maybe<EmojisVarianceFields>;
};


/** aggregate fields of "emojis" */
export type EmojisAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EmojisSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type EmojisAppendInput = {
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type EmojisAvgFields = {
  __typename?: 'emojis_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "emojis". All fields are combined with a logical 'AND'. */
export type EmojisBoolExp = {
  _and?: InputMaybe<Array<EmojisBoolExp>>;
  _not?: InputMaybe<EmojisBoolExp>;
  _or?: InputMaybe<Array<EmojisBoolExp>>;
  id?: InputMaybe<IntComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  tags?: InputMaybe<JsonbComparisonExp>;
  unicode?: InputMaybe<StringComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "emojis" */
export enum EmojisConstraint {
  /** unique or primary key constraint on columns "id" */
  EmojisPkey = 'emojis_pkey',
  /** unique or primary key constraint on columns "unicode" */
  EmojisUnicodeKey = 'emojis_unicode_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type EmojisDeleteAtPathInput = {
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type EmojisDeleteElemInput = {
  tags?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type EmojisDeleteKeyInput = {
  tags?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "emojis" */
export type EmojisIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "emojis" */
export type EmojisInsertInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  unicode?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type EmojisMaxFields = {
  __typename?: 'emojis_max_fields';
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  unicode?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type EmojisMinFields = {
  __typename?: 'emojis_min_fields';
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  unicode?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "emojis" */
export type EmojisMutationResponse = {
  __typename?: 'emojis_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Emojis>;
};

/** on_conflict condition type for table "emojis" */
export type EmojisOnConflict = {
  constraint: EmojisConstraint;
  update_columns?: Array<EmojisUpdateColumn>;
  where?: InputMaybe<EmojisBoolExp>;
};

/** Ordering options when selecting data from "emojis". */
export type EmojisOrderBy = {
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  tags?: InputMaybe<OrderBy>;
  unicode?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: emojis */
export type EmojisPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type EmojisPrependInput = {
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "emojis" */
export enum EmojisSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Tags = 'tags',
  /** column name */
  Unicode = 'unicode',
  /** column name */
  Url = 'url'
}

/** input type for updating data in table "emojis" */
export type EmojisSetInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  unicode?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type EmojisStddevFields = {
  __typename?: 'emojis_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type EmojisStddevPopFields = {
  __typename?: 'emojis_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type EmojisStddevSampFields = {
  __typename?: 'emojis_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "emojis" */
export type EmojisStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: EmojisStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EmojisStreamCursorValueInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  unicode?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type EmojisSumFields = {
  __typename?: 'emojis_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "emojis" */
export enum EmojisUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Tags = 'tags',
  /** column name */
  Unicode = 'unicode',
  /** column name */
  Url = 'url'
}

export type EmojisUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<EmojisAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<EmojisDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<EmojisDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<EmojisDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EmojisIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<EmojisPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EmojisSetInput>;
  /** filter the rows which have to be updated */
  where: EmojisBoolExp;
};

/** aggregate var_pop on columns */
export type EmojisVarPopFields = {
  __typename?: 'emojis_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type EmojisVarSampFields = {
  __typename?: 'emojis_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type EmojisVarianceFields = {
  __typename?: 'emojis_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "employees" */
export type Employees = {
  __typename?: 'employees';
  created_at: Scalars['timestamptz']['output'];
  deleted_at?: Maybe<Scalars['timestamptz']['output']>;
  isAdmin?: Maybe<Scalars['Boolean']['output']>;
  isSuperAdmin?: Maybe<Scalars['Boolean']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['Int']['output'];
};

/** aggregated selection of "employees" */
export type EmployeesAggregate = {
  __typename?: 'employees_aggregate';
  aggregate?: Maybe<EmployeesAggregateFields>;
  nodes: Array<Employees>;
};

/** aggregate fields of "employees" */
export type EmployeesAggregateFields = {
  __typename?: 'employees_aggregate_fields';
  avg?: Maybe<EmployeesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<EmployeesMaxFields>;
  min?: Maybe<EmployeesMinFields>;
  stddev?: Maybe<EmployeesStddevFields>;
  stddev_pop?: Maybe<EmployeesStddevPopFields>;
  stddev_samp?: Maybe<EmployeesStddevSampFields>;
  sum?: Maybe<EmployeesSumFields>;
  var_pop?: Maybe<EmployeesVarPopFields>;
  var_samp?: Maybe<EmployeesVarSampFields>;
  variance?: Maybe<EmployeesVarianceFields>;
};


/** aggregate fields of "employees" */
export type EmployeesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EmployeesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type EmployeesAvgFields = {
  __typename?: 'employees_avg_fields';
  userId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "employees". All fields are combined with a logical 'AND'. */
export type EmployeesBoolExp = {
  _and?: InputMaybe<Array<EmployeesBoolExp>>;
  _not?: InputMaybe<EmployeesBoolExp>;
  _or?: InputMaybe<Array<EmployeesBoolExp>>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  deleted_at?: InputMaybe<TimestamptzComparisonExp>;
  isAdmin?: InputMaybe<BooleanComparisonExp>;
  isSuperAdmin?: InputMaybe<BooleanComparisonExp>;
  updated_at?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "employees" */
export enum EmployeesConstraint {
  /** unique or primary key constraint on columns "user_id" */
  EmployeesPkey = 'employees_pkey'
}

/** input type for incrementing numeric columns in table "employees" */
export type EmployeesIncInput = {
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "employees" */
export type EmployeesInsertInput = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  isSuperAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type EmployeesMaxFields = {
  __typename?: 'employees_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deleted_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type EmployeesMinFields = {
  __typename?: 'employees_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deleted_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "employees" */
export type EmployeesMutationResponse = {
  __typename?: 'employees_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Employees>;
};

/** input type for inserting object relation for remote table "employees" */
export type EmployeesObjRelInsertInput = {
  data: EmployeesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<EmployeesOnConflict>;
};

/** on_conflict condition type for table "employees" */
export type EmployeesOnConflict = {
  constraint: EmployeesConstraint;
  update_columns?: Array<EmployeesUpdateColumn>;
  where?: InputMaybe<EmployeesBoolExp>;
};

/** Ordering options when selecting data from "employees". */
export type EmployeesOrderBy = {
  created_at?: InputMaybe<OrderBy>;
  deleted_at?: InputMaybe<OrderBy>;
  isAdmin?: InputMaybe<OrderBy>;
  isSuperAdmin?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: employees */
export type EmployeesPkColumnsInput = {
  userId: Scalars['Int']['input'];
};

/** select columns of table "employees" */
export enum EmployeesSelectColumn {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  IsAdmin = 'isAdmin',
  /** column name */
  IsSuperAdmin = 'isSuperAdmin',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "employees" */
export type EmployeesSetInput = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  isSuperAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type EmployeesStddevFields = {
  __typename?: 'employees_stddev_fields';
  userId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type EmployeesStddevPopFields = {
  __typename?: 'employees_stddev_pop_fields';
  userId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type EmployeesStddevSampFields = {
  __typename?: 'employees_stddev_samp_fields';
  userId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "employees" */
export type EmployeesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: EmployeesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EmployeesStreamCursorValueInput = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted_at?: InputMaybe<Scalars['timestamptz']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  isSuperAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type EmployeesSumFields = {
  __typename?: 'employees_sum_fields';
  userId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "employees" */
export enum EmployeesUpdateColumn {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeletedAt = 'deleted_at',
  /** column name */
  IsAdmin = 'isAdmin',
  /** column name */
  IsSuperAdmin = 'isSuperAdmin',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId'
}

export type EmployeesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EmployeesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EmployeesSetInput>;
  /** filter the rows which have to be updated */
  where: EmployeesBoolExp;
};

/** aggregate var_pop on columns */
export type EmployeesVarPopFields = {
  __typename?: 'employees_var_pop_fields';
  userId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type EmployeesVarSampFields = {
  __typename?: 'employees_var_samp_fields';
  userId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type EmployeesVarianceFields = {
  __typename?: 'employees_variance_fields';
  userId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "example_joins" */
export type ExampleJoins = {
  __typename?: 'example_joins';
  /** An object relationship */
  exampleTranslation: Examples;
  /** An object relationship */
  exampleTranslationTwo: Examples;
  from_id: Scalars['Int']['output'];
  to_id: Scalars['Int']['output'];
};

/** aggregated selection of "example_joins" */
export type ExampleJoinsAggregate = {
  __typename?: 'example_joins_aggregate';
  aggregate?: Maybe<ExampleJoinsAggregateFields>;
  nodes: Array<ExampleJoins>;
};

export type ExampleJoinsAggregateBoolExp = {
  count?: InputMaybe<ExampleJoinsAggregateBoolExpCount>;
};

export type ExampleJoinsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ExampleJoinsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ExampleJoinsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "example_joins" */
export type ExampleJoinsAggregateFields = {
  __typename?: 'example_joins_aggregate_fields';
  avg?: Maybe<ExampleJoinsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ExampleJoinsMaxFields>;
  min?: Maybe<ExampleJoinsMinFields>;
  stddev?: Maybe<ExampleJoinsStddevFields>;
  stddev_pop?: Maybe<ExampleJoinsStddevPopFields>;
  stddev_samp?: Maybe<ExampleJoinsStddevSampFields>;
  sum?: Maybe<ExampleJoinsSumFields>;
  var_pop?: Maybe<ExampleJoinsVarPopFields>;
  var_samp?: Maybe<ExampleJoinsVarSampFields>;
  variance?: Maybe<ExampleJoinsVarianceFields>;
};


/** aggregate fields of "example_joins" */
export type ExampleJoinsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ExampleJoinsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "example_joins" */
export type ExampleJoinsAggregateOrderBy = {
  avg?: InputMaybe<ExampleJoinsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ExampleJoinsMaxOrderBy>;
  min?: InputMaybe<ExampleJoinsMinOrderBy>;
  stddev?: InputMaybe<ExampleJoinsStddevOrderBy>;
  stddev_pop?: InputMaybe<ExampleJoinsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<ExampleJoinsStddevSampOrderBy>;
  sum?: InputMaybe<ExampleJoinsSumOrderBy>;
  var_pop?: InputMaybe<ExampleJoinsVarPopOrderBy>;
  var_samp?: InputMaybe<ExampleJoinsVarSampOrderBy>;
  variance?: InputMaybe<ExampleJoinsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "example_joins" */
export type ExampleJoinsArrRelInsertInput = {
  data: Array<ExampleJoinsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ExampleJoinsOnConflict>;
};

/** aggregate avg on columns */
export type ExampleJoinsAvgFields = {
  __typename?: 'example_joins_avg_fields';
  from_id?: Maybe<Scalars['Float']['output']>;
  to_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "example_joins" */
export type ExampleJoinsAvgOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "example_joins". All fields are combined with a logical 'AND'. */
export type ExampleJoinsBoolExp = {
  _and?: InputMaybe<Array<ExampleJoinsBoolExp>>;
  _not?: InputMaybe<ExampleJoinsBoolExp>;
  _or?: InputMaybe<Array<ExampleJoinsBoolExp>>;
  exampleTranslation?: InputMaybe<ExamplesBoolExp>;
  exampleTranslationTwo?: InputMaybe<ExamplesBoolExp>;
  from_id?: InputMaybe<IntComparisonExp>;
  to_id?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "example_joins" */
export enum ExampleJoinsConstraint {
  /** unique or primary key constraint on columns "from_id", "to_id" */
  ExampleJoinsPkey = 'example_joins_pkey'
}

/** input type for incrementing numeric columns in table "example_joins" */
export type ExampleJoinsIncInput = {
  from_id?: InputMaybe<Scalars['Int']['input']>;
  to_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "example_joins" */
export type ExampleJoinsInsertInput = {
  exampleTranslation?: InputMaybe<ExamplesObjRelInsertInput>;
  exampleTranslationTwo?: InputMaybe<ExamplesObjRelInsertInput>;
  from_id?: InputMaybe<Scalars['Int']['input']>;
  to_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ExampleJoinsMaxFields = {
  __typename?: 'example_joins_max_fields';
  from_id?: Maybe<Scalars['Int']['output']>;
  to_id?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "example_joins" */
export type ExampleJoinsMaxOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ExampleJoinsMinFields = {
  __typename?: 'example_joins_min_fields';
  from_id?: Maybe<Scalars['Int']['output']>;
  to_id?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "example_joins" */
export type ExampleJoinsMinOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "example_joins" */
export type ExampleJoinsMutationResponse = {
  __typename?: 'example_joins_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ExampleJoins>;
};

/** on_conflict condition type for table "example_joins" */
export type ExampleJoinsOnConflict = {
  constraint: ExampleJoinsConstraint;
  update_columns?: Array<ExampleJoinsUpdateColumn>;
  where?: InputMaybe<ExampleJoinsBoolExp>;
};

/** Ordering options when selecting data from "example_joins". */
export type ExampleJoinsOrderBy = {
  exampleTranslation?: InputMaybe<ExamplesOrderBy>;
  exampleTranslationTwo?: InputMaybe<ExamplesOrderBy>;
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: example_joins */
export type ExampleJoinsPkColumnsInput = {
  from_id: Scalars['Int']['input'];
  to_id: Scalars['Int']['input'];
};

/** select columns of table "example_joins" */
export enum ExampleJoinsSelectColumn {
  /** column name */
  FromId = 'from_id',
  /** column name */
  ToId = 'to_id'
}

/** input type for updating data in table "example_joins" */
export type ExampleJoinsSetInput = {
  from_id?: InputMaybe<Scalars['Int']['input']>;
  to_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ExampleJoinsStddevFields = {
  __typename?: 'example_joins_stddev_fields';
  from_id?: Maybe<Scalars['Float']['output']>;
  to_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "example_joins" */
export type ExampleJoinsStddevOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type ExampleJoinsStddevPopFields = {
  __typename?: 'example_joins_stddev_pop_fields';
  from_id?: Maybe<Scalars['Float']['output']>;
  to_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "example_joins" */
export type ExampleJoinsStddevPopOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type ExampleJoinsStddevSampFields = {
  __typename?: 'example_joins_stddev_samp_fields';
  from_id?: Maybe<Scalars['Float']['output']>;
  to_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "example_joins" */
export type ExampleJoinsStddevSampOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "example_joins" */
export type ExampleJoinsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ExampleJoinsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ExampleJoinsStreamCursorValueInput = {
  from_id?: InputMaybe<Scalars['Int']['input']>;
  to_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ExampleJoinsSumFields = {
  __typename?: 'example_joins_sum_fields';
  from_id?: Maybe<Scalars['Int']['output']>;
  to_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "example_joins" */
export type ExampleJoinsSumOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** update columns of table "example_joins" */
export enum ExampleJoinsUpdateColumn {
  /** column name */
  FromId = 'from_id',
  /** column name */
  ToId = 'to_id'
}

export type ExampleJoinsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ExampleJoinsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ExampleJoinsSetInput>;
  /** filter the rows which have to be updated */
  where: ExampleJoinsBoolExp;
};

/** aggregate var_pop on columns */
export type ExampleJoinsVarPopFields = {
  __typename?: 'example_joins_var_pop_fields';
  from_id?: Maybe<Scalars['Float']['output']>;
  to_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "example_joins" */
export type ExampleJoinsVarPopOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type ExampleJoinsVarSampFields = {
  __typename?: 'example_joins_var_samp_fields';
  from_id?: Maybe<Scalars['Float']['output']>;
  to_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "example_joins" */
export type ExampleJoinsVarSampOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ExampleJoinsVarianceFields = {
  __typename?: 'example_joins_variance_fields';
  from_id?: Maybe<Scalars['Float']['output']>;
  to_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "example_joins" */
export type ExampleJoinsVarianceOrderBy = {
  from_id?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "examples" */
export type Examples = {
  __typename?: 'examples';
  attributionUrl?: Maybe<Scalars['String']['output']>;
  audioUrl?: Maybe<Scalars['String']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  example: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  languageId: Scalars['Int']['output'];
  license?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  translations: Array<ExampleJoins>;
  /** An aggregate relationship */
  translations_aggregate: ExampleJoinsAggregate;
};


/** columns and relationships of "examples" */
export type ExamplesTranslationsArgs = {
  distinct_on?: InputMaybe<Array<ExampleJoinsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExampleJoinsOrderBy>>;
  where?: InputMaybe<ExampleJoinsBoolExp>;
};


/** columns and relationships of "examples" */
export type ExamplesTranslationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ExampleJoinsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExampleJoinsOrderBy>>;
  where?: InputMaybe<ExampleJoinsBoolExp>;
};

/** aggregated selection of "examples" */
export type ExamplesAggregate = {
  __typename?: 'examples_aggregate';
  aggregate?: Maybe<ExamplesAggregateFields>;
  nodes: Array<Examples>;
};

/** aggregate fields of "examples" */
export type ExamplesAggregateFields = {
  __typename?: 'examples_aggregate_fields';
  avg?: Maybe<ExamplesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ExamplesMaxFields>;
  min?: Maybe<ExamplesMinFields>;
  stddev?: Maybe<ExamplesStddevFields>;
  stddev_pop?: Maybe<ExamplesStddevPopFields>;
  stddev_samp?: Maybe<ExamplesStddevSampFields>;
  sum?: Maybe<ExamplesSumFields>;
  var_pop?: Maybe<ExamplesVarPopFields>;
  var_samp?: Maybe<ExamplesVarSampFields>;
  variance?: Maybe<ExamplesVarianceFields>;
};


/** aggregate fields of "examples" */
export type ExamplesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ExamplesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ExamplesAvgFields = {
  __typename?: 'examples_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "examples". All fields are combined with a logical 'AND'. */
export type ExamplesBoolExp = {
  _and?: InputMaybe<Array<ExamplesBoolExp>>;
  _not?: InputMaybe<ExamplesBoolExp>;
  _or?: InputMaybe<Array<ExamplesBoolExp>>;
  attributionUrl?: InputMaybe<StringComparisonExp>;
  audioUrl?: InputMaybe<StringComparisonExp>;
  author?: InputMaybe<StringComparisonExp>;
  example?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  languageId?: InputMaybe<IntComparisonExp>;
  license?: InputMaybe<StringComparisonExp>;
  translations?: InputMaybe<ExampleJoinsBoolExp>;
  translations_aggregate?: InputMaybe<ExampleJoinsAggregateBoolExp>;
};

/** unique or primary key constraints on table "examples" */
export enum ExamplesConstraint {
  /** unique or primary key constraint on columns "id" */
  ExamplesPkey = 'examples_pkey'
}

/** input type for incrementing numeric columns in table "examples" */
export type ExamplesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "examples" */
export type ExamplesInsertInput = {
  attributionUrl?: InputMaybe<Scalars['String']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  example?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  license?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<ExampleJoinsArrRelInsertInput>;
};

/** aggregate max on columns */
export type ExamplesMaxFields = {
  __typename?: 'examples_max_fields';
  attributionUrl?: Maybe<Scalars['String']['output']>;
  audioUrl?: Maybe<Scalars['String']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  example?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  license?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type ExamplesMinFields = {
  __typename?: 'examples_min_fields';
  attributionUrl?: Maybe<Scalars['String']['output']>;
  audioUrl?: Maybe<Scalars['String']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  example?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  license?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "examples" */
export type ExamplesMutationResponse = {
  __typename?: 'examples_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Examples>;
};

/** input type for inserting object relation for remote table "examples" */
export type ExamplesObjRelInsertInput = {
  data: ExamplesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ExamplesOnConflict>;
};

/** on_conflict condition type for table "examples" */
export type ExamplesOnConflict = {
  constraint: ExamplesConstraint;
  update_columns?: Array<ExamplesUpdateColumn>;
  where?: InputMaybe<ExamplesBoolExp>;
};

/** Ordering options when selecting data from "examples". */
export type ExamplesOrderBy = {
  attributionUrl?: InputMaybe<OrderBy>;
  audioUrl?: InputMaybe<OrderBy>;
  author?: InputMaybe<OrderBy>;
  example?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  license?: InputMaybe<OrderBy>;
  translations_aggregate?: InputMaybe<ExampleJoinsAggregateOrderBy>;
};

/** primary key columns input for table: examples */
export type ExamplesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "examples" */
export enum ExamplesSelectColumn {
  /** column name */
  AttributionUrl = 'attributionUrl',
  /** column name */
  AudioUrl = 'audioUrl',
  /** column name */
  Author = 'author',
  /** column name */
  Example = 'example',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  License = 'license'
}

/** input type for updating data in table "examples" */
export type ExamplesSetInput = {
  attributionUrl?: InputMaybe<Scalars['String']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  example?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  license?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type ExamplesStddevFields = {
  __typename?: 'examples_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ExamplesStddevPopFields = {
  __typename?: 'examples_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ExamplesStddevSampFields = {
  __typename?: 'examples_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "examples" */
export type ExamplesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ExamplesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ExamplesStreamCursorValueInput = {
  attributionUrl?: InputMaybe<Scalars['String']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  example?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  license?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type ExamplesSumFields = {
  __typename?: 'examples_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "examples" */
export enum ExamplesUpdateColumn {
  /** column name */
  AttributionUrl = 'attributionUrl',
  /** column name */
  AudioUrl = 'audioUrl',
  /** column name */
  Author = 'author',
  /** column name */
  Example = 'example',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  License = 'license'
}

export type ExamplesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ExamplesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ExamplesSetInput>;
  /** filter the rows which have to be updated */
  where: ExamplesBoolExp;
};

/** aggregate var_pop on columns */
export type ExamplesVarPopFields = {
  __typename?: 'examples_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ExamplesVarSampFields = {
  __typename?: 'examples_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ExamplesVarianceFields = {
  __typename?: 'examples_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "expired_refresh_tokens" */
export type ExpiredRefreshTokens = {
  __typename?: 'expired_refresh_tokens';
  token: Scalars['String']['output'];
  user_id: Scalars['Int']['output'];
};

/** aggregated selection of "expired_refresh_tokens" */
export type ExpiredRefreshTokensAggregate = {
  __typename?: 'expired_refresh_tokens_aggregate';
  aggregate?: Maybe<ExpiredRefreshTokensAggregateFields>;
  nodes: Array<ExpiredRefreshTokens>;
};

/** aggregate fields of "expired_refresh_tokens" */
export type ExpiredRefreshTokensAggregateFields = {
  __typename?: 'expired_refresh_tokens_aggregate_fields';
  avg?: Maybe<ExpiredRefreshTokensAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ExpiredRefreshTokensMaxFields>;
  min?: Maybe<ExpiredRefreshTokensMinFields>;
  stddev?: Maybe<ExpiredRefreshTokensStddevFields>;
  stddev_pop?: Maybe<ExpiredRefreshTokensStddevPopFields>;
  stddev_samp?: Maybe<ExpiredRefreshTokensStddevSampFields>;
  sum?: Maybe<ExpiredRefreshTokensSumFields>;
  var_pop?: Maybe<ExpiredRefreshTokensVarPopFields>;
  var_samp?: Maybe<ExpiredRefreshTokensVarSampFields>;
  variance?: Maybe<ExpiredRefreshTokensVarianceFields>;
};


/** aggregate fields of "expired_refresh_tokens" */
export type ExpiredRefreshTokensAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ExpiredRefreshTokensSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ExpiredRefreshTokensAvgFields = {
  __typename?: 'expired_refresh_tokens_avg_fields';
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "expired_refresh_tokens". All fields are combined with a logical 'AND'. */
export type ExpiredRefreshTokensBoolExp = {
  _and?: InputMaybe<Array<ExpiredRefreshTokensBoolExp>>;
  _not?: InputMaybe<ExpiredRefreshTokensBoolExp>;
  _or?: InputMaybe<Array<ExpiredRefreshTokensBoolExp>>;
  token?: InputMaybe<StringComparisonExp>;
  user_id?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "expired_refresh_tokens" */
export enum ExpiredRefreshTokensConstraint {
  /** unique or primary key constraint on columns "token" */
  ExpiredAccessTokensPkey = 'expired_access_tokens_pkey'
}

/** input type for incrementing numeric columns in table "expired_refresh_tokens" */
export type ExpiredRefreshTokensIncInput = {
  user_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "expired_refresh_tokens" */
export type ExpiredRefreshTokensInsertInput = {
  token?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ExpiredRefreshTokensMaxFields = {
  __typename?: 'expired_refresh_tokens_max_fields';
  token?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type ExpiredRefreshTokensMinFields = {
  __typename?: 'expired_refresh_tokens_min_fields';
  token?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "expired_refresh_tokens" */
export type ExpiredRefreshTokensMutationResponse = {
  __typename?: 'expired_refresh_tokens_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ExpiredRefreshTokens>;
};

/** on_conflict condition type for table "expired_refresh_tokens" */
export type ExpiredRefreshTokensOnConflict = {
  constraint: ExpiredRefreshTokensConstraint;
  update_columns?: Array<ExpiredRefreshTokensUpdateColumn>;
  where?: InputMaybe<ExpiredRefreshTokensBoolExp>;
};

/** Ordering options when selecting data from "expired_refresh_tokens". */
export type ExpiredRefreshTokensOrderBy = {
  token?: InputMaybe<OrderBy>;
  user_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: expired_refresh_tokens */
export type ExpiredRefreshTokensPkColumnsInput = {
  token: Scalars['String']['input'];
};

/** select columns of table "expired_refresh_tokens" */
export enum ExpiredRefreshTokensSelectColumn {
  /** column name */
  Token = 'token',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "expired_refresh_tokens" */
export type ExpiredRefreshTokensSetInput = {
  token?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ExpiredRefreshTokensStddevFields = {
  __typename?: 'expired_refresh_tokens_stddev_fields';
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ExpiredRefreshTokensStddevPopFields = {
  __typename?: 'expired_refresh_tokens_stddev_pop_fields';
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ExpiredRefreshTokensStddevSampFields = {
  __typename?: 'expired_refresh_tokens_stddev_samp_fields';
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "expired_refresh_tokens" */
export type ExpiredRefreshTokensStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ExpiredRefreshTokensStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ExpiredRefreshTokensStreamCursorValueInput = {
  token?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ExpiredRefreshTokensSumFields = {
  __typename?: 'expired_refresh_tokens_sum_fields';
  user_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "expired_refresh_tokens" */
export enum ExpiredRefreshTokensUpdateColumn {
  /** column name */
  Token = 'token',
  /** column name */
  UserId = 'user_id'
}

export type ExpiredRefreshTokensUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ExpiredRefreshTokensIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ExpiredRefreshTokensSetInput>;
  /** filter the rows which have to be updated */
  where: ExpiredRefreshTokensBoolExp;
};

/** aggregate var_pop on columns */
export type ExpiredRefreshTokensVarPopFields = {
  __typename?: 'expired_refresh_tokens_var_pop_fields';
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ExpiredRefreshTokensVarSampFields = {
  __typename?: 'expired_refresh_tokens_var_samp_fields';
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ExpiredRefreshTokensVarianceFields = {
  __typename?: 'expired_refresh_tokens_variance_fields';
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "fill_in_the_blank_options" */
export type FillInTheBlankOptions = {
  __typename?: 'fill_in_the_blank_options';
  created_by: Scalars['Int']['output'];
  fillInTheBlankId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  option: Scalars['String']['output'];
};

/** aggregated selection of "fill_in_the_blank_options" */
export type FillInTheBlankOptionsAggregate = {
  __typename?: 'fill_in_the_blank_options_aggregate';
  aggregate?: Maybe<FillInTheBlankOptionsAggregateFields>;
  nodes: Array<FillInTheBlankOptions>;
};

export type FillInTheBlankOptionsAggregateBoolExp = {
  count?: InputMaybe<FillInTheBlankOptionsAggregateBoolExpCount>;
};

export type FillInTheBlankOptionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<FillInTheBlankOptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FillInTheBlankOptionsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "fill_in_the_blank_options" */
export type FillInTheBlankOptionsAggregateFields = {
  __typename?: 'fill_in_the_blank_options_aggregate_fields';
  avg?: Maybe<FillInTheBlankOptionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<FillInTheBlankOptionsMaxFields>;
  min?: Maybe<FillInTheBlankOptionsMinFields>;
  stddev?: Maybe<FillInTheBlankOptionsStddevFields>;
  stddev_pop?: Maybe<FillInTheBlankOptionsStddevPopFields>;
  stddev_samp?: Maybe<FillInTheBlankOptionsStddevSampFields>;
  sum?: Maybe<FillInTheBlankOptionsSumFields>;
  var_pop?: Maybe<FillInTheBlankOptionsVarPopFields>;
  var_samp?: Maybe<FillInTheBlankOptionsVarSampFields>;
  variance?: Maybe<FillInTheBlankOptionsVarianceFields>;
};


/** aggregate fields of "fill_in_the_blank_options" */
export type FillInTheBlankOptionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FillInTheBlankOptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsAggregateOrderBy = {
  avg?: InputMaybe<FillInTheBlankOptionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<FillInTheBlankOptionsMaxOrderBy>;
  min?: InputMaybe<FillInTheBlankOptionsMinOrderBy>;
  stddev?: InputMaybe<FillInTheBlankOptionsStddevOrderBy>;
  stddev_pop?: InputMaybe<FillInTheBlankOptionsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<FillInTheBlankOptionsStddevSampOrderBy>;
  sum?: InputMaybe<FillInTheBlankOptionsSumOrderBy>;
  var_pop?: InputMaybe<FillInTheBlankOptionsVarPopOrderBy>;
  var_samp?: InputMaybe<FillInTheBlankOptionsVarSampOrderBy>;
  variance?: InputMaybe<FillInTheBlankOptionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsArrRelInsertInput = {
  data: Array<FillInTheBlankOptionsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<FillInTheBlankOptionsOnConflict>;
};

/** aggregate avg on columns */
export type FillInTheBlankOptionsAvgFields = {
  __typename?: 'fill_in_the_blank_options_avg_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsAvgOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fill_in_the_blank_options". All fields are combined with a logical 'AND'. */
export type FillInTheBlankOptionsBoolExp = {
  _and?: InputMaybe<Array<FillInTheBlankOptionsBoolExp>>;
  _not?: InputMaybe<FillInTheBlankOptionsBoolExp>;
  _or?: InputMaybe<Array<FillInTheBlankOptionsBoolExp>>;
  created_by?: InputMaybe<IntComparisonExp>;
  fillInTheBlankId?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  option?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "fill_in_the_blank_options" */
export enum FillInTheBlankOptionsConstraint {
  /** unique or primary key constraint on columns "id" */
  FillInTheBlankOptionsPkey = 'fill_in_the_blank_options_pkey'
}

/** input type for incrementing numeric columns in table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsIncInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  fillInTheBlankId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsInsertInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  fillInTheBlankId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  option?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type FillInTheBlankOptionsMaxFields = {
  __typename?: 'fill_in_the_blank_options_max_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  option?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsMaxOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  option?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type FillInTheBlankOptionsMinFields = {
  __typename?: 'fill_in_the_blank_options_min_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  option?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsMinOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  option?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsMutationResponse = {
  __typename?: 'fill_in_the_blank_options_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<FillInTheBlankOptions>;
};

/** on_conflict condition type for table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsOnConflict = {
  constraint: FillInTheBlankOptionsConstraint;
  update_columns?: Array<FillInTheBlankOptionsUpdateColumn>;
  where?: InputMaybe<FillInTheBlankOptionsBoolExp>;
};

/** Ordering options when selecting data from "fill_in_the_blank_options". */
export type FillInTheBlankOptionsOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  option?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fill_in_the_blank_options */
export type FillInTheBlankOptionsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "fill_in_the_blank_options" */
export enum FillInTheBlankOptionsSelectColumn {
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  FillInTheBlankId = 'fillInTheBlankId',
  /** column name */
  Id = 'id',
  /** column name */
  Option = 'option'
}

/** input type for updating data in table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsSetInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  fillInTheBlankId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  option?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type FillInTheBlankOptionsStddevFields = {
  __typename?: 'fill_in_the_blank_options_stddev_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsStddevOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type FillInTheBlankOptionsStddevPopFields = {
  __typename?: 'fill_in_the_blank_options_stddev_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsStddevPopOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type FillInTheBlankOptionsStddevSampFields = {
  __typename?: 'fill_in_the_blank_options_stddev_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsStddevSampOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: FillInTheBlankOptionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FillInTheBlankOptionsStreamCursorValueInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  fillInTheBlankId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  option?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type FillInTheBlankOptionsSumFields = {
  __typename?: 'fill_in_the_blank_options_sum_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsSumOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** update columns of table "fill_in_the_blank_options" */
export enum FillInTheBlankOptionsUpdateColumn {
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  FillInTheBlankId = 'fillInTheBlankId',
  /** column name */
  Id = 'id',
  /** column name */
  Option = 'option'
}

export type FillInTheBlankOptionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FillInTheBlankOptionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FillInTheBlankOptionsSetInput>;
  /** filter the rows which have to be updated */
  where: FillInTheBlankOptionsBoolExp;
};

/** aggregate var_pop on columns */
export type FillInTheBlankOptionsVarPopFields = {
  __typename?: 'fill_in_the_blank_options_var_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsVarPopOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type FillInTheBlankOptionsVarSampFields = {
  __typename?: 'fill_in_the_blank_options_var_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsVarSampOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type FillInTheBlankOptionsVarianceFields = {
  __typename?: 'fill_in_the_blank_options_variance_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "fill_in_the_blank_options" */
export type FillInTheBlankOptionsVarianceOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "fill_in_the_blank_responses" */
export type FillInTheBlankResponses = {
  __typename?: 'fill_in_the_blank_responses';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  /** An object relationship */
  fillInTheBlank: FillInTheBlanks;
  fillInTheBlankId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isCorrect: Scalars['Boolean']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesAggregate = {
  __typename?: 'fill_in_the_blank_responses_aggregate';
  aggregate?: Maybe<FillInTheBlankResponsesAggregateFields>;
  nodes: Array<FillInTheBlankResponses>;
};

export type FillInTheBlankResponsesAggregateBoolExp = {
  bool_and?: InputMaybe<FillInTheBlankResponsesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<FillInTheBlankResponsesAggregateBoolExpBoolOr>;
  count?: InputMaybe<FillInTheBlankResponsesAggregateBoolExpCount>;
};

export type FillInTheBlankResponsesAggregateBoolExpBoolAnd = {
  arguments: FillInTheBlankResponsesSelectColumnFillInTheBlankResponsesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FillInTheBlankResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type FillInTheBlankResponsesAggregateBoolExpBoolOr = {
  arguments: FillInTheBlankResponsesSelectColumnFillInTheBlankResponsesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FillInTheBlankResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type FillInTheBlankResponsesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<FillInTheBlankResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FillInTheBlankResponsesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesAggregateFields = {
  __typename?: 'fill_in_the_blank_responses_aggregate_fields';
  avg?: Maybe<FillInTheBlankResponsesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<FillInTheBlankResponsesMaxFields>;
  min?: Maybe<FillInTheBlankResponsesMinFields>;
  stddev?: Maybe<FillInTheBlankResponsesStddevFields>;
  stddev_pop?: Maybe<FillInTheBlankResponsesStddevPopFields>;
  stddev_samp?: Maybe<FillInTheBlankResponsesStddevSampFields>;
  sum?: Maybe<FillInTheBlankResponsesSumFields>;
  var_pop?: Maybe<FillInTheBlankResponsesVarPopFields>;
  var_samp?: Maybe<FillInTheBlankResponsesVarSampFields>;
  variance?: Maybe<FillInTheBlankResponsesVarianceFields>;
};


/** aggregate fields of "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FillInTheBlankResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesAggregateOrderBy = {
  avg?: InputMaybe<FillInTheBlankResponsesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<FillInTheBlankResponsesMaxOrderBy>;
  min?: InputMaybe<FillInTheBlankResponsesMinOrderBy>;
  stddev?: InputMaybe<FillInTheBlankResponsesStddevOrderBy>;
  stddev_pop?: InputMaybe<FillInTheBlankResponsesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<FillInTheBlankResponsesStddevSampOrderBy>;
  sum?: InputMaybe<FillInTheBlankResponsesSumOrderBy>;
  var_pop?: InputMaybe<FillInTheBlankResponsesVarPopOrderBy>;
  var_samp?: InputMaybe<FillInTheBlankResponsesVarSampOrderBy>;
  variance?: InputMaybe<FillInTheBlankResponsesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesArrRelInsertInput = {
  data: Array<FillInTheBlankResponsesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<FillInTheBlankResponsesOnConflict>;
};

/** aggregate avg on columns */
export type FillInTheBlankResponsesAvgFields = {
  __typename?: 'fill_in_the_blank_responses_avg_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesAvgOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fill_in_the_blank_responses". All fields are combined with a logical 'AND'. */
export type FillInTheBlankResponsesBoolExp = {
  _and?: InputMaybe<Array<FillInTheBlankResponsesBoolExp>>;
  _not?: InputMaybe<FillInTheBlankResponsesBoolExp>;
  _or?: InputMaybe<Array<FillInTheBlankResponsesBoolExp>>;
  activitySetResponseId?: InputMaybe<IntComparisonExp>;
  answer?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  fillInTheBlank?: InputMaybe<FillInTheBlanksBoolExp>;
  fillInTheBlankId?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isCorrect?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "fill_in_the_blank_responses" */
export enum FillInTheBlankResponsesConstraint {
  /** unique or primary key constraint on columns "id" */
  FillInTheBlankResponsesPkey = 'fill_in_the_blank_responses_pkey'
}

/** input type for incrementing numeric columns in table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesIncInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  fillInTheBlankId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesInsertInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  fillInTheBlank?: InputMaybe<FillInTheBlanksObjRelInsertInput>;
  fillInTheBlankId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type FillInTheBlankResponsesMaxFields = {
  __typename?: 'fill_in_the_blank_responses_max_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesMaxOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type FillInTheBlankResponsesMinFields = {
  __typename?: 'fill_in_the_blank_responses_min_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesMinOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesMutationResponse = {
  __typename?: 'fill_in_the_blank_responses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<FillInTheBlankResponses>;
};

/** on_conflict condition type for table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesOnConflict = {
  constraint: FillInTheBlankResponsesConstraint;
  update_columns?: Array<FillInTheBlankResponsesUpdateColumn>;
  where?: InputMaybe<FillInTheBlankResponsesBoolExp>;
};

/** Ordering options when selecting data from "fill_in_the_blank_responses". */
export type FillInTheBlankResponsesOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlank?: InputMaybe<FillInTheBlanksOrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCorrect?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fill_in_the_blank_responses */
export type FillInTheBlankResponsesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "fill_in_the_blank_responses" */
export enum FillInTheBlankResponsesSelectColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  FillInTheBlankId = 'fillInTheBlankId',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "fill_in_the_blank_responses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "fill_in_the_blank_responses" */
export enum FillInTheBlankResponsesSelectColumnFillInTheBlankResponsesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** select "fill_in_the_blank_responses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "fill_in_the_blank_responses" */
export enum FillInTheBlankResponsesSelectColumnFillInTheBlankResponsesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** input type for updating data in table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesSetInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  fillInTheBlankId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type FillInTheBlankResponsesStddevFields = {
  __typename?: 'fill_in_the_blank_responses_stddev_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesStddevOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type FillInTheBlankResponsesStddevPopFields = {
  __typename?: 'fill_in_the_blank_responses_stddev_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesStddevPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type FillInTheBlankResponsesStddevSampFields = {
  __typename?: 'fill_in_the_blank_responses_stddev_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesStddevSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: FillInTheBlankResponsesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FillInTheBlankResponsesStreamCursorValueInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  fillInTheBlankId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type FillInTheBlankResponsesSumFields = {
  __typename?: 'fill_in_the_blank_responses_sum_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesSumOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** update columns of table "fill_in_the_blank_responses" */
export enum FillInTheBlankResponsesUpdateColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  FillInTheBlankId = 'fillInTheBlankId',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type FillInTheBlankResponsesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FillInTheBlankResponsesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FillInTheBlankResponsesSetInput>;
  /** filter the rows which have to be updated */
  where: FillInTheBlankResponsesBoolExp;
};

/** aggregate var_pop on columns */
export type FillInTheBlankResponsesVarPopFields = {
  __typename?: 'fill_in_the_blank_responses_var_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesVarPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type FillInTheBlankResponsesVarSampFields = {
  __typename?: 'fill_in_the_blank_responses_var_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesVarSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type FillInTheBlankResponsesVarianceFields = {
  __typename?: 'fill_in_the_blank_responses_variance_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  fillInTheBlankId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "fill_in_the_blank_responses" */
export type FillInTheBlankResponsesVarianceOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  fillInTheBlankId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "fill_in_the_blanks" */
export type FillInTheBlanks = {
  __typename?: 'fill_in_the_blanks';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  audioUrl?: Maybe<Scalars['String']['output']>;
  baseSentence: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  explanation?: Maybe<Scalars['String']['output']>;
  hint: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  omission: Scalars['String']['output'];
  /** An array relationship */
  options: Array<FillInTheBlankOptions>;
  /** An aggregate relationship */
  options_aggregate: FillInTheBlankOptionsAggregate;
  order: Scalars['Int']['output'];
  translation?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "fill_in_the_blanks" */
export type FillInTheBlanksOptionsArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankOptionsOrderBy>>;
  where?: InputMaybe<FillInTheBlankOptionsBoolExp>;
};


/** columns and relationships of "fill_in_the_blanks" */
export type FillInTheBlanksOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankOptionsOrderBy>>;
  where?: InputMaybe<FillInTheBlankOptionsBoolExp>;
};

/** aggregated selection of "fill_in_the_blanks" */
export type FillInTheBlanksAggregate = {
  __typename?: 'fill_in_the_blanks_aggregate';
  aggregate?: Maybe<FillInTheBlanksAggregateFields>;
  nodes: Array<FillInTheBlanks>;
};

export type FillInTheBlanksAggregateBoolExp = {
  count?: InputMaybe<FillInTheBlanksAggregateBoolExpCount>;
};

export type FillInTheBlanksAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<FillInTheBlanksSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FillInTheBlanksBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "fill_in_the_blanks" */
export type FillInTheBlanksAggregateFields = {
  __typename?: 'fill_in_the_blanks_aggregate_fields';
  avg?: Maybe<FillInTheBlanksAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<FillInTheBlanksMaxFields>;
  min?: Maybe<FillInTheBlanksMinFields>;
  stddev?: Maybe<FillInTheBlanksStddevFields>;
  stddev_pop?: Maybe<FillInTheBlanksStddevPopFields>;
  stddev_samp?: Maybe<FillInTheBlanksStddevSampFields>;
  sum?: Maybe<FillInTheBlanksSumFields>;
  var_pop?: Maybe<FillInTheBlanksVarPopFields>;
  var_samp?: Maybe<FillInTheBlanksVarSampFields>;
  variance?: Maybe<FillInTheBlanksVarianceFields>;
};


/** aggregate fields of "fill_in_the_blanks" */
export type FillInTheBlanksAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FillInTheBlanksSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "fill_in_the_blanks" */
export type FillInTheBlanksAggregateOrderBy = {
  avg?: InputMaybe<FillInTheBlanksAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<FillInTheBlanksMaxOrderBy>;
  min?: InputMaybe<FillInTheBlanksMinOrderBy>;
  stddev?: InputMaybe<FillInTheBlanksStddevOrderBy>;
  stddev_pop?: InputMaybe<FillInTheBlanksStddevPopOrderBy>;
  stddev_samp?: InputMaybe<FillInTheBlanksStddevSampOrderBy>;
  sum?: InputMaybe<FillInTheBlanksSumOrderBy>;
  var_pop?: InputMaybe<FillInTheBlanksVarPopOrderBy>;
  var_samp?: InputMaybe<FillInTheBlanksVarSampOrderBy>;
  variance?: InputMaybe<FillInTheBlanksVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fill_in_the_blanks" */
export type FillInTheBlanksArrRelInsertInput = {
  data: Array<FillInTheBlanksInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<FillInTheBlanksOnConflict>;
};

/** aggregate avg on columns */
export type FillInTheBlanksAvgFields = {
  __typename?: 'fill_in_the_blanks_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fill_in_the_blanks". All fields are combined with a logical 'AND'. */
export type FillInTheBlanksBoolExp = {
  _and?: InputMaybe<Array<FillInTheBlanksBoolExp>>;
  _not?: InputMaybe<FillInTheBlanksBoolExp>;
  _or?: InputMaybe<Array<FillInTheBlanksBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  audioUrl?: InputMaybe<StringComparisonExp>;
  baseSentence?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  explanation?: InputMaybe<StringComparisonExp>;
  hint?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  omission?: InputMaybe<StringComparisonExp>;
  options?: InputMaybe<FillInTheBlankOptionsBoolExp>;
  options_aggregate?: InputMaybe<FillInTheBlankOptionsAggregateBoolExp>;
  order?: InputMaybe<IntComparisonExp>;
  translation?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "fill_in_the_blanks" */
export enum FillInTheBlanksConstraint {
  /** unique or primary key constraint on columns "id" */
  FillInTheBlanksPkey = 'fill_in_the_blanks_pkey'
}

/** input type for incrementing numeric columns in table "fill_in_the_blanks" */
export type FillInTheBlanksIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "fill_in_the_blanks" */
export type FillInTheBlanksInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  baseSentence?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  explanation?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  omission?: InputMaybe<Scalars['String']['input']>;
  options?: InputMaybe<FillInTheBlankOptionsArrRelInsertInput>;
  order?: InputMaybe<Scalars['Int']['input']>;
  translation?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type FillInTheBlanksMaxFields = {
  __typename?: 'fill_in_the_blanks_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  audioUrl?: Maybe<Scalars['String']['output']>;
  baseSentence?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  explanation?: Maybe<Scalars['String']['output']>;
  hint?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omission?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  translation?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audioUrl?: InputMaybe<OrderBy>;
  baseSentence?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  explanation?: InputMaybe<OrderBy>;
  hint?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  omission?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translation?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type FillInTheBlanksMinFields = {
  __typename?: 'fill_in_the_blanks_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  audioUrl?: Maybe<Scalars['String']['output']>;
  baseSentence?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  explanation?: Maybe<Scalars['String']['output']>;
  hint?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omission?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  translation?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audioUrl?: InputMaybe<OrderBy>;
  baseSentence?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  explanation?: InputMaybe<OrderBy>;
  hint?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  omission?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translation?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fill_in_the_blanks" */
export type FillInTheBlanksMutationResponse = {
  __typename?: 'fill_in_the_blanks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<FillInTheBlanks>;
};

/** input type for inserting object relation for remote table "fill_in_the_blanks" */
export type FillInTheBlanksObjRelInsertInput = {
  data: FillInTheBlanksInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<FillInTheBlanksOnConflict>;
};

/** on_conflict condition type for table "fill_in_the_blanks" */
export type FillInTheBlanksOnConflict = {
  constraint: FillInTheBlanksConstraint;
  update_columns?: Array<FillInTheBlanksUpdateColumn>;
  where?: InputMaybe<FillInTheBlanksBoolExp>;
};

/** Ordering options when selecting data from "fill_in_the_blanks". */
export type FillInTheBlanksOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audioUrl?: InputMaybe<OrderBy>;
  baseSentence?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  explanation?: InputMaybe<OrderBy>;
  hint?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  omission?: InputMaybe<OrderBy>;
  options_aggregate?: InputMaybe<FillInTheBlankOptionsAggregateOrderBy>;
  order?: InputMaybe<OrderBy>;
  translation?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fill_in_the_blanks */
export type FillInTheBlanksPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "fill_in_the_blanks" */
export enum FillInTheBlanksSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  AudioUrl = 'audioUrl',
  /** column name */
  BaseSentence = 'baseSentence',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Explanation = 'explanation',
  /** column name */
  Hint = 'hint',
  /** column name */
  Id = 'id',
  /** column name */
  Omission = 'omission',
  /** column name */
  Order = 'order',
  /** column name */
  Translation = 'translation',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "fill_in_the_blanks" */
export type FillInTheBlanksSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  baseSentence?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  explanation?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  omission?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  translation?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type FillInTheBlanksStddevFields = {
  __typename?: 'fill_in_the_blanks_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type FillInTheBlanksStddevPopFields = {
  __typename?: 'fill_in_the_blanks_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type FillInTheBlanksStddevSampFields = {
  __typename?: 'fill_in_the_blanks_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fill_in_the_blanks" */
export type FillInTheBlanksStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: FillInTheBlanksStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FillInTheBlanksStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  baseSentence?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  explanation?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  omission?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  translation?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type FillInTheBlanksSumFields = {
  __typename?: 'fill_in_the_blanks_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** update columns of table "fill_in_the_blanks" */
export enum FillInTheBlanksUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  AudioUrl = 'audioUrl',
  /** column name */
  BaseSentence = 'baseSentence',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Explanation = 'explanation',
  /** column name */
  Hint = 'hint',
  /** column name */
  Id = 'id',
  /** column name */
  Omission = 'omission',
  /** column name */
  Order = 'order',
  /** column name */
  Translation = 'translation',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type FillInTheBlanksUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FillInTheBlanksIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FillInTheBlanksSetInput>;
  /** filter the rows which have to be updated */
  where: FillInTheBlanksBoolExp;
};

/** aggregate var_pop on columns */
export type FillInTheBlanksVarPopFields = {
  __typename?: 'fill_in_the_blanks_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type FillInTheBlanksVarSampFields = {
  __typename?: 'fill_in_the_blanks_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type FillInTheBlanksVarianceFields = {
  __typename?: 'fill_in_the_blanks_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "fill_in_the_blanks" */
export type FillInTheBlanksVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8ComparisonExp = {
  _eq?: InputMaybe<Scalars['float8']['input']>;
  _gt?: InputMaybe<Scalars['float8']['input']>;
  _gte?: InputMaybe<Scalars['float8']['input']>;
  _in?: InputMaybe<Array<Scalars['float8']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['float8']['input']>;
  _lte?: InputMaybe<Scalars['float8']['input']>;
  _neq?: InputMaybe<Scalars['float8']['input']>;
  _nin?: InputMaybe<Array<Scalars['float8']['input']>>;
};

/** columns and relationships of "game_dailies" */
export type GameDailies = {
  __typename?: 'game_dailies';
  date: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  languageCode: Scalars['String']['output'];
  scramble?: Maybe<Scalars['jsonb']['output']>;
  synonym?: Maybe<Scalars['jsonb']['output']>;
  wordit?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "game_dailies" */
export type GameDailiesScrambleArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "game_dailies" */
export type GameDailiesSynonymArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "game_dailies" */
export type GameDailiesAggregate = {
  __typename?: 'game_dailies_aggregate';
  aggregate?: Maybe<GameDailiesAggregateFields>;
  nodes: Array<GameDailies>;
};

/** aggregate fields of "game_dailies" */
export type GameDailiesAggregateFields = {
  __typename?: 'game_dailies_aggregate_fields';
  avg?: Maybe<GameDailiesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<GameDailiesMaxFields>;
  min?: Maybe<GameDailiesMinFields>;
  stddev?: Maybe<GameDailiesStddevFields>;
  stddev_pop?: Maybe<GameDailiesStddevPopFields>;
  stddev_samp?: Maybe<GameDailiesStddevSampFields>;
  sum?: Maybe<GameDailiesSumFields>;
  var_pop?: Maybe<GameDailiesVarPopFields>;
  var_samp?: Maybe<GameDailiesVarSampFields>;
  variance?: Maybe<GameDailiesVarianceFields>;
};


/** aggregate fields of "game_dailies" */
export type GameDailiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GameDailiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type GameDailiesAppendInput = {
  scramble?: InputMaybe<Scalars['jsonb']['input']>;
  synonym?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type GameDailiesAvgFields = {
  __typename?: 'game_dailies_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "game_dailies". All fields are combined with a logical 'AND'. */
export type GameDailiesBoolExp = {
  _and?: InputMaybe<Array<GameDailiesBoolExp>>;
  _not?: InputMaybe<GameDailiesBoolExp>;
  _or?: InputMaybe<Array<GameDailiesBoolExp>>;
  date?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  languageCode?: InputMaybe<StringComparisonExp>;
  scramble?: InputMaybe<JsonbComparisonExp>;
  synonym?: InputMaybe<JsonbComparisonExp>;
  wordit?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "game_dailies" */
export enum GameDailiesConstraint {
  /** unique or primary key constraint on columns "id" */
  GameDailiesPkey = 'game_dailies_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type GameDailiesDeleteAtPathInput = {
  scramble?: InputMaybe<Array<Scalars['String']['input']>>;
  synonym?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type GameDailiesDeleteElemInput = {
  scramble?: InputMaybe<Scalars['Int']['input']>;
  synonym?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type GameDailiesDeleteKeyInput = {
  scramble?: InputMaybe<Scalars['String']['input']>;
  synonym?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "game_dailies" */
export type GameDailiesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "game_dailies" */
export type GameDailiesInsertInput = {
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageCode?: InputMaybe<Scalars['String']['input']>;
  scramble?: InputMaybe<Scalars['jsonb']['input']>;
  synonym?: InputMaybe<Scalars['jsonb']['input']>;
  wordit?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type GameDailiesMaxFields = {
  __typename?: 'game_dailies_max_fields';
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageCode?: Maybe<Scalars['String']['output']>;
  wordit?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type GameDailiesMinFields = {
  __typename?: 'game_dailies_min_fields';
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageCode?: Maybe<Scalars['String']['output']>;
  wordit?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "game_dailies" */
export type GameDailiesMutationResponse = {
  __typename?: 'game_dailies_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<GameDailies>;
};

/** on_conflict condition type for table "game_dailies" */
export type GameDailiesOnConflict = {
  constraint: GameDailiesConstraint;
  update_columns?: Array<GameDailiesUpdateColumn>;
  where?: InputMaybe<GameDailiesBoolExp>;
};

/** Ordering options when selecting data from "game_dailies". */
export type GameDailiesOrderBy = {
  date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  languageCode?: InputMaybe<OrderBy>;
  scramble?: InputMaybe<OrderBy>;
  synonym?: InputMaybe<OrderBy>;
  wordit?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: game_dailies */
export type GameDailiesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type GameDailiesPrependInput = {
  scramble?: InputMaybe<Scalars['jsonb']['input']>;
  synonym?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "game_dailies" */
export enum GameDailiesSelectColumn {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  Scramble = 'scramble',
  /** column name */
  Synonym = 'synonym',
  /** column name */
  Wordit = 'wordit'
}

/** input type for updating data in table "game_dailies" */
export type GameDailiesSetInput = {
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageCode?: InputMaybe<Scalars['String']['input']>;
  scramble?: InputMaybe<Scalars['jsonb']['input']>;
  synonym?: InputMaybe<Scalars['jsonb']['input']>;
  wordit?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type GameDailiesStddevFields = {
  __typename?: 'game_dailies_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type GameDailiesStddevPopFields = {
  __typename?: 'game_dailies_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type GameDailiesStddevSampFields = {
  __typename?: 'game_dailies_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "game_dailies" */
export type GameDailiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: GameDailiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GameDailiesStreamCursorValueInput = {
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageCode?: InputMaybe<Scalars['String']['input']>;
  scramble?: InputMaybe<Scalars['jsonb']['input']>;
  synonym?: InputMaybe<Scalars['jsonb']['input']>;
  wordit?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type GameDailiesSumFields = {
  __typename?: 'game_dailies_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "game_dailies" */
export enum GameDailiesUpdateColumn {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  Scramble = 'scramble',
  /** column name */
  Synonym = 'synonym',
  /** column name */
  Wordit = 'wordit'
}

export type GameDailiesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<GameDailiesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<GameDailiesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<GameDailiesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<GameDailiesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<GameDailiesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<GameDailiesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GameDailiesSetInput>;
  /** filter the rows which have to be updated */
  where: GameDailiesBoolExp;
};

/** aggregate var_pop on columns */
export type GameDailiesVarPopFields = {
  __typename?: 'game_dailies_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type GameDailiesVarSampFields = {
  __typename?: 'game_dailies_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type GameDailiesVarianceFields = {
  __typename?: 'game_dailies_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "game_difficulty" */
export type GameDifficulty = {
  __typename?: 'game_difficulty';
  value: Scalars['String']['output'];
};

/** aggregated selection of "game_difficulty" */
export type GameDifficultyAggregate = {
  __typename?: 'game_difficulty_aggregate';
  aggregate?: Maybe<GameDifficultyAggregateFields>;
  nodes: Array<GameDifficulty>;
};

/** aggregate fields of "game_difficulty" */
export type GameDifficultyAggregateFields = {
  __typename?: 'game_difficulty_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<GameDifficultyMaxFields>;
  min?: Maybe<GameDifficultyMinFields>;
};


/** aggregate fields of "game_difficulty" */
export type GameDifficultyAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GameDifficultySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "game_difficulty". All fields are combined with a logical 'AND'. */
export type GameDifficultyBoolExp = {
  _and?: InputMaybe<Array<GameDifficultyBoolExp>>;
  _not?: InputMaybe<GameDifficultyBoolExp>;
  _or?: InputMaybe<Array<GameDifficultyBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "game_difficulty" */
export enum GameDifficultyConstraint {
  /** unique or primary key constraint on columns "value" */
  GameDifficultyPkey = 'game_difficulty_pkey'
}

export enum GameDifficultyEnum {
  Easy = 'EASY',
  Hard = 'HARD',
  Medium = 'MEDIUM'
}

/** Boolean expression to compare columns of type "game_difficulty_enum". All fields are combined with logical 'AND'. */
export type GameDifficultyEnumComparisonExp = {
  _eq?: InputMaybe<GameDifficultyEnum>;
  _in?: InputMaybe<Array<GameDifficultyEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<GameDifficultyEnum>;
  _nin?: InputMaybe<Array<GameDifficultyEnum>>;
};

/** input type for inserting data into table "game_difficulty" */
export type GameDifficultyInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type GameDifficultyMaxFields = {
  __typename?: 'game_difficulty_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type GameDifficultyMinFields = {
  __typename?: 'game_difficulty_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "game_difficulty" */
export type GameDifficultyMutationResponse = {
  __typename?: 'game_difficulty_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<GameDifficulty>;
};

/** on_conflict condition type for table "game_difficulty" */
export type GameDifficultyOnConflict = {
  constraint: GameDifficultyConstraint;
  update_columns?: Array<GameDifficultyUpdateColumn>;
  where?: InputMaybe<GameDifficultyBoolExp>;
};

/** Ordering options when selecting data from "game_difficulty". */
export type GameDifficultyOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: game_difficulty */
export type GameDifficultyPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "game_difficulty" */
export enum GameDifficultySelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "game_difficulty" */
export type GameDifficultySetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "game_difficulty" */
export type GameDifficultyStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: GameDifficultyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GameDifficultyStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "game_difficulty" */
export enum GameDifficultyUpdateColumn {
  /** column name */
  Value = 'value'
}

export type GameDifficultyUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GameDifficultySetInput>;
  /** filter the rows which have to be updated */
  where: GameDifficultyBoolExp;
};

/** columns and relationships of "game_types" */
export type GameTypes = {
  __typename?: 'game_types';
  value: Scalars['String']['output'];
};

/** aggregated selection of "game_types" */
export type GameTypesAggregate = {
  __typename?: 'game_types_aggregate';
  aggregate?: Maybe<GameTypesAggregateFields>;
  nodes: Array<GameTypes>;
};

/** aggregate fields of "game_types" */
export type GameTypesAggregateFields = {
  __typename?: 'game_types_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<GameTypesMaxFields>;
  min?: Maybe<GameTypesMinFields>;
};


/** aggregate fields of "game_types" */
export type GameTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GameTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "game_types". All fields are combined with a logical 'AND'. */
export type GameTypesBoolExp = {
  _and?: InputMaybe<Array<GameTypesBoolExp>>;
  _not?: InputMaybe<GameTypesBoolExp>;
  _or?: InputMaybe<Array<GameTypesBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "game_types" */
export enum GameTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  GameTypesPkey = 'game_types_pkey'
}

export enum GameTypesEnum {
  ActivitySet = 'ACTIVITY_SET',
  GridONym = 'GRID_O_NYM',
  Irregular = 'IRREGULAR',
  Poems = 'POEMS',
  Question = 'QUESTION',
  Scramble = 'SCRAMBLE',
  Spelling = 'SPELLING',
  Wordit = 'WORDIT'
}

/** Boolean expression to compare columns of type "game_types_enum". All fields are combined with logical 'AND'. */
export type GameTypesEnumComparisonExp = {
  _eq?: InputMaybe<GameTypesEnum>;
  _in?: InputMaybe<Array<GameTypesEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<GameTypesEnum>;
  _nin?: InputMaybe<Array<GameTypesEnum>>;
};

/** input type for inserting data into table "game_types" */
export type GameTypesInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type GameTypesMaxFields = {
  __typename?: 'game_types_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type GameTypesMinFields = {
  __typename?: 'game_types_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "game_types" */
export type GameTypesMutationResponse = {
  __typename?: 'game_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<GameTypes>;
};

/** on_conflict condition type for table "game_types" */
export type GameTypesOnConflict = {
  constraint: GameTypesConstraint;
  update_columns?: Array<GameTypesUpdateColumn>;
  where?: InputMaybe<GameTypesBoolExp>;
};

/** Ordering options when selecting data from "game_types". */
export type GameTypesOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: game_types */
export type GameTypesPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "game_types" */
export enum GameTypesSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "game_types" */
export type GameTypesSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "game_types" */
export type GameTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: GameTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GameTypesStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "game_types" */
export enum GameTypesUpdateColumn {
  /** column name */
  Value = 'value'
}

export type GameTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GameTypesSetInput>;
  /** filter the rows which have to be updated */
  where: GameTypesBoolExp;
};

/** columns and relationships of "game_users" */
export type GameUsers = {
  __typename?: 'game_users';
  activityAnswers?: Maybe<Scalars['jsonb']['output']>;
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  attack: Scalars['Int']['output'];
  avatar?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  game: Games;
  gameId: Scalars['Int']['output'];
  /** An object relationship */
  gameQuestioner?: Maybe<GameUsers>;
  gameUserQuestionerId?: Maybe<Scalars['Int']['output']>;
  health: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isBot: Scalars['Boolean']['output'];
  isChallenged?: Maybe<Scalars['Boolean']['output']>;
  isReady?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  position?: Maybe<Scalars['Int']['output']>;
  question?: Maybe<Scalars['String']['output']>;
  questionCorrection?: Maybe<Scalars['String']['output']>;
  response?: Maybe<Scalars['String']['output']>;
  score: Scalars['Int']['output'];
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  team?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "game_users" */
export type GameUsersActivityAnswersArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "game_users" */
export type GameUsersAggregate = {
  __typename?: 'game_users_aggregate';
  aggregate?: Maybe<GameUsersAggregateFields>;
  nodes: Array<GameUsers>;
};

export type GameUsersAggregateBoolExp = {
  bool_and?: InputMaybe<GameUsersAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<GameUsersAggregateBoolExpBoolOr>;
  count?: InputMaybe<GameUsersAggregateBoolExpCount>;
};

export type GameUsersAggregateBoolExpBoolAnd = {
  arguments: GameUsersSelectColumnGameUsersAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<GameUsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GameUsersAggregateBoolExpBoolOr = {
  arguments: GameUsersSelectColumnGameUsersAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<GameUsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type GameUsersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<GameUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<GameUsersBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "game_users" */
export type GameUsersAggregateFields = {
  __typename?: 'game_users_aggregate_fields';
  avg?: Maybe<GameUsersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<GameUsersMaxFields>;
  min?: Maybe<GameUsersMinFields>;
  stddev?: Maybe<GameUsersStddevFields>;
  stddev_pop?: Maybe<GameUsersStddevPopFields>;
  stddev_samp?: Maybe<GameUsersStddevSampFields>;
  sum?: Maybe<GameUsersSumFields>;
  var_pop?: Maybe<GameUsersVarPopFields>;
  var_samp?: Maybe<GameUsersVarSampFields>;
  variance?: Maybe<GameUsersVarianceFields>;
};


/** aggregate fields of "game_users" */
export type GameUsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GameUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "game_users" */
export type GameUsersAggregateOrderBy = {
  avg?: InputMaybe<GameUsersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<GameUsersMaxOrderBy>;
  min?: InputMaybe<GameUsersMinOrderBy>;
  stddev?: InputMaybe<GameUsersStddevOrderBy>;
  stddev_pop?: InputMaybe<GameUsersStddevPopOrderBy>;
  stddev_samp?: InputMaybe<GameUsersStddevSampOrderBy>;
  sum?: InputMaybe<GameUsersSumOrderBy>;
  var_pop?: InputMaybe<GameUsersVarPopOrderBy>;
  var_samp?: InputMaybe<GameUsersVarSampOrderBy>;
  variance?: InputMaybe<GameUsersVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type GameUsersAppendInput = {
  activityAnswers?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "game_users" */
export type GameUsersArrRelInsertInput = {
  data: Array<GameUsersInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<GameUsersOnConflict>;
};

/** aggregate avg on columns */
export type GameUsersAvgFields = {
  __typename?: 'game_users_avg_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  attack?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "game_users" */
export type GameUsersAvgOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "game_users". All fields are combined with a logical 'AND'. */
export type GameUsersBoolExp = {
  _and?: InputMaybe<Array<GameUsersBoolExp>>;
  _not?: InputMaybe<GameUsersBoolExp>;
  _or?: InputMaybe<Array<GameUsersBoolExp>>;
  activityAnswers?: InputMaybe<JsonbComparisonExp>;
  activitySetResponseId?: InputMaybe<IntComparisonExp>;
  attack?: InputMaybe<IntComparisonExp>;
  avatar?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  endedAt?: InputMaybe<TimestamptzComparisonExp>;
  game?: InputMaybe<GamesBoolExp>;
  gameId?: InputMaybe<IntComparisonExp>;
  gameQuestioner?: InputMaybe<GameUsersBoolExp>;
  gameUserQuestionerId?: InputMaybe<IntComparisonExp>;
  health?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isBot?: InputMaybe<BooleanComparisonExp>;
  isChallenged?: InputMaybe<BooleanComparisonExp>;
  isReady?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  position?: InputMaybe<IntComparisonExp>;
  question?: InputMaybe<StringComparisonExp>;
  questionCorrection?: InputMaybe<StringComparisonExp>;
  response?: InputMaybe<StringComparisonExp>;
  score?: InputMaybe<IntComparisonExp>;
  startedAt?: InputMaybe<TimestamptzComparisonExp>;
  team?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "game_users" */
export enum GameUsersConstraint {
  /** unique or primary key constraint on columns "id" */
  GameUsersPkey = 'game_users_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type GameUsersDeleteAtPathInput = {
  activityAnswers?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type GameUsersDeleteElemInput = {
  activityAnswers?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type GameUsersDeleteKeyInput = {
  activityAnswers?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "game_users" */
export type GameUsersIncInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  attack?: InputMaybe<Scalars['Int']['input']>;
  gameId?: InputMaybe<Scalars['Int']['input']>;
  gameUserQuestionerId?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "game_users" */
export type GameUsersInsertInput = {
  activityAnswers?: InputMaybe<Scalars['jsonb']['input']>;
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  attack?: InputMaybe<Scalars['Int']['input']>;
  avatar?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  game?: InputMaybe<GamesObjRelInsertInput>;
  gameId?: InputMaybe<Scalars['Int']['input']>;
  gameQuestioner?: InputMaybe<GameUsersObjRelInsertInput>;
  gameUserQuestionerId?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isBot?: InputMaybe<Scalars['Boolean']['input']>;
  isChallenged?: InputMaybe<Scalars['Boolean']['input']>;
  isReady?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<Scalars['String']['input']>;
  questionCorrection?: InputMaybe<Scalars['String']['input']>;
  response?: InputMaybe<Scalars['String']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type GameUsersMaxFields = {
  __typename?: 'game_users_max_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  attack?: Maybe<Scalars['Int']['output']>;
  avatar?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  gameId?: Maybe<Scalars['Int']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  question?: Maybe<Scalars['String']['output']>;
  questionCorrection?: Maybe<Scalars['String']['output']>;
  response?: Maybe<Scalars['String']['output']>;
  score?: Maybe<Scalars['Int']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  team?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "game_users" */
export type GameUsersMaxOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  avatar?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  endedAt?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  questionCorrection?: InputMaybe<OrderBy>;
  response?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  startedAt?: InputMaybe<OrderBy>;
  team?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type GameUsersMinFields = {
  __typename?: 'game_users_min_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  attack?: Maybe<Scalars['Int']['output']>;
  avatar?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  gameId?: Maybe<Scalars['Int']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  question?: Maybe<Scalars['String']['output']>;
  questionCorrection?: Maybe<Scalars['String']['output']>;
  response?: Maybe<Scalars['String']['output']>;
  score?: Maybe<Scalars['Int']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  team?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "game_users" */
export type GameUsersMinOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  avatar?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  endedAt?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  questionCorrection?: InputMaybe<OrderBy>;
  response?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  startedAt?: InputMaybe<OrderBy>;
  team?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "game_users" */
export type GameUsersMutationResponse = {
  __typename?: 'game_users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<GameUsers>;
};

/** input type for inserting object relation for remote table "game_users" */
export type GameUsersObjRelInsertInput = {
  data: GameUsersInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<GameUsersOnConflict>;
};

/** on_conflict condition type for table "game_users" */
export type GameUsersOnConflict = {
  constraint: GameUsersConstraint;
  update_columns?: Array<GameUsersUpdateColumn>;
  where?: InputMaybe<GameUsersBoolExp>;
};

/** Ordering options when selecting data from "game_users". */
export type GameUsersOrderBy = {
  activityAnswers?: InputMaybe<OrderBy>;
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  avatar?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  endedAt?: InputMaybe<OrderBy>;
  game?: InputMaybe<GamesOrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameQuestioner?: InputMaybe<GameUsersOrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isBot?: InputMaybe<OrderBy>;
  isChallenged?: InputMaybe<OrderBy>;
  isReady?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  question?: InputMaybe<OrderBy>;
  questionCorrection?: InputMaybe<OrderBy>;
  response?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  startedAt?: InputMaybe<OrderBy>;
  team?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: game_users */
export type GameUsersPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type GameUsersPrependInput = {
  activityAnswers?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "game_users" */
export enum GameUsersSelectColumn {
  /** column name */
  ActivityAnswers = 'activityAnswers',
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Attack = 'attack',
  /** column name */
  Avatar = 'avatar',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndedAt = 'endedAt',
  /** column name */
  GameId = 'gameId',
  /** column name */
  GameUserQuestionerId = 'gameUserQuestionerId',
  /** column name */
  Health = 'health',
  /** column name */
  Id = 'id',
  /** column name */
  IsBot = 'isBot',
  /** column name */
  IsChallenged = 'isChallenged',
  /** column name */
  IsReady = 'isReady',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  Question = 'question',
  /** column name */
  QuestionCorrection = 'questionCorrection',
  /** column name */
  Response = 'response',
  /** column name */
  Score = 'score',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  Team = 'team',
  /** column name */
  UserId = 'userId'
}

/** select "game_users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "game_users" */
export enum GameUsersSelectColumnGameUsersAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsBot = 'isBot',
  /** column name */
  IsChallenged = 'isChallenged',
  /** column name */
  IsReady = 'isReady'
}

/** select "game_users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "game_users" */
export enum GameUsersSelectColumnGameUsersAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsBot = 'isBot',
  /** column name */
  IsChallenged = 'isChallenged',
  /** column name */
  IsReady = 'isReady'
}

/** input type for updating data in table "game_users" */
export type GameUsersSetInput = {
  activityAnswers?: InputMaybe<Scalars['jsonb']['input']>;
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  attack?: InputMaybe<Scalars['Int']['input']>;
  avatar?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  gameId?: InputMaybe<Scalars['Int']['input']>;
  gameUserQuestionerId?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isBot?: InputMaybe<Scalars['Boolean']['input']>;
  isChallenged?: InputMaybe<Scalars['Boolean']['input']>;
  isReady?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<Scalars['String']['input']>;
  questionCorrection?: InputMaybe<Scalars['String']['input']>;
  response?: InputMaybe<Scalars['String']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type GameUsersStddevFields = {
  __typename?: 'game_users_stddev_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  attack?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "game_users" */
export type GameUsersStddevOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type GameUsersStddevPopFields = {
  __typename?: 'game_users_stddev_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  attack?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "game_users" */
export type GameUsersStddevPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type GameUsersStddevSampFields = {
  __typename?: 'game_users_stddev_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  attack?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "game_users" */
export type GameUsersStddevSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "game_users" */
export type GameUsersStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: GameUsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GameUsersStreamCursorValueInput = {
  activityAnswers?: InputMaybe<Scalars['jsonb']['input']>;
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  attack?: InputMaybe<Scalars['Int']['input']>;
  avatar?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  gameId?: InputMaybe<Scalars['Int']['input']>;
  gameUserQuestionerId?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isBot?: InputMaybe<Scalars['Boolean']['input']>;
  isChallenged?: InputMaybe<Scalars['Boolean']['input']>;
  isReady?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  question?: InputMaybe<Scalars['String']['input']>;
  questionCorrection?: InputMaybe<Scalars['String']['input']>;
  response?: InputMaybe<Scalars['String']['input']>;
  score?: InputMaybe<Scalars['Int']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type GameUsersSumFields = {
  __typename?: 'game_users_sum_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  attack?: Maybe<Scalars['Int']['output']>;
  gameId?: Maybe<Scalars['Int']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  score?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "game_users" */
export type GameUsersSumOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** update columns of table "game_users" */
export enum GameUsersUpdateColumn {
  /** column name */
  ActivityAnswers = 'activityAnswers',
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Attack = 'attack',
  /** column name */
  Avatar = 'avatar',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndedAt = 'endedAt',
  /** column name */
  GameId = 'gameId',
  /** column name */
  GameUserQuestionerId = 'gameUserQuestionerId',
  /** column name */
  Health = 'health',
  /** column name */
  Id = 'id',
  /** column name */
  IsBot = 'isBot',
  /** column name */
  IsChallenged = 'isChallenged',
  /** column name */
  IsReady = 'isReady',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  Question = 'question',
  /** column name */
  QuestionCorrection = 'questionCorrection',
  /** column name */
  Response = 'response',
  /** column name */
  Score = 'score',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  Team = 'team',
  /** column name */
  UserId = 'userId'
}

export type GameUsersUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<GameUsersAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<GameUsersDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<GameUsersDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<GameUsersDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<GameUsersIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<GameUsersPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GameUsersSetInput>;
  /** filter the rows which have to be updated */
  where: GameUsersBoolExp;
};

/** aggregate var_pop on columns */
export type GameUsersVarPopFields = {
  __typename?: 'game_users_var_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  attack?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "game_users" */
export type GameUsersVarPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type GameUsersVarSampFields = {
  __typename?: 'game_users_var_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  attack?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "game_users" */
export type GameUsersVarSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type GameUsersVarianceFields = {
  __typename?: 'game_users_variance_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  attack?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  gameUserQuestionerId?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "game_users" */
export type GameUsersVarianceOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  attack?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  gameUserQuestionerId?: InputMaybe<OrderBy>;
  health?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  score?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "games" */
export type Games = {
  __typename?: 'games';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  currentTurn?: Maybe<Scalars['Int']['output']>;
  data?: Maybe<Scalars['jsonb']['output']>;
  difficulty?: Maybe<GameDifficultyEnum>;
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  gameUsers: Array<GameUsers>;
  /** An aggregate relationship */
  gameUsers_aggregate: GameUsersAggregate;
  goalWord?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  languageCode?: Maybe<Scalars['String']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  poemId?: Maybe<Scalars['Int']['output']>;
  roomId: Scalars['String']['output'];
  scrambleWord?: Maybe<Scalars['jsonb']['output']>;
  seconds?: Maybe<Scalars['Int']['output']>;
  spellingWord?: Maybe<Scalars['String']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  status: Scalars['String']['output'];
  teamMode?: Maybe<Scalars['String']['output']>;
  turns?: Maybe<Scalars['jsonb']['output']>;
  type: GameTypesEnum;
  wordit?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "games" */
export type GamesDataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "games" */
export type GamesGameUsersArgs = {
  distinct_on?: InputMaybe<Array<GameUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameUsersOrderBy>>;
  where?: InputMaybe<GameUsersBoolExp>;
};


/** columns and relationships of "games" */
export type GamesGameUsersAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameUsersOrderBy>>;
  where?: InputMaybe<GameUsersBoolExp>;
};


/** columns and relationships of "games" */
export type GamesScrambleWordArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "games" */
export type GamesTurnsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "games" */
export type GamesAggregate = {
  __typename?: 'games_aggregate';
  aggregate?: Maybe<GamesAggregateFields>;
  nodes: Array<Games>;
};

/** aggregate fields of "games" */
export type GamesAggregateFields = {
  __typename?: 'games_aggregate_fields';
  avg?: Maybe<GamesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<GamesMaxFields>;
  min?: Maybe<GamesMinFields>;
  stddev?: Maybe<GamesStddevFields>;
  stddev_pop?: Maybe<GamesStddevPopFields>;
  stddev_samp?: Maybe<GamesStddevSampFields>;
  sum?: Maybe<GamesSumFields>;
  var_pop?: Maybe<GamesVarPopFields>;
  var_samp?: Maybe<GamesVarSampFields>;
  variance?: Maybe<GamesVarianceFields>;
};


/** aggregate fields of "games" */
export type GamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type GamesAppendInput = {
  data?: InputMaybe<Scalars['jsonb']['input']>;
  scrambleWord?: InputMaybe<Scalars['jsonb']['input']>;
  turns?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type GamesAvgFields = {
  __typename?: 'games_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  currentTurn?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  seconds?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "games". All fields are combined with a logical 'AND'. */
export type GamesBoolExp = {
  _and?: InputMaybe<Array<GamesBoolExp>>;
  _not?: InputMaybe<GamesBoolExp>;
  _or?: InputMaybe<Array<GamesBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  currentTurn?: InputMaybe<IntComparisonExp>;
  data?: InputMaybe<JsonbComparisonExp>;
  difficulty?: InputMaybe<GameDifficultyEnumComparisonExp>;
  endedAt?: InputMaybe<TimestamptzComparisonExp>;
  gameUsers?: InputMaybe<GameUsersBoolExp>;
  gameUsers_aggregate?: InputMaybe<GameUsersAggregateBoolExp>;
  goalWord?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  languageCode?: InputMaybe<StringComparisonExp>;
  languageId?: InputMaybe<IntComparisonExp>;
  poemId?: InputMaybe<IntComparisonExp>;
  roomId?: InputMaybe<StringComparisonExp>;
  scrambleWord?: InputMaybe<JsonbComparisonExp>;
  seconds?: InputMaybe<IntComparisonExp>;
  spellingWord?: InputMaybe<StringComparisonExp>;
  startedAt?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  teamMode?: InputMaybe<StringComparisonExp>;
  turns?: InputMaybe<JsonbComparisonExp>;
  type?: InputMaybe<GameTypesEnumComparisonExp>;
  wordit?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "games" */
export enum GamesConstraint {
  /** unique or primary key constraint on columns "id" */
  GamesPkey = 'games_pkey',
  /** unique or primary key constraint on columns "room_id" */
  GamesRoomIdKey = 'games_room_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type GamesDeleteAtPathInput = {
  data?: InputMaybe<Array<Scalars['String']['input']>>;
  scrambleWord?: InputMaybe<Array<Scalars['String']['input']>>;
  turns?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type GamesDeleteElemInput = {
  data?: InputMaybe<Scalars['Int']['input']>;
  scrambleWord?: InputMaybe<Scalars['Int']['input']>;
  turns?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type GamesDeleteKeyInput = {
  data?: InputMaybe<Scalars['String']['input']>;
  scrambleWord?: InputMaybe<Scalars['String']['input']>;
  turns?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "games" */
export type GamesIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  currentTurn?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  poemId?: InputMaybe<Scalars['Int']['input']>;
  seconds?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "games" */
export type GamesInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  currentTurn?: InputMaybe<Scalars['Int']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  difficulty?: InputMaybe<GameDifficultyEnum>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  gameUsers?: InputMaybe<GameUsersArrRelInsertInput>;
  goalWord?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageCode?: InputMaybe<Scalars['String']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  poemId?: InputMaybe<Scalars['Int']['input']>;
  roomId?: InputMaybe<Scalars['String']['input']>;
  scrambleWord?: InputMaybe<Scalars['jsonb']['input']>;
  seconds?: InputMaybe<Scalars['Int']['input']>;
  spellingWord?: InputMaybe<Scalars['String']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  teamMode?: InputMaybe<Scalars['String']['input']>;
  turns?: InputMaybe<Scalars['jsonb']['input']>;
  type?: InputMaybe<GameTypesEnum>;
  wordit?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type GamesMaxFields = {
  __typename?: 'games_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  currentTurn?: Maybe<Scalars['Int']['output']>;
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  goalWord?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageCode?: Maybe<Scalars['String']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  poemId?: Maybe<Scalars['Int']['output']>;
  roomId?: Maybe<Scalars['String']['output']>;
  seconds?: Maybe<Scalars['Int']['output']>;
  spellingWord?: Maybe<Scalars['String']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  teamMode?: Maybe<Scalars['String']['output']>;
  wordit?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type GamesMinFields = {
  __typename?: 'games_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  currentTurn?: Maybe<Scalars['Int']['output']>;
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  goalWord?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageCode?: Maybe<Scalars['String']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  poemId?: Maybe<Scalars['Int']['output']>;
  roomId?: Maybe<Scalars['String']['output']>;
  seconds?: Maybe<Scalars['Int']['output']>;
  spellingWord?: Maybe<Scalars['String']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  teamMode?: Maybe<Scalars['String']['output']>;
  wordit?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "games" */
export type GamesMutationResponse = {
  __typename?: 'games_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Games>;
};

/** input type for inserting object relation for remote table "games" */
export type GamesObjRelInsertInput = {
  data: GamesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<GamesOnConflict>;
};

/** on_conflict condition type for table "games" */
export type GamesOnConflict = {
  constraint: GamesConstraint;
  update_columns?: Array<GamesUpdateColumn>;
  where?: InputMaybe<GamesBoolExp>;
};

/** Ordering options when selecting data from "games". */
export type GamesOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  currentTurn?: InputMaybe<OrderBy>;
  data?: InputMaybe<OrderBy>;
  difficulty?: InputMaybe<OrderBy>;
  endedAt?: InputMaybe<OrderBy>;
  gameUsers_aggregate?: InputMaybe<GameUsersAggregateOrderBy>;
  goalWord?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  languageCode?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  roomId?: InputMaybe<OrderBy>;
  scrambleWord?: InputMaybe<OrderBy>;
  seconds?: InputMaybe<OrderBy>;
  spellingWord?: InputMaybe<OrderBy>;
  startedAt?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  teamMode?: InputMaybe<OrderBy>;
  turns?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  wordit?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: games */
export type GamesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type GamesPrependInput = {
  data?: InputMaybe<Scalars['jsonb']['input']>;
  scrambleWord?: InputMaybe<Scalars['jsonb']['input']>;
  turns?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "games" */
export enum GamesSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CurrentTurn = 'currentTurn',
  /** column name */
  Data = 'data',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  EndedAt = 'endedAt',
  /** column name */
  GoalWord = 'goalWord',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  PoemId = 'poemId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ScrambleWord = 'scrambleWord',
  /** column name */
  Seconds = 'seconds',
  /** column name */
  SpellingWord = 'spellingWord',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  Status = 'status',
  /** column name */
  TeamMode = 'teamMode',
  /** column name */
  Turns = 'turns',
  /** column name */
  Type = 'type',
  /** column name */
  Wordit = 'wordit'
}

/** input type for updating data in table "games" */
export type GamesSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  currentTurn?: InputMaybe<Scalars['Int']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  difficulty?: InputMaybe<GameDifficultyEnum>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  goalWord?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageCode?: InputMaybe<Scalars['String']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  poemId?: InputMaybe<Scalars['Int']['input']>;
  roomId?: InputMaybe<Scalars['String']['input']>;
  scrambleWord?: InputMaybe<Scalars['jsonb']['input']>;
  seconds?: InputMaybe<Scalars['Int']['input']>;
  spellingWord?: InputMaybe<Scalars['String']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  teamMode?: InputMaybe<Scalars['String']['input']>;
  turns?: InputMaybe<Scalars['jsonb']['input']>;
  type?: InputMaybe<GameTypesEnum>;
  wordit?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type GamesStddevFields = {
  __typename?: 'games_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  currentTurn?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  seconds?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type GamesStddevPopFields = {
  __typename?: 'games_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  currentTurn?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  seconds?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type GamesStddevSampFields = {
  __typename?: 'games_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  currentTurn?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  seconds?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "games" */
export type GamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: GamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GamesStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  currentTurn?: InputMaybe<Scalars['Int']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  difficulty?: InputMaybe<GameDifficultyEnum>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  goalWord?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageCode?: InputMaybe<Scalars['String']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  poemId?: InputMaybe<Scalars['Int']['input']>;
  roomId?: InputMaybe<Scalars['String']['input']>;
  scrambleWord?: InputMaybe<Scalars['jsonb']['input']>;
  seconds?: InputMaybe<Scalars['Int']['input']>;
  spellingWord?: InputMaybe<Scalars['String']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  teamMode?: InputMaybe<Scalars['String']['input']>;
  turns?: InputMaybe<Scalars['jsonb']['input']>;
  type?: InputMaybe<GameTypesEnum>;
  wordit?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type GamesSumFields = {
  __typename?: 'games_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  currentTurn?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  poemId?: Maybe<Scalars['Int']['output']>;
  seconds?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "games" */
export enum GamesUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CurrentTurn = 'currentTurn',
  /** column name */
  Data = 'data',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  EndedAt = 'endedAt',
  /** column name */
  GoalWord = 'goalWord',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  PoemId = 'poemId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ScrambleWord = 'scrambleWord',
  /** column name */
  Seconds = 'seconds',
  /** column name */
  SpellingWord = 'spellingWord',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  Status = 'status',
  /** column name */
  TeamMode = 'teamMode',
  /** column name */
  Turns = 'turns',
  /** column name */
  Type = 'type',
  /** column name */
  Wordit = 'wordit'
}

export type GamesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<GamesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<GamesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<GamesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<GamesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<GamesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<GamesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GamesSetInput>;
  /** filter the rows which have to be updated */
  where: GamesBoolExp;
};

/** aggregate var_pop on columns */
export type GamesVarPopFields = {
  __typename?: 'games_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  currentTurn?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  seconds?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type GamesVarSampFields = {
  __typename?: 'games_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  currentTurn?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  seconds?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type GamesVarianceFields = {
  __typename?: 'games_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  currentTurn?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  seconds?: Maybe<Scalars['Float']['output']>;
};

export type GetRandomPoemArgs = {
  l_id?: InputMaybe<Scalars['Int']['input']>;
  seed?: InputMaybe<Scalars['seed_float']['input']>;
};

export type GetUserWordsCountArgs = {
  user_id_arg?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "goals" */
export type Goals = {
  __typename?: 'goals';
  booksCompletedPerMonth: Scalars['Int']['output'];
  coursesCompletedPerMonth: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  listeningDays: Array<Scalars['Int']['output']>;
  listeningMinPerDay: Scalars['Int']['output'];
  readingDays: Array<Scalars['Int']['output']>;
  readingMinPerDay: Scalars['Int']['output'];
  userId: Scalars['Int']['output'];
  wordDays: Array<Scalars['Int']['output']>;
  wordsPerDay: Scalars['Int']['output'];
};

/** aggregated selection of "goals" */
export type GoalsAggregate = {
  __typename?: 'goals_aggregate';
  aggregate?: Maybe<GoalsAggregateFields>;
  nodes: Array<Goals>;
};

/** aggregate fields of "goals" */
export type GoalsAggregateFields = {
  __typename?: 'goals_aggregate_fields';
  avg?: Maybe<GoalsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<GoalsMaxFields>;
  min?: Maybe<GoalsMinFields>;
  stddev?: Maybe<GoalsStddevFields>;
  stddev_pop?: Maybe<GoalsStddevPopFields>;
  stddev_samp?: Maybe<GoalsStddevSampFields>;
  sum?: Maybe<GoalsSumFields>;
  var_pop?: Maybe<GoalsVarPopFields>;
  var_samp?: Maybe<GoalsVarSampFields>;
  variance?: Maybe<GoalsVarianceFields>;
};


/** aggregate fields of "goals" */
export type GoalsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GoalsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type GoalsAvgFields = {
  __typename?: 'goals_avg_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinPerDay?: Maybe<Scalars['Float']['output']>;
  readingMinPerDay?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  wordsPerDay?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "goals". All fields are combined with a logical 'AND'. */
export type GoalsBoolExp = {
  _and?: InputMaybe<Array<GoalsBoolExp>>;
  _not?: InputMaybe<GoalsBoolExp>;
  _or?: InputMaybe<Array<GoalsBoolExp>>;
  booksCompletedPerMonth?: InputMaybe<IntComparisonExp>;
  coursesCompletedPerMonth?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  listeningDays?: InputMaybe<IntArrayComparisonExp>;
  listeningMinPerDay?: InputMaybe<IntComparisonExp>;
  readingDays?: InputMaybe<IntArrayComparisonExp>;
  readingMinPerDay?: InputMaybe<IntComparisonExp>;
  userId?: InputMaybe<IntComparisonExp>;
  wordDays?: InputMaybe<IntArrayComparisonExp>;
  wordsPerDay?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "goals" */
export enum GoalsConstraint {
  /** unique or primary key constraint on columns "id" */
  GoalsPkey = 'goals_pkey'
}

/** input type for incrementing numeric columns in table "goals" */
export type GoalsIncInput = {
  booksCompletedPerMonth?: InputMaybe<Scalars['Int']['input']>;
  coursesCompletedPerMonth?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  listeningMinPerDay?: InputMaybe<Scalars['Int']['input']>;
  readingMinPerDay?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  wordsPerDay?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "goals" */
export type GoalsInsertInput = {
  booksCompletedPerMonth?: InputMaybe<Scalars['Int']['input']>;
  coursesCompletedPerMonth?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  listeningDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  listeningMinPerDay?: InputMaybe<Scalars['Int']['input']>;
  readingDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  readingMinPerDay?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  wordDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  wordsPerDay?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type GoalsMaxFields = {
  __typename?: 'goals_max_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Int']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  listeningDays?: Maybe<Array<Scalars['Int']['output']>>;
  listeningMinPerDay?: Maybe<Scalars['Int']['output']>;
  readingDays?: Maybe<Array<Scalars['Int']['output']>>;
  readingMinPerDay?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  wordDays?: Maybe<Array<Scalars['Int']['output']>>;
  wordsPerDay?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type GoalsMinFields = {
  __typename?: 'goals_min_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Int']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  listeningDays?: Maybe<Array<Scalars['Int']['output']>>;
  listeningMinPerDay?: Maybe<Scalars['Int']['output']>;
  readingDays?: Maybe<Array<Scalars['Int']['output']>>;
  readingMinPerDay?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  wordDays?: Maybe<Array<Scalars['Int']['output']>>;
  wordsPerDay?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "goals" */
export type GoalsMutationResponse = {
  __typename?: 'goals_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Goals>;
};

/** on_conflict condition type for table "goals" */
export type GoalsOnConflict = {
  constraint: GoalsConstraint;
  update_columns?: Array<GoalsUpdateColumn>;
  where?: InputMaybe<GoalsBoolExp>;
};

/** Ordering options when selecting data from "goals". */
export type GoalsOrderBy = {
  booksCompletedPerMonth?: InputMaybe<OrderBy>;
  coursesCompletedPerMonth?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  listeningDays?: InputMaybe<OrderBy>;
  listeningMinPerDay?: InputMaybe<OrderBy>;
  readingDays?: InputMaybe<OrderBy>;
  readingMinPerDay?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  wordDays?: InputMaybe<OrderBy>;
  wordsPerDay?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: goals */
export type GoalsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "goals" */
export enum GoalsSelectColumn {
  /** column name */
  BooksCompletedPerMonth = 'booksCompletedPerMonth',
  /** column name */
  CoursesCompletedPerMonth = 'coursesCompletedPerMonth',
  /** column name */
  Id = 'id',
  /** column name */
  ListeningDays = 'listeningDays',
  /** column name */
  ListeningMinPerDay = 'listeningMinPerDay',
  /** column name */
  ReadingDays = 'readingDays',
  /** column name */
  ReadingMinPerDay = 'readingMinPerDay',
  /** column name */
  UserId = 'userId',
  /** column name */
  WordDays = 'wordDays',
  /** column name */
  WordsPerDay = 'wordsPerDay'
}

/** input type for updating data in table "goals" */
export type GoalsSetInput = {
  booksCompletedPerMonth?: InputMaybe<Scalars['Int']['input']>;
  coursesCompletedPerMonth?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  listeningDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  listeningMinPerDay?: InputMaybe<Scalars['Int']['input']>;
  readingDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  readingMinPerDay?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  wordDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  wordsPerDay?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type GoalsStddevFields = {
  __typename?: 'goals_stddev_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinPerDay?: Maybe<Scalars['Float']['output']>;
  readingMinPerDay?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  wordsPerDay?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type GoalsStddevPopFields = {
  __typename?: 'goals_stddev_pop_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinPerDay?: Maybe<Scalars['Float']['output']>;
  readingMinPerDay?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  wordsPerDay?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type GoalsStddevSampFields = {
  __typename?: 'goals_stddev_samp_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinPerDay?: Maybe<Scalars['Float']['output']>;
  readingMinPerDay?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  wordsPerDay?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "goals" */
export type GoalsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: GoalsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GoalsStreamCursorValueInput = {
  booksCompletedPerMonth?: InputMaybe<Scalars['Int']['input']>;
  coursesCompletedPerMonth?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  listeningDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  listeningMinPerDay?: InputMaybe<Scalars['Int']['input']>;
  readingDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  readingMinPerDay?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  wordDays?: InputMaybe<Array<Scalars['Int']['input']>>;
  wordsPerDay?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type GoalsSumFields = {
  __typename?: 'goals_sum_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Int']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  listeningMinPerDay?: Maybe<Scalars['Int']['output']>;
  readingMinPerDay?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  wordsPerDay?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "goals" */
export enum GoalsUpdateColumn {
  /** column name */
  BooksCompletedPerMonth = 'booksCompletedPerMonth',
  /** column name */
  CoursesCompletedPerMonth = 'coursesCompletedPerMonth',
  /** column name */
  Id = 'id',
  /** column name */
  ListeningDays = 'listeningDays',
  /** column name */
  ListeningMinPerDay = 'listeningMinPerDay',
  /** column name */
  ReadingDays = 'readingDays',
  /** column name */
  ReadingMinPerDay = 'readingMinPerDay',
  /** column name */
  UserId = 'userId',
  /** column name */
  WordDays = 'wordDays',
  /** column name */
  WordsPerDay = 'wordsPerDay'
}

export type GoalsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<GoalsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GoalsSetInput>;
  /** filter the rows which have to be updated */
  where: GoalsBoolExp;
};

/** aggregate var_pop on columns */
export type GoalsVarPopFields = {
  __typename?: 'goals_var_pop_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinPerDay?: Maybe<Scalars['Float']['output']>;
  readingMinPerDay?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  wordsPerDay?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type GoalsVarSampFields = {
  __typename?: 'goals_var_samp_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinPerDay?: Maybe<Scalars['Float']['output']>;
  readingMinPerDay?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  wordsPerDay?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type GoalsVarianceFields = {
  __typename?: 'goals_variance_fields';
  booksCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  coursesCompletedPerMonth?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  listeningMinPerDay?: Maybe<Scalars['Float']['output']>;
  readingMinPerDay?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  wordsPerDay?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "images" */
export type Images = {
  __typename?: 'images';
  height: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  imageUrl: Scalars['String']['output'];
  photographerName: Scalars['String']['output'];
  photographerUrl: Scalars['String']['output'];
  synset?: Maybe<Scalars['String']['output']>;
  synsetId?: Maybe<Scalars['Int']['output']>;
  width: Scalars['Int']['output'];
  word?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "images" */
export type ImagesAggregate = {
  __typename?: 'images_aggregate';
  aggregate?: Maybe<ImagesAggregateFields>;
  nodes: Array<Images>;
};

/** aggregate fields of "images" */
export type ImagesAggregateFields = {
  __typename?: 'images_aggregate_fields';
  avg?: Maybe<ImagesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ImagesMaxFields>;
  min?: Maybe<ImagesMinFields>;
  stddev?: Maybe<ImagesStddevFields>;
  stddev_pop?: Maybe<ImagesStddevPopFields>;
  stddev_samp?: Maybe<ImagesStddevSampFields>;
  sum?: Maybe<ImagesSumFields>;
  var_pop?: Maybe<ImagesVarPopFields>;
  var_samp?: Maybe<ImagesVarSampFields>;
  variance?: Maybe<ImagesVarianceFields>;
};


/** aggregate fields of "images" */
export type ImagesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ImagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ImagesAvgFields = {
  __typename?: 'images_avg_fields';
  height?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "images". All fields are combined with a logical 'AND'. */
export type ImagesBoolExp = {
  _and?: InputMaybe<Array<ImagesBoolExp>>;
  _not?: InputMaybe<ImagesBoolExp>;
  _or?: InputMaybe<Array<ImagesBoolExp>>;
  height?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  imageUrl?: InputMaybe<StringComparisonExp>;
  photographerName?: InputMaybe<StringComparisonExp>;
  photographerUrl?: InputMaybe<StringComparisonExp>;
  synset?: InputMaybe<StringComparisonExp>;
  synsetId?: InputMaybe<IntComparisonExp>;
  width?: InputMaybe<IntComparisonExp>;
  word?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "images" */
export enum ImagesConstraint {
  /** unique or primary key constraint on columns "id" */
  ImagesPkey = 'images_pkey'
}

/** input type for incrementing numeric columns in table "images" */
export type ImagesIncInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  synsetId?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "images" */
export type ImagesInsertInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  photographerName?: InputMaybe<Scalars['String']['input']>;
  photographerUrl?: InputMaybe<Scalars['String']['input']>;
  synset?: InputMaybe<Scalars['String']['input']>;
  synsetId?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type ImagesMaxFields = {
  __typename?: 'images_max_fields';
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageUrl?: Maybe<Scalars['String']['output']>;
  photographerName?: Maybe<Scalars['String']['output']>;
  photographerUrl?: Maybe<Scalars['String']['output']>;
  synset?: Maybe<Scalars['String']['output']>;
  synsetId?: Maybe<Scalars['Int']['output']>;
  width?: Maybe<Scalars['Int']['output']>;
  word?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type ImagesMinFields = {
  __typename?: 'images_min_fields';
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageUrl?: Maybe<Scalars['String']['output']>;
  photographerName?: Maybe<Scalars['String']['output']>;
  photographerUrl?: Maybe<Scalars['String']['output']>;
  synset?: Maybe<Scalars['String']['output']>;
  synsetId?: Maybe<Scalars['Int']['output']>;
  width?: Maybe<Scalars['Int']['output']>;
  word?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "images" */
export type ImagesMutationResponse = {
  __typename?: 'images_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Images>;
};

/** input type for inserting object relation for remote table "images" */
export type ImagesObjRelInsertInput = {
  data: ImagesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ImagesOnConflict>;
};

/** on_conflict condition type for table "images" */
export type ImagesOnConflict = {
  constraint: ImagesConstraint;
  update_columns?: Array<ImagesUpdateColumn>;
  where?: InputMaybe<ImagesBoolExp>;
};

/** Ordering options when selecting data from "images". */
export type ImagesOrderBy = {
  height?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageUrl?: InputMaybe<OrderBy>;
  photographerName?: InputMaybe<OrderBy>;
  photographerUrl?: InputMaybe<OrderBy>;
  synset?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: images */
export type ImagesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "images" */
export enum ImagesSelectColumn {
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  ImageUrl = 'imageUrl',
  /** column name */
  PhotographerName = 'photographerName',
  /** column name */
  PhotographerUrl = 'photographerUrl',
  /** column name */
  Synset = 'synset',
  /** column name */
  SynsetId = 'synsetId',
  /** column name */
  Width = 'width',
  /** column name */
  Word = 'word'
}

/** input type for updating data in table "images" */
export type ImagesSetInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  photographerName?: InputMaybe<Scalars['String']['input']>;
  photographerUrl?: InputMaybe<Scalars['String']['input']>;
  synset?: InputMaybe<Scalars['String']['input']>;
  synsetId?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type ImagesStddevFields = {
  __typename?: 'images_stddev_fields';
  height?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ImagesStddevPopFields = {
  __typename?: 'images_stddev_pop_fields';
  height?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ImagesStddevSampFields = {
  __typename?: 'images_stddev_samp_fields';
  height?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "images" */
export type ImagesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ImagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ImagesStreamCursorValueInput = {
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageUrl?: InputMaybe<Scalars['String']['input']>;
  photographerName?: InputMaybe<Scalars['String']['input']>;
  photographerUrl?: InputMaybe<Scalars['String']['input']>;
  synset?: InputMaybe<Scalars['String']['input']>;
  synsetId?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type ImagesSumFields = {
  __typename?: 'images_sum_fields';
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  synsetId?: Maybe<Scalars['Int']['output']>;
  width?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "images" */
export enum ImagesUpdateColumn {
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  ImageUrl = 'imageUrl',
  /** column name */
  PhotographerName = 'photographerName',
  /** column name */
  PhotographerUrl = 'photographerUrl',
  /** column name */
  Synset = 'synset',
  /** column name */
  SynsetId = 'synsetId',
  /** column name */
  Width = 'width',
  /** column name */
  Word = 'word'
}

export type ImagesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ImagesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ImagesSetInput>;
  /** filter the rows which have to be updated */
  where: ImagesBoolExp;
};

/** aggregate var_pop on columns */
export type ImagesVarPopFields = {
  __typename?: 'images_var_pop_fields';
  height?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ImagesVarSampFields = {
  __typename?: 'images_var_samp_fields';
  height?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ImagesVarianceFields = {
  __typename?: 'images_variance_fields';
  height?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "interests" */
export type Interests = {
  __typename?: 'interests';
  emoji: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  teacherInterests: Array<TeacherInterests>;
  /** An aggregate relationship */
  teacherInterests_aggregate: TeacherInterestsAggregate;
};


/** columns and relationships of "interests" */
export type InterestsTeacherInterestsArgs = {
  distinct_on?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherInterestsOrderBy>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};


/** columns and relationships of "interests" */
export type InterestsTeacherInterestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherInterestsOrderBy>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};

/** aggregated selection of "interests" */
export type InterestsAggregate = {
  __typename?: 'interests_aggregate';
  aggregate?: Maybe<InterestsAggregateFields>;
  nodes: Array<Interests>;
};

/** aggregate fields of "interests" */
export type InterestsAggregateFields = {
  __typename?: 'interests_aggregate_fields';
  avg?: Maybe<InterestsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<InterestsMaxFields>;
  min?: Maybe<InterestsMinFields>;
  stddev?: Maybe<InterestsStddevFields>;
  stddev_pop?: Maybe<InterestsStddevPopFields>;
  stddev_samp?: Maybe<InterestsStddevSampFields>;
  sum?: Maybe<InterestsSumFields>;
  var_pop?: Maybe<InterestsVarPopFields>;
  var_samp?: Maybe<InterestsVarSampFields>;
  variance?: Maybe<InterestsVarianceFields>;
};


/** aggregate fields of "interests" */
export type InterestsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<InterestsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type InterestsAvgFields = {
  __typename?: 'interests_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "interests". All fields are combined with a logical 'AND'. */
export type InterestsBoolExp = {
  _and?: InputMaybe<Array<InterestsBoolExp>>;
  _not?: InputMaybe<InterestsBoolExp>;
  _or?: InputMaybe<Array<InterestsBoolExp>>;
  emoji?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  teacherInterests?: InputMaybe<TeacherInterestsBoolExp>;
  teacherInterests_aggregate?: InputMaybe<TeacherInterestsAggregateBoolExp>;
};

/** unique or primary key constraints on table "interests" */
export enum InterestsConstraint {
  /** unique or primary key constraint on columns "name" */
  InterestsNameKey = 'interests_name_key',
  /** unique or primary key constraint on columns "id" */
  InterestsPkey = 'interests_pkey'
}

/** input type for incrementing numeric columns in table "interests" */
export type InterestsIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "interests" */
export type InterestsInsertInput = {
  emoji?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  teacherInterests?: InputMaybe<TeacherInterestsArrRelInsertInput>;
};

/** aggregate max on columns */
export type InterestsMaxFields = {
  __typename?: 'interests_max_fields';
  emoji?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type InterestsMinFields = {
  __typename?: 'interests_min_fields';
  emoji?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "interests" */
export type InterestsMutationResponse = {
  __typename?: 'interests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Interests>;
};

/** input type for inserting object relation for remote table "interests" */
export type InterestsObjRelInsertInput = {
  data: InterestsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<InterestsOnConflict>;
};

/** on_conflict condition type for table "interests" */
export type InterestsOnConflict = {
  constraint: InterestsConstraint;
  update_columns?: Array<InterestsUpdateColumn>;
  where?: InputMaybe<InterestsBoolExp>;
};

/** Ordering options when selecting data from "interests". */
export type InterestsOrderBy = {
  emoji?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  teacherInterests_aggregate?: InputMaybe<TeacherInterestsAggregateOrderBy>;
};

/** primary key columns input for table: interests */
export type InterestsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "interests" */
export enum InterestsSelectColumn {
  /** column name */
  Emoji = 'emoji',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "interests" */
export type InterestsSetInput = {
  emoji?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type InterestsStddevFields = {
  __typename?: 'interests_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type InterestsStddevPopFields = {
  __typename?: 'interests_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type InterestsStddevSampFields = {
  __typename?: 'interests_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "interests" */
export type InterestsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: InterestsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type InterestsStreamCursorValueInput = {
  emoji?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type InterestsSumFields = {
  __typename?: 'interests_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "interests" */
export enum InterestsUpdateColumn {
  /** column name */
  Emoji = 'emoji',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type InterestsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<InterestsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<InterestsSetInput>;
  /** filter the rows which have to be updated */
  where: InterestsBoolExp;
};

/** aggregate var_pop on columns */
export type InterestsVarPopFields = {
  __typename?: 'interests_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type InterestsVarSampFields = {
  __typename?: 'interests_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type InterestsVarianceFields = {
  __typename?: 'interests_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

export type JsonbCastExp = {
  String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']['input']>;
  _eq?: InputMaybe<Scalars['jsonb']['input']>;
  _gt?: InputMaybe<Scalars['jsonb']['input']>;
  _gte?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']['input']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']['input']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['jsonb']['input']>;
  _lte?: InputMaybe<Scalars['jsonb']['input']>;
  _neq?: InputMaybe<Scalars['jsonb']['input']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']['input']>>;
};

/** columns and relationships of "languages" */
export type Languages = {
  __typename?: 'languages';
  id: Scalars['Int']['output'];
  key: Scalars['String']['output'];
  name: Scalars['String']['output'];
  native: Scalars['String']['output'];
};

/** aggregated selection of "languages" */
export type LanguagesAggregate = {
  __typename?: 'languages_aggregate';
  aggregate?: Maybe<LanguagesAggregateFields>;
  nodes: Array<Languages>;
};

/** aggregate fields of "languages" */
export type LanguagesAggregateFields = {
  __typename?: 'languages_aggregate_fields';
  avg?: Maybe<LanguagesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<LanguagesMaxFields>;
  min?: Maybe<LanguagesMinFields>;
  stddev?: Maybe<LanguagesStddevFields>;
  stddev_pop?: Maybe<LanguagesStddevPopFields>;
  stddev_samp?: Maybe<LanguagesStddevSampFields>;
  sum?: Maybe<LanguagesSumFields>;
  var_pop?: Maybe<LanguagesVarPopFields>;
  var_samp?: Maybe<LanguagesVarSampFields>;
  variance?: Maybe<LanguagesVarianceFields>;
};


/** aggregate fields of "languages" */
export type LanguagesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LanguagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type LanguagesAvgFields = {
  __typename?: 'languages_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "languages". All fields are combined with a logical 'AND'. */
export type LanguagesBoolExp = {
  _and?: InputMaybe<Array<LanguagesBoolExp>>;
  _not?: InputMaybe<LanguagesBoolExp>;
  _or?: InputMaybe<Array<LanguagesBoolExp>>;
  id?: InputMaybe<IntComparisonExp>;
  key?: InputMaybe<StringComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  native?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "languages" */
export enum LanguagesConstraint {
  /** unique or primary key constraint on columns "key" */
  LanguagesKeyKey = 'languages_key_key',
  /** unique or primary key constraint on columns "id" */
  LanguagesPkey = 'languages_pkey'
}

/** input type for incrementing numeric columns in table "languages" */
export type LanguagesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "languages" */
export type LanguagesInsertInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  native?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type LanguagesMaxFields = {
  __typename?: 'languages_max_fields';
  id?: Maybe<Scalars['Int']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  native?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type LanguagesMinFields = {
  __typename?: 'languages_min_fields';
  id?: Maybe<Scalars['Int']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  native?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "languages" */
export type LanguagesMutationResponse = {
  __typename?: 'languages_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Languages>;
};

/** input type for inserting object relation for remote table "languages" */
export type LanguagesObjRelInsertInput = {
  data: LanguagesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<LanguagesOnConflict>;
};

/** on_conflict condition type for table "languages" */
export type LanguagesOnConflict = {
  constraint: LanguagesConstraint;
  update_columns?: Array<LanguagesUpdateColumn>;
  where?: InputMaybe<LanguagesBoolExp>;
};

/** Ordering options when selecting data from "languages". */
export type LanguagesOrderBy = {
  id?: InputMaybe<OrderBy>;
  key?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  native?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: languages */
export type LanguagesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "languages" */
export enum LanguagesSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  Native = 'native'
}

/** input type for updating data in table "languages" */
export type LanguagesSetInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  native?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type LanguagesStddevFields = {
  __typename?: 'languages_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type LanguagesStddevPopFields = {
  __typename?: 'languages_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type LanguagesStddevSampFields = {
  __typename?: 'languages_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "languages" */
export type LanguagesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LanguagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LanguagesStreamCursorValueInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  native?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type LanguagesSumFields = {
  __typename?: 'languages_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "languages" */
export enum LanguagesUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  Native = 'native'
}

export type LanguagesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LanguagesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LanguagesSetInput>;
  /** filter the rows which have to be updated */
  where: LanguagesBoolExp;
};

/** aggregate var_pop on columns */
export type LanguagesVarPopFields = {
  __typename?: 'languages_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type LanguagesVarSampFields = {
  __typename?: 'languages_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type LanguagesVarianceFields = {
  __typename?: 'languages_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "listenings" */
export type Listenings = {
  __typename?: 'listenings';
  audioKey: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  instructions: Scalars['String']['output'];
  transcriptKey?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
  videoKey?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "listenings" */
export type ListeningsAggregate = {
  __typename?: 'listenings_aggregate';
  aggregate?: Maybe<ListeningsAggregateFields>;
  nodes: Array<Listenings>;
};

/** aggregate fields of "listenings" */
export type ListeningsAggregateFields = {
  __typename?: 'listenings_aggregate_fields';
  avg?: Maybe<ListeningsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ListeningsMaxFields>;
  min?: Maybe<ListeningsMinFields>;
  stddev?: Maybe<ListeningsStddevFields>;
  stddev_pop?: Maybe<ListeningsStddevPopFields>;
  stddev_samp?: Maybe<ListeningsStddevSampFields>;
  sum?: Maybe<ListeningsSumFields>;
  var_pop?: Maybe<ListeningsVarPopFields>;
  var_samp?: Maybe<ListeningsVarSampFields>;
  variance?: Maybe<ListeningsVarianceFields>;
};


/** aggregate fields of "listenings" */
export type ListeningsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ListeningsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ListeningsAvgFields = {
  __typename?: 'listenings_avg_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "listenings". All fields are combined with a logical 'AND'. */
export type ListeningsBoolExp = {
  _and?: InputMaybe<Array<ListeningsBoolExp>>;
  _not?: InputMaybe<ListeningsBoolExp>;
  _or?: InputMaybe<Array<ListeningsBoolExp>>;
  audioKey?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  created_by?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  instructions?: InputMaybe<StringComparisonExp>;
  transcriptKey?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  videoKey?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "listenings" */
export enum ListeningsConstraint {
  /** unique or primary key constraint on columns "id" */
  ListeningPkey = 'listening_pkey'
}

/** input type for incrementing numeric columns in table "listenings" */
export type ListeningsIncInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "listenings" */
export type ListeningsInsertInput = {
  audioKey?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  instructions?: InputMaybe<Scalars['String']['input']>;
  transcriptKey?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  videoKey?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type ListeningsMaxFields = {
  __typename?: 'listenings_max_fields';
  audioKey?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  instructions?: Maybe<Scalars['String']['output']>;
  transcriptKey?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  videoKey?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type ListeningsMinFields = {
  __typename?: 'listenings_min_fields';
  audioKey?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  instructions?: Maybe<Scalars['String']['output']>;
  transcriptKey?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  videoKey?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "listenings" */
export type ListeningsMutationResponse = {
  __typename?: 'listenings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Listenings>;
};

/** input type for inserting object relation for remote table "listenings" */
export type ListeningsObjRelInsertInput = {
  data: ListeningsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ListeningsOnConflict>;
};

/** on_conflict condition type for table "listenings" */
export type ListeningsOnConflict = {
  constraint: ListeningsConstraint;
  update_columns?: Array<ListeningsUpdateColumn>;
  where?: InputMaybe<ListeningsBoolExp>;
};

/** Ordering options when selecting data from "listenings". */
export type ListeningsOrderBy = {
  audioKey?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  instructions?: InputMaybe<OrderBy>;
  transcriptKey?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  videoKey?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: listenings */
export type ListeningsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "listenings" */
export enum ListeningsSelectColumn {
  /** column name */
  AudioKey = 'audioKey',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Instructions = 'instructions',
  /** column name */
  TranscriptKey = 'transcriptKey',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoKey = 'videoKey'
}

/** input type for updating data in table "listenings" */
export type ListeningsSetInput = {
  audioKey?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  instructions?: InputMaybe<Scalars['String']['input']>;
  transcriptKey?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  videoKey?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type ListeningsStddevFields = {
  __typename?: 'listenings_stddev_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ListeningsStddevPopFields = {
  __typename?: 'listenings_stddev_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ListeningsStddevSampFields = {
  __typename?: 'listenings_stddev_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "listenings" */
export type ListeningsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ListeningsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ListeningsStreamCursorValueInput = {
  audioKey?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  instructions?: InputMaybe<Scalars['String']['input']>;
  transcriptKey?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  videoKey?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type ListeningsSumFields = {
  __typename?: 'listenings_sum_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "listenings" */
export enum ListeningsUpdateColumn {
  /** column name */
  AudioKey = 'audioKey',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Instructions = 'instructions',
  /** column name */
  TranscriptKey = 'transcriptKey',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoKey = 'videoKey'
}

export type ListeningsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ListeningsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ListeningsSetInput>;
  /** filter the rows which have to be updated */
  where: ListeningsBoolExp;
};

/** aggregate var_pop on columns */
export type ListeningsVarPopFields = {
  __typename?: 'listenings_var_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ListeningsVarSampFields = {
  __typename?: 'listenings_var_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ListeningsVarianceFields = {
  __typename?: 'listenings_variance_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "live_class_activities" */
export type LiveClassActivities = {
  __typename?: 'live_class_activities';
  /** An object relationship */
  activitySet: ActivitySets;
  activitySetId: Scalars['Int']['output'];
  createdAt: Scalars['timestamptz']['output'];
  data: Scalars['jsonb']['output'];
  gameId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** An array relationship */
  liveMessages: Array<LiveMessages>;
  /** An aggregate relationship */
  liveMessages_aggregate: LiveMessagesAggregate;
  room: Scalars['String']['output'];
  shouldRefetchActivity?: Maybe<Scalars['timestamptz']['output']>;
  showRecordings?: Maybe<Scalars['Boolean']['output']>;
  showWhiteboard?: Maybe<Scalars['Boolean']['output']>;
  status: Scalars['String']['output'];
  /** An array relationship */
  students: Array<StudentLiveClassActivities>;
  /** An aggregate relationship */
  students_aggregate: StudentLiveClassActivitiesAggregate;
  teacherId: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "live_class_activities" */
export type LiveClassActivitiesDataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "live_class_activities" */
export type LiveClassActivitiesLiveMessagesArgs = {
  distinct_on?: InputMaybe<Array<LiveMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveMessagesOrderBy>>;
  where?: InputMaybe<LiveMessagesBoolExp>;
};


/** columns and relationships of "live_class_activities" */
export type LiveClassActivitiesLiveMessagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<LiveMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveMessagesOrderBy>>;
  where?: InputMaybe<LiveMessagesBoolExp>;
};


/** columns and relationships of "live_class_activities" */
export type LiveClassActivitiesStudentsArgs = {
  distinct_on?: InputMaybe<Array<StudentLiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentLiveClassActivitiesOrderBy>>;
  where?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
};


/** columns and relationships of "live_class_activities" */
export type LiveClassActivitiesStudentsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentLiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentLiveClassActivitiesOrderBy>>;
  where?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
};

/** aggregated selection of "live_class_activities" */
export type LiveClassActivitiesAggregate = {
  __typename?: 'live_class_activities_aggregate';
  aggregate?: Maybe<LiveClassActivitiesAggregateFields>;
  nodes: Array<LiveClassActivities>;
};

/** aggregate fields of "live_class_activities" */
export type LiveClassActivitiesAggregateFields = {
  __typename?: 'live_class_activities_aggregate_fields';
  avg?: Maybe<LiveClassActivitiesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<LiveClassActivitiesMaxFields>;
  min?: Maybe<LiveClassActivitiesMinFields>;
  stddev?: Maybe<LiveClassActivitiesStddevFields>;
  stddev_pop?: Maybe<LiveClassActivitiesStddevPopFields>;
  stddev_samp?: Maybe<LiveClassActivitiesStddevSampFields>;
  sum?: Maybe<LiveClassActivitiesSumFields>;
  var_pop?: Maybe<LiveClassActivitiesVarPopFields>;
  var_samp?: Maybe<LiveClassActivitiesVarSampFields>;
  variance?: Maybe<LiveClassActivitiesVarianceFields>;
};


/** aggregate fields of "live_class_activities" */
export type LiveClassActivitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LiveClassActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type LiveClassActivitiesAppendInput = {
  data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type LiveClassActivitiesAvgFields = {
  __typename?: 'live_class_activities_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "live_class_activities". All fields are combined with a logical 'AND'. */
export type LiveClassActivitiesBoolExp = {
  _and?: InputMaybe<Array<LiveClassActivitiesBoolExp>>;
  _not?: InputMaybe<LiveClassActivitiesBoolExp>;
  _or?: InputMaybe<Array<LiveClassActivitiesBoolExp>>;
  activitySet?: InputMaybe<ActivitySetsBoolExp>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  data?: InputMaybe<JsonbComparisonExp>;
  gameId?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  liveMessages?: InputMaybe<LiveMessagesBoolExp>;
  liveMessages_aggregate?: InputMaybe<LiveMessagesAggregateBoolExp>;
  room?: InputMaybe<StringComparisonExp>;
  shouldRefetchActivity?: InputMaybe<TimestamptzComparisonExp>;
  showRecordings?: InputMaybe<BooleanComparisonExp>;
  showWhiteboard?: InputMaybe<BooleanComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  students?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
  students_aggregate?: InputMaybe<StudentLiveClassActivitiesAggregateBoolExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "live_class_activities" */
export enum LiveClassActivitiesConstraint {
  /** unique or primary key constraint on columns "id" */
  LiveClassActivitiesPkey = 'live_class_activities_pkey',
  /** unique or primary key constraint on columns "room" */
  LiveClassActivitiesRoomKey = 'live_class_activities_room_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type LiveClassActivitiesDeleteAtPathInput = {
  data?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type LiveClassActivitiesDeleteElemInput = {
  data?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type LiveClassActivitiesDeleteKeyInput = {
  data?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "live_class_activities" */
export type LiveClassActivitiesIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  gameId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "live_class_activities" */
export type LiveClassActivitiesInsertInput = {
  activitySet?: InputMaybe<ActivitySetsObjRelInsertInput>;
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  gameId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  liveMessages?: InputMaybe<LiveMessagesArrRelInsertInput>;
  room?: InputMaybe<Scalars['String']['input']>;
  shouldRefetchActivity?: InputMaybe<Scalars['timestamptz']['input']>;
  showRecordings?: InputMaybe<Scalars['Boolean']['input']>;
  showWhiteboard?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  students?: InputMaybe<StudentLiveClassActivitiesArrRelInsertInput>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type LiveClassActivitiesMaxFields = {
  __typename?: 'live_class_activities_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  gameId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  room?: Maybe<Scalars['String']['output']>;
  shouldRefetchActivity?: Maybe<Scalars['timestamptz']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type LiveClassActivitiesMinFields = {
  __typename?: 'live_class_activities_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  gameId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  room?: Maybe<Scalars['String']['output']>;
  shouldRefetchActivity?: Maybe<Scalars['timestamptz']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "live_class_activities" */
export type LiveClassActivitiesMutationResponse = {
  __typename?: 'live_class_activities_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<LiveClassActivities>;
};

/** input type for inserting object relation for remote table "live_class_activities" */
export type LiveClassActivitiesObjRelInsertInput = {
  data: LiveClassActivitiesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<LiveClassActivitiesOnConflict>;
};

/** on_conflict condition type for table "live_class_activities" */
export type LiveClassActivitiesOnConflict = {
  constraint: LiveClassActivitiesConstraint;
  update_columns?: Array<LiveClassActivitiesUpdateColumn>;
  where?: InputMaybe<LiveClassActivitiesBoolExp>;
};

/** Ordering options when selecting data from "live_class_activities". */
export type LiveClassActivitiesOrderBy = {
  activitySet?: InputMaybe<ActivitySetsOrderBy>;
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  data?: InputMaybe<OrderBy>;
  gameId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  liveMessages_aggregate?: InputMaybe<LiveMessagesAggregateOrderBy>;
  room?: InputMaybe<OrderBy>;
  shouldRefetchActivity?: InputMaybe<OrderBy>;
  showRecordings?: InputMaybe<OrderBy>;
  showWhiteboard?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  students_aggregate?: InputMaybe<StudentLiveClassActivitiesAggregateOrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: live_class_activities */
export type LiveClassActivitiesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type LiveClassActivitiesPrependInput = {
  data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "live_class_activities" */
export enum LiveClassActivitiesSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  GameId = 'gameId',
  /** column name */
  Id = 'id',
  /** column name */
  Room = 'room',
  /** column name */
  ShouldRefetchActivity = 'shouldRefetchActivity',
  /** column name */
  ShowRecordings = 'showRecordings',
  /** column name */
  ShowWhiteboard = 'showWhiteboard',
  /** column name */
  Status = 'status',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "live_class_activities" */
export type LiveClassActivitiesSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  gameId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  room?: InputMaybe<Scalars['String']['input']>;
  shouldRefetchActivity?: InputMaybe<Scalars['timestamptz']['input']>;
  showRecordings?: InputMaybe<Scalars['Boolean']['input']>;
  showWhiteboard?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type LiveClassActivitiesStddevFields = {
  __typename?: 'live_class_activities_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type LiveClassActivitiesStddevPopFields = {
  __typename?: 'live_class_activities_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type LiveClassActivitiesStddevSampFields = {
  __typename?: 'live_class_activities_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "live_class_activities" */
export type LiveClassActivitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LiveClassActivitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LiveClassActivitiesStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  gameId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  room?: InputMaybe<Scalars['String']['input']>;
  shouldRefetchActivity?: InputMaybe<Scalars['timestamptz']['input']>;
  showRecordings?: InputMaybe<Scalars['Boolean']['input']>;
  showWhiteboard?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type LiveClassActivitiesSumFields = {
  __typename?: 'live_class_activities_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  gameId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "live_class_activities" */
export enum LiveClassActivitiesUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  GameId = 'gameId',
  /** column name */
  Id = 'id',
  /** column name */
  Room = 'room',
  /** column name */
  ShouldRefetchActivity = 'shouldRefetchActivity',
  /** column name */
  ShowRecordings = 'showRecordings',
  /** column name */
  ShowWhiteboard = 'showWhiteboard',
  /** column name */
  Status = 'status',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type LiveClassActivitiesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<LiveClassActivitiesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<LiveClassActivitiesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<LiveClassActivitiesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<LiveClassActivitiesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LiveClassActivitiesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<LiveClassActivitiesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LiveClassActivitiesSetInput>;
  /** filter the rows which have to be updated */
  where: LiveClassActivitiesBoolExp;
};

/** aggregate var_pop on columns */
export type LiveClassActivitiesVarPopFields = {
  __typename?: 'live_class_activities_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type LiveClassActivitiesVarSampFields = {
  __typename?: 'live_class_activities_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type LiveClassActivitiesVarianceFields = {
  __typename?: 'live_class_activities_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  gameId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "live_messages" */
export type LiveMessages = {
  __typename?: 'live_messages';
  content: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** An object relationship */
  liveClassActivity: LiveClassActivities;
  liveClassActivityId: Scalars['Int']['output'];
  sentAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['Int']['output'];
};

/** aggregated selection of "live_messages" */
export type LiveMessagesAggregate = {
  __typename?: 'live_messages_aggregate';
  aggregate?: Maybe<LiveMessagesAggregateFields>;
  nodes: Array<LiveMessages>;
};

export type LiveMessagesAggregateBoolExp = {
  count?: InputMaybe<LiveMessagesAggregateBoolExpCount>;
};

export type LiveMessagesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LiveMessagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<LiveMessagesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "live_messages" */
export type LiveMessagesAggregateFields = {
  __typename?: 'live_messages_aggregate_fields';
  avg?: Maybe<LiveMessagesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<LiveMessagesMaxFields>;
  min?: Maybe<LiveMessagesMinFields>;
  stddev?: Maybe<LiveMessagesStddevFields>;
  stddev_pop?: Maybe<LiveMessagesStddevPopFields>;
  stddev_samp?: Maybe<LiveMessagesStddevSampFields>;
  sum?: Maybe<LiveMessagesSumFields>;
  var_pop?: Maybe<LiveMessagesVarPopFields>;
  var_samp?: Maybe<LiveMessagesVarSampFields>;
  variance?: Maybe<LiveMessagesVarianceFields>;
};


/** aggregate fields of "live_messages" */
export type LiveMessagesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LiveMessagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "live_messages" */
export type LiveMessagesAggregateOrderBy = {
  avg?: InputMaybe<LiveMessagesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LiveMessagesMaxOrderBy>;
  min?: InputMaybe<LiveMessagesMinOrderBy>;
  stddev?: InputMaybe<LiveMessagesStddevOrderBy>;
  stddev_pop?: InputMaybe<LiveMessagesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<LiveMessagesStddevSampOrderBy>;
  sum?: InputMaybe<LiveMessagesSumOrderBy>;
  var_pop?: InputMaybe<LiveMessagesVarPopOrderBy>;
  var_samp?: InputMaybe<LiveMessagesVarSampOrderBy>;
  variance?: InputMaybe<LiveMessagesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "live_messages" */
export type LiveMessagesArrRelInsertInput = {
  data: Array<LiveMessagesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<LiveMessagesOnConflict>;
};

/** aggregate avg on columns */
export type LiveMessagesAvgFields = {
  __typename?: 'live_messages_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivityId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "live_messages" */
export type LiveMessagesAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "live_messages". All fields are combined with a logical 'AND'. */
export type LiveMessagesBoolExp = {
  _and?: InputMaybe<Array<LiveMessagesBoolExp>>;
  _not?: InputMaybe<LiveMessagesBoolExp>;
  _or?: InputMaybe<Array<LiveMessagesBoolExp>>;
  content?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  liveClassActivity?: InputMaybe<LiveClassActivitiesBoolExp>;
  liveClassActivityId?: InputMaybe<IntComparisonExp>;
  sentAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "live_messages" */
export enum LiveMessagesConstraint {
  /** unique or primary key constraint on columns "id" */
  LiveMessagesPkey = 'live_messages_pkey'
}

/** input type for incrementing numeric columns in table "live_messages" */
export type LiveMessagesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  liveClassActivityId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "live_messages" */
export type LiveMessagesInsertInput = {
  content?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  liveClassActivity?: InputMaybe<LiveClassActivitiesObjRelInsertInput>;
  liveClassActivityId?: InputMaybe<Scalars['Int']['input']>;
  sentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type LiveMessagesMaxFields = {
  __typename?: 'live_messages_max_fields';
  content?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  liveClassActivityId?: Maybe<Scalars['Int']['output']>;
  sentAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "live_messages" */
export type LiveMessagesMaxOrderBy = {
  content?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  sentAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LiveMessagesMinFields = {
  __typename?: 'live_messages_min_fields';
  content?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  liveClassActivityId?: Maybe<Scalars['Int']['output']>;
  sentAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "live_messages" */
export type LiveMessagesMinOrderBy = {
  content?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  sentAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "live_messages" */
export type LiveMessagesMutationResponse = {
  __typename?: 'live_messages_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<LiveMessages>;
};

/** on_conflict condition type for table "live_messages" */
export type LiveMessagesOnConflict = {
  constraint: LiveMessagesConstraint;
  update_columns?: Array<LiveMessagesUpdateColumn>;
  where?: InputMaybe<LiveMessagesBoolExp>;
};

/** Ordering options when selecting data from "live_messages". */
export type LiveMessagesOrderBy = {
  content?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  liveClassActivity?: InputMaybe<LiveClassActivitiesOrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  sentAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: live_messages */
export type LiveMessagesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "live_messages" */
export enum LiveMessagesSelectColumn {
  /** column name */
  Content = 'content',
  /** column name */
  Id = 'id',
  /** column name */
  LiveClassActivityId = 'liveClassActivityId',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "live_messages" */
export type LiveMessagesSetInput = {
  content?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  liveClassActivityId?: InputMaybe<Scalars['Int']['input']>;
  sentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type LiveMessagesStddevFields = {
  __typename?: 'live_messages_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivityId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "live_messages" */
export type LiveMessagesStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type LiveMessagesStddevPopFields = {
  __typename?: 'live_messages_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivityId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "live_messages" */
export type LiveMessagesStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type LiveMessagesStddevSampFields = {
  __typename?: 'live_messages_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivityId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "live_messages" */
export type LiveMessagesStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "live_messages" */
export type LiveMessagesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: LiveMessagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LiveMessagesStreamCursorValueInput = {
  content?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  liveClassActivityId?: InputMaybe<Scalars['Int']['input']>;
  sentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type LiveMessagesSumFields = {
  __typename?: 'live_messages_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  liveClassActivityId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "live_messages" */
export type LiveMessagesSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** update columns of table "live_messages" */
export enum LiveMessagesUpdateColumn {
  /** column name */
  Content = 'content',
  /** column name */
  Id = 'id',
  /** column name */
  LiveClassActivityId = 'liveClassActivityId',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  UserId = 'userId'
}

export type LiveMessagesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LiveMessagesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LiveMessagesSetInput>;
  /** filter the rows which have to be updated */
  where: LiveMessagesBoolExp;
};

/** aggregate var_pop on columns */
export type LiveMessagesVarPopFields = {
  __typename?: 'live_messages_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivityId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "live_messages" */
export type LiveMessagesVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type LiveMessagesVarSampFields = {
  __typename?: 'live_messages_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivityId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "live_messages" */
export type LiveMessagesVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type LiveMessagesVarianceFields = {
  __typename?: 'live_messages_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivityId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "live_messages" */
export type LiveMessagesVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivityId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "matching_options" */
export type MatchingOptions = {
  __typename?: 'matching_options';
  created_by: Scalars['Int']['output'];
  firstColumn: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  matchingId: Scalars['Int']['output'];
  secondColumn: Scalars['String']['output'];
};

/** aggregated selection of "matching_options" */
export type MatchingOptionsAggregate = {
  __typename?: 'matching_options_aggregate';
  aggregate?: Maybe<MatchingOptionsAggregateFields>;
  nodes: Array<MatchingOptions>;
};

export type MatchingOptionsAggregateBoolExp = {
  count?: InputMaybe<MatchingOptionsAggregateBoolExpCount>;
};

export type MatchingOptionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MatchingOptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MatchingOptionsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "matching_options" */
export type MatchingOptionsAggregateFields = {
  __typename?: 'matching_options_aggregate_fields';
  avg?: Maybe<MatchingOptionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MatchingOptionsMaxFields>;
  min?: Maybe<MatchingOptionsMinFields>;
  stddev?: Maybe<MatchingOptionsStddevFields>;
  stddev_pop?: Maybe<MatchingOptionsStddevPopFields>;
  stddev_samp?: Maybe<MatchingOptionsStddevSampFields>;
  sum?: Maybe<MatchingOptionsSumFields>;
  var_pop?: Maybe<MatchingOptionsVarPopFields>;
  var_samp?: Maybe<MatchingOptionsVarSampFields>;
  variance?: Maybe<MatchingOptionsVarianceFields>;
};


/** aggregate fields of "matching_options" */
export type MatchingOptionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MatchingOptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "matching_options" */
export type MatchingOptionsAggregateOrderBy = {
  avg?: InputMaybe<MatchingOptionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MatchingOptionsMaxOrderBy>;
  min?: InputMaybe<MatchingOptionsMinOrderBy>;
  stddev?: InputMaybe<MatchingOptionsStddevOrderBy>;
  stddev_pop?: InputMaybe<MatchingOptionsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<MatchingOptionsStddevSampOrderBy>;
  sum?: InputMaybe<MatchingOptionsSumOrderBy>;
  var_pop?: InputMaybe<MatchingOptionsVarPopOrderBy>;
  var_samp?: InputMaybe<MatchingOptionsVarSampOrderBy>;
  variance?: InputMaybe<MatchingOptionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "matching_options" */
export type MatchingOptionsArrRelInsertInput = {
  data: Array<MatchingOptionsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<MatchingOptionsOnConflict>;
};

/** aggregate avg on columns */
export type MatchingOptionsAvgFields = {
  __typename?: 'matching_options_avg_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "matching_options" */
export type MatchingOptionsAvgOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "matching_options". All fields are combined with a logical 'AND'. */
export type MatchingOptionsBoolExp = {
  _and?: InputMaybe<Array<MatchingOptionsBoolExp>>;
  _not?: InputMaybe<MatchingOptionsBoolExp>;
  _or?: InputMaybe<Array<MatchingOptionsBoolExp>>;
  created_by?: InputMaybe<IntComparisonExp>;
  firstColumn?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  matchingId?: InputMaybe<IntComparisonExp>;
  secondColumn?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "matching_options" */
export enum MatchingOptionsConstraint {
  /** unique or primary key constraint on columns "id" */
  MatchingOptionsPkey = 'matching_options_pkey'
}

/** input type for incrementing numeric columns in table "matching_options" */
export type MatchingOptionsIncInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  matchingId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "matching_options" */
export type MatchingOptionsInsertInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  firstColumn?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  matchingId?: InputMaybe<Scalars['Int']['input']>;
  secondColumn?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type MatchingOptionsMaxFields = {
  __typename?: 'matching_options_max_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  firstColumn?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  matchingId?: Maybe<Scalars['Int']['output']>;
  secondColumn?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "matching_options" */
export type MatchingOptionsMaxOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  firstColumn?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
  secondColumn?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MatchingOptionsMinFields = {
  __typename?: 'matching_options_min_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  firstColumn?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  matchingId?: Maybe<Scalars['Int']['output']>;
  secondColumn?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "matching_options" */
export type MatchingOptionsMinOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  firstColumn?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
  secondColumn?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "matching_options" */
export type MatchingOptionsMutationResponse = {
  __typename?: 'matching_options_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MatchingOptions>;
};

/** on_conflict condition type for table "matching_options" */
export type MatchingOptionsOnConflict = {
  constraint: MatchingOptionsConstraint;
  update_columns?: Array<MatchingOptionsUpdateColumn>;
  where?: InputMaybe<MatchingOptionsBoolExp>;
};

/** Ordering options when selecting data from "matching_options". */
export type MatchingOptionsOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  firstColumn?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
  secondColumn?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: matching_options */
export type MatchingOptionsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "matching_options" */
export enum MatchingOptionsSelectColumn {
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  FirstColumn = 'firstColumn',
  /** column name */
  Id = 'id',
  /** column name */
  MatchingId = 'matchingId',
  /** column name */
  SecondColumn = 'secondColumn'
}

/** input type for updating data in table "matching_options" */
export type MatchingOptionsSetInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  firstColumn?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  matchingId?: InputMaybe<Scalars['Int']['input']>;
  secondColumn?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type MatchingOptionsStddevFields = {
  __typename?: 'matching_options_stddev_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "matching_options" */
export type MatchingOptionsStddevOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type MatchingOptionsStddevPopFields = {
  __typename?: 'matching_options_stddev_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "matching_options" */
export type MatchingOptionsStddevPopOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type MatchingOptionsStddevSampFields = {
  __typename?: 'matching_options_stddev_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "matching_options" */
export type MatchingOptionsStddevSampOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "matching_options" */
export type MatchingOptionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MatchingOptionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MatchingOptionsStreamCursorValueInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  firstColumn?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  matchingId?: InputMaybe<Scalars['Int']['input']>;
  secondColumn?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type MatchingOptionsSumFields = {
  __typename?: 'matching_options_sum_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  matchingId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "matching_options" */
export type MatchingOptionsSumOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** update columns of table "matching_options" */
export enum MatchingOptionsUpdateColumn {
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  FirstColumn = 'firstColumn',
  /** column name */
  Id = 'id',
  /** column name */
  MatchingId = 'matchingId',
  /** column name */
  SecondColumn = 'secondColumn'
}

export type MatchingOptionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MatchingOptionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MatchingOptionsSetInput>;
  /** filter the rows which have to be updated */
  where: MatchingOptionsBoolExp;
};

/** aggregate var_pop on columns */
export type MatchingOptionsVarPopFields = {
  __typename?: 'matching_options_var_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "matching_options" */
export type MatchingOptionsVarPopOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type MatchingOptionsVarSampFields = {
  __typename?: 'matching_options_var_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "matching_options" */
export type MatchingOptionsVarSampOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MatchingOptionsVarianceFields = {
  __typename?: 'matching_options_variance_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "matching_options" */
export type MatchingOptionsVarianceOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "matching_responses" */
export type MatchingResponses = {
  __typename?: 'matching_responses';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer: Scalars['String']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isCorrect: Scalars['Boolean']['output'];
  /** An object relationship */
  matching: Matchings;
  matchingId: Scalars['Int']['output'];
};

/** aggregated selection of "matching_responses" */
export type MatchingResponsesAggregate = {
  __typename?: 'matching_responses_aggregate';
  aggregate?: Maybe<MatchingResponsesAggregateFields>;
  nodes: Array<MatchingResponses>;
};

export type MatchingResponsesAggregateBoolExp = {
  bool_and?: InputMaybe<MatchingResponsesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<MatchingResponsesAggregateBoolExpBoolOr>;
  count?: InputMaybe<MatchingResponsesAggregateBoolExpCount>;
};

export type MatchingResponsesAggregateBoolExpBoolAnd = {
  arguments: MatchingResponsesSelectColumnMatchingResponsesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MatchingResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MatchingResponsesAggregateBoolExpBoolOr = {
  arguments: MatchingResponsesSelectColumnMatchingResponsesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MatchingResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MatchingResponsesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MatchingResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MatchingResponsesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "matching_responses" */
export type MatchingResponsesAggregateFields = {
  __typename?: 'matching_responses_aggregate_fields';
  avg?: Maybe<MatchingResponsesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MatchingResponsesMaxFields>;
  min?: Maybe<MatchingResponsesMinFields>;
  stddev?: Maybe<MatchingResponsesStddevFields>;
  stddev_pop?: Maybe<MatchingResponsesStddevPopFields>;
  stddev_samp?: Maybe<MatchingResponsesStddevSampFields>;
  sum?: Maybe<MatchingResponsesSumFields>;
  var_pop?: Maybe<MatchingResponsesVarPopFields>;
  var_samp?: Maybe<MatchingResponsesVarSampFields>;
  variance?: Maybe<MatchingResponsesVarianceFields>;
};


/** aggregate fields of "matching_responses" */
export type MatchingResponsesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MatchingResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "matching_responses" */
export type MatchingResponsesAggregateOrderBy = {
  avg?: InputMaybe<MatchingResponsesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MatchingResponsesMaxOrderBy>;
  min?: InputMaybe<MatchingResponsesMinOrderBy>;
  stddev?: InputMaybe<MatchingResponsesStddevOrderBy>;
  stddev_pop?: InputMaybe<MatchingResponsesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<MatchingResponsesStddevSampOrderBy>;
  sum?: InputMaybe<MatchingResponsesSumOrderBy>;
  var_pop?: InputMaybe<MatchingResponsesVarPopOrderBy>;
  var_samp?: InputMaybe<MatchingResponsesVarSampOrderBy>;
  variance?: InputMaybe<MatchingResponsesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "matching_responses" */
export type MatchingResponsesArrRelInsertInput = {
  data: Array<MatchingResponsesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<MatchingResponsesOnConflict>;
};

/** aggregate avg on columns */
export type MatchingResponsesAvgFields = {
  __typename?: 'matching_responses_avg_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "matching_responses" */
export type MatchingResponsesAvgOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "matching_responses". All fields are combined with a logical 'AND'. */
export type MatchingResponsesBoolExp = {
  _and?: InputMaybe<Array<MatchingResponsesBoolExp>>;
  _not?: InputMaybe<MatchingResponsesBoolExp>;
  _or?: InputMaybe<Array<MatchingResponsesBoolExp>>;
  activitySetResponseId?: InputMaybe<IntComparisonExp>;
  answer?: InputMaybe<StringComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isCorrect?: InputMaybe<BooleanComparisonExp>;
  matching?: InputMaybe<MatchingsBoolExp>;
  matchingId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "matching_responses" */
export enum MatchingResponsesConstraint {
  /** unique or primary key constraint on columns "id" */
  MatchingResponsesPkey = 'matching_responses_pkey'
}

/** input type for incrementing numeric columns in table "matching_responses" */
export type MatchingResponsesIncInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  matchingId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "matching_responses" */
export type MatchingResponsesInsertInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  matching?: InputMaybe<MatchingsObjRelInsertInput>;
  matchingId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type MatchingResponsesMaxFields = {
  __typename?: 'matching_responses_max_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  matchingId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "matching_responses" */
export type MatchingResponsesMaxOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MatchingResponsesMinFields = {
  __typename?: 'matching_responses_min_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  matchingId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "matching_responses" */
export type MatchingResponsesMinOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "matching_responses" */
export type MatchingResponsesMutationResponse = {
  __typename?: 'matching_responses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MatchingResponses>;
};

/** on_conflict condition type for table "matching_responses" */
export type MatchingResponsesOnConflict = {
  constraint: MatchingResponsesConstraint;
  update_columns?: Array<MatchingResponsesUpdateColumn>;
  where?: InputMaybe<MatchingResponsesBoolExp>;
};

/** Ordering options when selecting data from "matching_responses". */
export type MatchingResponsesOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCorrect?: InputMaybe<OrderBy>;
  matching?: InputMaybe<MatchingsOrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: matching_responses */
export type MatchingResponsesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "matching_responses" */
export enum MatchingResponsesSelectColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  MatchingId = 'matchingId'
}

/** select "matching_responses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "matching_responses" */
export enum MatchingResponsesSelectColumnMatchingResponsesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** select "matching_responses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "matching_responses" */
export enum MatchingResponsesSelectColumnMatchingResponsesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** input type for updating data in table "matching_responses" */
export type MatchingResponsesSetInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  matchingId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type MatchingResponsesStddevFields = {
  __typename?: 'matching_responses_stddev_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "matching_responses" */
export type MatchingResponsesStddevOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type MatchingResponsesStddevPopFields = {
  __typename?: 'matching_responses_stddev_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "matching_responses" */
export type MatchingResponsesStddevPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type MatchingResponsesStddevSampFields = {
  __typename?: 'matching_responses_stddev_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "matching_responses" */
export type MatchingResponsesStddevSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "matching_responses" */
export type MatchingResponsesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MatchingResponsesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MatchingResponsesStreamCursorValueInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  matchingId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type MatchingResponsesSumFields = {
  __typename?: 'matching_responses_sum_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  matchingId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "matching_responses" */
export type MatchingResponsesSumOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** update columns of table "matching_responses" */
export enum MatchingResponsesUpdateColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  MatchingId = 'matchingId'
}

export type MatchingResponsesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MatchingResponsesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MatchingResponsesSetInput>;
  /** filter the rows which have to be updated */
  where: MatchingResponsesBoolExp;
};

/** aggregate var_pop on columns */
export type MatchingResponsesVarPopFields = {
  __typename?: 'matching_responses_var_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "matching_responses" */
export type MatchingResponsesVarPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type MatchingResponsesVarSampFields = {
  __typename?: 'matching_responses_var_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "matching_responses" */
export type MatchingResponsesVarSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MatchingResponsesVarianceFields = {
  __typename?: 'matching_responses_variance_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  matchingId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "matching_responses" */
export type MatchingResponsesVarianceOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "matchings" */
export type Matchings = {
  __typename?: 'matchings';
  activitySetId: Scalars['Int']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** An array relationship */
  matchingOptions: Array<MatchingOptions>;
  /** An aggregate relationship */
  matchingOptions_aggregate: MatchingOptionsAggregate;
  order: Scalars['Int']['output'];
  text?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "matchings" */
export type MatchingsMatchingOptionsArgs = {
  distinct_on?: InputMaybe<Array<MatchingOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingOptionsOrderBy>>;
  where?: InputMaybe<MatchingOptionsBoolExp>;
};


/** columns and relationships of "matchings" */
export type MatchingsMatchingOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingOptionsOrderBy>>;
  where?: InputMaybe<MatchingOptionsBoolExp>;
};

/** aggregated selection of "matchings" */
export type MatchingsAggregate = {
  __typename?: 'matchings_aggregate';
  aggregate?: Maybe<MatchingsAggregateFields>;
  nodes: Array<Matchings>;
};

export type MatchingsAggregateBoolExp = {
  count?: InputMaybe<MatchingsAggregateBoolExpCount>;
};

export type MatchingsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MatchingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MatchingsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "matchings" */
export type MatchingsAggregateFields = {
  __typename?: 'matchings_aggregate_fields';
  avg?: Maybe<MatchingsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MatchingsMaxFields>;
  min?: Maybe<MatchingsMinFields>;
  stddev?: Maybe<MatchingsStddevFields>;
  stddev_pop?: Maybe<MatchingsStddevPopFields>;
  stddev_samp?: Maybe<MatchingsStddevSampFields>;
  sum?: Maybe<MatchingsSumFields>;
  var_pop?: Maybe<MatchingsVarPopFields>;
  var_samp?: Maybe<MatchingsVarSampFields>;
  variance?: Maybe<MatchingsVarianceFields>;
};


/** aggregate fields of "matchings" */
export type MatchingsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MatchingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "matchings" */
export type MatchingsAggregateOrderBy = {
  avg?: InputMaybe<MatchingsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MatchingsMaxOrderBy>;
  min?: InputMaybe<MatchingsMinOrderBy>;
  stddev?: InputMaybe<MatchingsStddevOrderBy>;
  stddev_pop?: InputMaybe<MatchingsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<MatchingsStddevSampOrderBy>;
  sum?: InputMaybe<MatchingsSumOrderBy>;
  var_pop?: InputMaybe<MatchingsVarPopOrderBy>;
  var_samp?: InputMaybe<MatchingsVarSampOrderBy>;
  variance?: InputMaybe<MatchingsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "matchings" */
export type MatchingsArrRelInsertInput = {
  data: Array<MatchingsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<MatchingsOnConflict>;
};

/** aggregate avg on columns */
export type MatchingsAvgFields = {
  __typename?: 'matchings_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "matchings" */
export type MatchingsAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "matchings". All fields are combined with a logical 'AND'. */
export type MatchingsBoolExp = {
  _and?: InputMaybe<Array<MatchingsBoolExp>>;
  _not?: InputMaybe<MatchingsBoolExp>;
  _or?: InputMaybe<Array<MatchingsBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  matchingOptions?: InputMaybe<MatchingOptionsBoolExp>;
  matchingOptions_aggregate?: InputMaybe<MatchingOptionsAggregateBoolExp>;
  order?: InputMaybe<IntComparisonExp>;
  text?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "matchings" */
export enum MatchingsConstraint {
  /** unique or primary key constraint on columns "id" */
  MatchingsPkey = 'matchings_pkey'
}

/** input type for incrementing numeric columns in table "matchings" */
export type MatchingsIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "matchings" */
export type MatchingsInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  matchingOptions?: InputMaybe<MatchingOptionsArrRelInsertInput>;
  order?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type MatchingsMaxFields = {
  __typename?: 'matchings_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "matchings" */
export type MatchingsMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  text?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MatchingsMinFields = {
  __typename?: 'matchings_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "matchings" */
export type MatchingsMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  text?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "matchings" */
export type MatchingsMutationResponse = {
  __typename?: 'matchings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Matchings>;
};

/** input type for inserting object relation for remote table "matchings" */
export type MatchingsObjRelInsertInput = {
  data: MatchingsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<MatchingsOnConflict>;
};

/** on_conflict condition type for table "matchings" */
export type MatchingsOnConflict = {
  constraint: MatchingsConstraint;
  update_columns?: Array<MatchingsUpdateColumn>;
  where?: InputMaybe<MatchingsBoolExp>;
};

/** Ordering options when selecting data from "matchings". */
export type MatchingsOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  matchingOptions_aggregate?: InputMaybe<MatchingOptionsAggregateOrderBy>;
  order?: InputMaybe<OrderBy>;
  text?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: matchings */
export type MatchingsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "matchings" */
export enum MatchingsSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  Order = 'order',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "matchings" */
export type MatchingsSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type MatchingsStddevFields = {
  __typename?: 'matchings_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "matchings" */
export type MatchingsStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type MatchingsStddevPopFields = {
  __typename?: 'matchings_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "matchings" */
export type MatchingsStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type MatchingsStddevSampFields = {
  __typename?: 'matchings_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "matchings" */
export type MatchingsStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "matchings" */
export type MatchingsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MatchingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MatchingsStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type MatchingsSumFields = {
  __typename?: 'matchings_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "matchings" */
export type MatchingsSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** update columns of table "matchings" */
export enum MatchingsUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  Order = 'order',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type MatchingsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MatchingsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MatchingsSetInput>;
  /** filter the rows which have to be updated */
  where: MatchingsBoolExp;
};

/** aggregate var_pop on columns */
export type MatchingsVarPopFields = {
  __typename?: 'matchings_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "matchings" */
export type MatchingsVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type MatchingsVarSampFields = {
  __typename?: 'matchings_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "matchings" */
export type MatchingsVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MatchingsVarianceFields = {
  __typename?: 'matchings_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "matchings" */
export type MatchingsVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** columns and relationships of "messages" */
export type Messages = {
  __typename?: 'messages';
  /** An object relationship */
  conversation: UserMessages;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  message: Scalars['String']['output'];
  userMessagesId: Scalars['Int']['output'];
};

/** aggregated selection of "messages" */
export type MessagesAggregate = {
  __typename?: 'messages_aggregate';
  aggregate?: Maybe<MessagesAggregateFields>;
  nodes: Array<Messages>;
};

export type MessagesAggregateBoolExp = {
  count?: InputMaybe<MessagesAggregateBoolExpCount>;
};

export type MessagesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MessagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "messages" */
export type MessagesAggregateFields = {
  __typename?: 'messages_aggregate_fields';
  avg?: Maybe<MessagesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MessagesMaxFields>;
  min?: Maybe<MessagesMinFields>;
  stddev?: Maybe<MessagesStddevFields>;
  stddev_pop?: Maybe<MessagesStddevPopFields>;
  stddev_samp?: Maybe<MessagesStddevSampFields>;
  sum?: Maybe<MessagesSumFields>;
  var_pop?: Maybe<MessagesVarPopFields>;
  var_samp?: Maybe<MessagesVarSampFields>;
  variance?: Maybe<MessagesVarianceFields>;
};


/** aggregate fields of "messages" */
export type MessagesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MessagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "messages" */
export type MessagesAggregateOrderBy = {
  avg?: InputMaybe<MessagesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MessagesMaxOrderBy>;
  min?: InputMaybe<MessagesMinOrderBy>;
  stddev?: InputMaybe<MessagesStddevOrderBy>;
  stddev_pop?: InputMaybe<MessagesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<MessagesStddevSampOrderBy>;
  sum?: InputMaybe<MessagesSumOrderBy>;
  var_pop?: InputMaybe<MessagesVarPopOrderBy>;
  var_samp?: InputMaybe<MessagesVarSampOrderBy>;
  variance?: InputMaybe<MessagesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "messages" */
export type MessagesArrRelInsertInput = {
  data: Array<MessagesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<MessagesOnConflict>;
};

/** aggregate avg on columns */
export type MessagesAvgFields = {
  __typename?: 'messages_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  userMessagesId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "messages" */
export type MessagesAvgOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "messages". All fields are combined with a logical 'AND'. */
export type MessagesBoolExp = {
  _and?: InputMaybe<Array<MessagesBoolExp>>;
  _not?: InputMaybe<MessagesBoolExp>;
  _or?: InputMaybe<Array<MessagesBoolExp>>;
  conversation?: InputMaybe<UserMessagesBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  message?: InputMaybe<StringComparisonExp>;
  userMessagesId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "messages" */
export enum MessagesConstraint {
  /** unique or primary key constraint on columns "id" */
  MessagesPkey = 'messages_pkey'
}

/** input type for incrementing numeric columns in table "messages" */
export type MessagesIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userMessagesId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "messages" */
export type MessagesInsertInput = {
  conversation?: InputMaybe<UserMessagesObjRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  userMessagesId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type MessagesMaxFields = {
  __typename?: 'messages_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  userMessagesId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "messages" */
export type MessagesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  message?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MessagesMinFields = {
  __typename?: 'messages_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  userMessagesId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "messages" */
export type MessagesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  message?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "messages" */
export type MessagesMutationResponse = {
  __typename?: 'messages_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Messages>;
};

/** on_conflict condition type for table "messages" */
export type MessagesOnConflict = {
  constraint: MessagesConstraint;
  update_columns?: Array<MessagesUpdateColumn>;
  where?: InputMaybe<MessagesBoolExp>;
};

/** Ordering options when selecting data from "messages". */
export type MessagesOrderBy = {
  conversation?: InputMaybe<UserMessagesOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  message?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: messages */
export type MessagesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "messages" */
export enum MessagesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  UserMessagesId = 'userMessagesId'
}

/** input type for updating data in table "messages" */
export type MessagesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  userMessagesId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type MessagesStddevFields = {
  __typename?: 'messages_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  userMessagesId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "messages" */
export type MessagesStddevOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type MessagesStddevPopFields = {
  __typename?: 'messages_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  userMessagesId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "messages" */
export type MessagesStddevPopOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type MessagesStddevSampFields = {
  __typename?: 'messages_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  userMessagesId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "messages" */
export type MessagesStddevSampOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "messages" */
export type MessagesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MessagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MessagesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  userMessagesId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type MessagesSumFields = {
  __typename?: 'messages_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  userMessagesId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "messages" */
export type MessagesSumOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** update columns of table "messages" */
export enum MessagesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  UserMessagesId = 'userMessagesId'
}

export type MessagesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MessagesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MessagesSetInput>;
  /** filter the rows which have to be updated */
  where: MessagesBoolExp;
};

/** aggregate var_pop on columns */
export type MessagesVarPopFields = {
  __typename?: 'messages_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  userMessagesId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "messages" */
export type MessagesVarPopOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type MessagesVarSampFields = {
  __typename?: 'messages_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  userMessagesId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "messages" */
export type MessagesVarSampOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MessagesVarianceFields = {
  __typename?: 'messages_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  userMessagesId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "messages" */
export type MessagesVarianceOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  userMessagesId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "multiple_choice_options" */
export type MultipleChoiceOptions = {
  __typename?: 'multiple_choice_options';
  createdAt: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  isCorrectAnswer: Scalars['Boolean']['output'];
  multipleChoiceId: Scalars['Int']['output'];
  option: Scalars['String']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "multiple_choice_options" */
export type MultipleChoiceOptionsAggregate = {
  __typename?: 'multiple_choice_options_aggregate';
  aggregate?: Maybe<MultipleChoiceOptionsAggregateFields>;
  nodes: Array<MultipleChoiceOptions>;
};

export type MultipleChoiceOptionsAggregateBoolExp = {
  bool_and?: InputMaybe<MultipleChoiceOptionsAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<MultipleChoiceOptionsAggregateBoolExpBoolOr>;
  count?: InputMaybe<MultipleChoiceOptionsAggregateBoolExpCount>;
};

export type MultipleChoiceOptionsAggregateBoolExpBoolAnd = {
  arguments: MultipleChoiceOptionsSelectColumnMultipleChoiceOptionsAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoiceOptionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MultipleChoiceOptionsAggregateBoolExpBoolOr = {
  arguments: MultipleChoiceOptionsSelectColumnMultipleChoiceOptionsAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoiceOptionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MultipleChoiceOptionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MultipleChoiceOptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoiceOptionsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "multiple_choice_options" */
export type MultipleChoiceOptionsAggregateFields = {
  __typename?: 'multiple_choice_options_aggregate_fields';
  avg?: Maybe<MultipleChoiceOptionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MultipleChoiceOptionsMaxFields>;
  min?: Maybe<MultipleChoiceOptionsMinFields>;
  stddev?: Maybe<MultipleChoiceOptionsStddevFields>;
  stddev_pop?: Maybe<MultipleChoiceOptionsStddevPopFields>;
  stddev_samp?: Maybe<MultipleChoiceOptionsStddevSampFields>;
  sum?: Maybe<MultipleChoiceOptionsSumFields>;
  var_pop?: Maybe<MultipleChoiceOptionsVarPopFields>;
  var_samp?: Maybe<MultipleChoiceOptionsVarSampFields>;
  variance?: Maybe<MultipleChoiceOptionsVarianceFields>;
};


/** aggregate fields of "multiple_choice_options" */
export type MultipleChoiceOptionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MultipleChoiceOptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "multiple_choice_options" */
export type MultipleChoiceOptionsAggregateOrderBy = {
  avg?: InputMaybe<MultipleChoiceOptionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MultipleChoiceOptionsMaxOrderBy>;
  min?: InputMaybe<MultipleChoiceOptionsMinOrderBy>;
  stddev?: InputMaybe<MultipleChoiceOptionsStddevOrderBy>;
  stddev_pop?: InputMaybe<MultipleChoiceOptionsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<MultipleChoiceOptionsStddevSampOrderBy>;
  sum?: InputMaybe<MultipleChoiceOptionsSumOrderBy>;
  var_pop?: InputMaybe<MultipleChoiceOptionsVarPopOrderBy>;
  var_samp?: InputMaybe<MultipleChoiceOptionsVarSampOrderBy>;
  variance?: InputMaybe<MultipleChoiceOptionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "multiple_choice_options" */
export type MultipleChoiceOptionsArrRelInsertInput = {
  data: Array<MultipleChoiceOptionsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<MultipleChoiceOptionsOnConflict>;
};

/** aggregate avg on columns */
export type MultipleChoiceOptionsAvgFields = {
  __typename?: 'multiple_choice_options_avg_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsAvgOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "multiple_choice_options". All fields are combined with a logical 'AND'. */
export type MultipleChoiceOptionsBoolExp = {
  _and?: InputMaybe<Array<MultipleChoiceOptionsBoolExp>>;
  _not?: InputMaybe<MultipleChoiceOptionsBoolExp>;
  _or?: InputMaybe<Array<MultipleChoiceOptionsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  created_by?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isCorrectAnswer?: InputMaybe<BooleanComparisonExp>;
  multipleChoiceId?: InputMaybe<IntComparisonExp>;
  option?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "multiple_choice_options" */
export enum MultipleChoiceOptionsConstraint {
  /** unique or primary key constraint on columns "id" */
  MultipleChoiceOptionsPkey = 'multiple_choice_options_pkey'
}

/** input type for incrementing numeric columns in table "multiple_choice_options" */
export type MultipleChoiceOptionsIncInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  multipleChoiceId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "multiple_choice_options" */
export type MultipleChoiceOptionsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrectAnswer?: InputMaybe<Scalars['Boolean']['input']>;
  multipleChoiceId?: InputMaybe<Scalars['Int']['input']>;
  option?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type MultipleChoiceOptionsMaxFields = {
  __typename?: 'multiple_choice_options_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  multipleChoiceId?: Maybe<Scalars['Int']['output']>;
  option?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
  option?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MultipleChoiceOptionsMinFields = {
  __typename?: 'multiple_choice_options_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  multipleChoiceId?: Maybe<Scalars['Int']['output']>;
  option?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
  option?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "multiple_choice_options" */
export type MultipleChoiceOptionsMutationResponse = {
  __typename?: 'multiple_choice_options_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MultipleChoiceOptions>;
};

/** on_conflict condition type for table "multiple_choice_options" */
export type MultipleChoiceOptionsOnConflict = {
  constraint: MultipleChoiceOptionsConstraint;
  update_columns?: Array<MultipleChoiceOptionsUpdateColumn>;
  where?: InputMaybe<MultipleChoiceOptionsBoolExp>;
};

/** Ordering options when selecting data from "multiple_choice_options". */
export type MultipleChoiceOptionsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCorrectAnswer?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
  option?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: multiple_choice_options */
export type MultipleChoiceOptionsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "multiple_choice_options" */
export enum MultipleChoiceOptionsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrectAnswer = 'isCorrectAnswer',
  /** column name */
  MultipleChoiceId = 'multipleChoiceId',
  /** column name */
  Option = 'option',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "multiple_choice_options_aggregate_bool_exp_bool_and_arguments_columns" columns of table "multiple_choice_options" */
export enum MultipleChoiceOptionsSelectColumnMultipleChoiceOptionsAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsCorrectAnswer = 'isCorrectAnswer'
}

/** select "multiple_choice_options_aggregate_bool_exp_bool_or_arguments_columns" columns of table "multiple_choice_options" */
export enum MultipleChoiceOptionsSelectColumnMultipleChoiceOptionsAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsCorrectAnswer = 'isCorrectAnswer'
}

/** input type for updating data in table "multiple_choice_options" */
export type MultipleChoiceOptionsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrectAnswer?: InputMaybe<Scalars['Boolean']['input']>;
  multipleChoiceId?: InputMaybe<Scalars['Int']['input']>;
  option?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type MultipleChoiceOptionsStddevFields = {
  __typename?: 'multiple_choice_options_stddev_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsStddevOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type MultipleChoiceOptionsStddevPopFields = {
  __typename?: 'multiple_choice_options_stddev_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsStddevPopOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type MultipleChoiceOptionsStddevSampFields = {
  __typename?: 'multiple_choice_options_stddev_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsStddevSampOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "multiple_choice_options" */
export type MultipleChoiceOptionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MultipleChoiceOptionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MultipleChoiceOptionsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrectAnswer?: InputMaybe<Scalars['Boolean']['input']>;
  multipleChoiceId?: InputMaybe<Scalars['Int']['input']>;
  option?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type MultipleChoiceOptionsSumFields = {
  __typename?: 'multiple_choice_options_sum_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  multipleChoiceId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsSumOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** update columns of table "multiple_choice_options" */
export enum MultipleChoiceOptionsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrectAnswer = 'isCorrectAnswer',
  /** column name */
  MultipleChoiceId = 'multipleChoiceId',
  /** column name */
  Option = 'option',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type MultipleChoiceOptionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MultipleChoiceOptionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MultipleChoiceOptionsSetInput>;
  /** filter the rows which have to be updated */
  where: MultipleChoiceOptionsBoolExp;
};

/** aggregate var_pop on columns */
export type MultipleChoiceOptionsVarPopFields = {
  __typename?: 'multiple_choice_options_var_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsVarPopOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type MultipleChoiceOptionsVarSampFields = {
  __typename?: 'multiple_choice_options_var_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsVarSampOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MultipleChoiceOptionsVarianceFields = {
  __typename?: 'multiple_choice_options_variance_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "multiple_choice_options" */
export type MultipleChoiceOptionsVarianceOrderBy = {
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "multiple_choice_responses" */
export type MultipleChoiceResponses = {
  __typename?: 'multiple_choice_responses';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  created_by: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isCorrect?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  multipleChoice: MultipleChoices;
  multipleChoiceId: Scalars['Int']['output'];
};

/** aggregated selection of "multiple_choice_responses" */
export type MultipleChoiceResponsesAggregate = {
  __typename?: 'multiple_choice_responses_aggregate';
  aggregate?: Maybe<MultipleChoiceResponsesAggregateFields>;
  nodes: Array<MultipleChoiceResponses>;
};

export type MultipleChoiceResponsesAggregateBoolExp = {
  bool_and?: InputMaybe<MultipleChoiceResponsesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<MultipleChoiceResponsesAggregateBoolExpBoolOr>;
  count?: InputMaybe<MultipleChoiceResponsesAggregateBoolExpCount>;
};

export type MultipleChoiceResponsesAggregateBoolExpBoolAnd = {
  arguments: MultipleChoiceResponsesSelectColumnMultipleChoiceResponsesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoiceResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MultipleChoiceResponsesAggregateBoolExpBoolOr = {
  arguments: MultipleChoiceResponsesSelectColumnMultipleChoiceResponsesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoiceResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MultipleChoiceResponsesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MultipleChoiceResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoiceResponsesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "multiple_choice_responses" */
export type MultipleChoiceResponsesAggregateFields = {
  __typename?: 'multiple_choice_responses_aggregate_fields';
  avg?: Maybe<MultipleChoiceResponsesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MultipleChoiceResponsesMaxFields>;
  min?: Maybe<MultipleChoiceResponsesMinFields>;
  stddev?: Maybe<MultipleChoiceResponsesStddevFields>;
  stddev_pop?: Maybe<MultipleChoiceResponsesStddevPopFields>;
  stddev_samp?: Maybe<MultipleChoiceResponsesStddevSampFields>;
  sum?: Maybe<MultipleChoiceResponsesSumFields>;
  var_pop?: Maybe<MultipleChoiceResponsesVarPopFields>;
  var_samp?: Maybe<MultipleChoiceResponsesVarSampFields>;
  variance?: Maybe<MultipleChoiceResponsesVarianceFields>;
};


/** aggregate fields of "multiple_choice_responses" */
export type MultipleChoiceResponsesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MultipleChoiceResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "multiple_choice_responses" */
export type MultipleChoiceResponsesAggregateOrderBy = {
  avg?: InputMaybe<MultipleChoiceResponsesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MultipleChoiceResponsesMaxOrderBy>;
  min?: InputMaybe<MultipleChoiceResponsesMinOrderBy>;
  stddev?: InputMaybe<MultipleChoiceResponsesStddevOrderBy>;
  stddev_pop?: InputMaybe<MultipleChoiceResponsesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<MultipleChoiceResponsesStddevSampOrderBy>;
  sum?: InputMaybe<MultipleChoiceResponsesSumOrderBy>;
  var_pop?: InputMaybe<MultipleChoiceResponsesVarPopOrderBy>;
  var_samp?: InputMaybe<MultipleChoiceResponsesVarSampOrderBy>;
  variance?: InputMaybe<MultipleChoiceResponsesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "multiple_choice_responses" */
export type MultipleChoiceResponsesArrRelInsertInput = {
  data: Array<MultipleChoiceResponsesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<MultipleChoiceResponsesOnConflict>;
};

/** aggregate avg on columns */
export type MultipleChoiceResponsesAvgFields = {
  __typename?: 'multiple_choice_responses_avg_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesAvgOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "multiple_choice_responses". All fields are combined with a logical 'AND'. */
export type MultipleChoiceResponsesBoolExp = {
  _and?: InputMaybe<Array<MultipleChoiceResponsesBoolExp>>;
  _not?: InputMaybe<MultipleChoiceResponsesBoolExp>;
  _or?: InputMaybe<Array<MultipleChoiceResponsesBoolExp>>;
  activitySetResponseId?: InputMaybe<IntComparisonExp>;
  answer?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  created_by?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isCorrect?: InputMaybe<BooleanComparisonExp>;
  multipleChoice?: InputMaybe<MultipleChoicesBoolExp>;
  multipleChoiceId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "multiple_choice_responses" */
export enum MultipleChoiceResponsesConstraint {
  /** unique or primary key constraint on columns "id" */
  MultipleChoiceResponsesPkey = 'multiple_choice_responses_pkey'
}

/** input type for incrementing numeric columns in table "multiple_choice_responses" */
export type MultipleChoiceResponsesIncInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  multipleChoiceId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "multiple_choice_responses" */
export type MultipleChoiceResponsesInsertInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  multipleChoice?: InputMaybe<MultipleChoicesObjRelInsertInput>;
  multipleChoiceId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type MultipleChoiceResponsesMaxFields = {
  __typename?: 'multiple_choice_responses_max_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  multipleChoiceId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesMaxOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MultipleChoiceResponsesMinFields = {
  __typename?: 'multiple_choice_responses_min_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  multipleChoiceId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesMinOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "multiple_choice_responses" */
export type MultipleChoiceResponsesMutationResponse = {
  __typename?: 'multiple_choice_responses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MultipleChoiceResponses>;
};

/** on_conflict condition type for table "multiple_choice_responses" */
export type MultipleChoiceResponsesOnConflict = {
  constraint: MultipleChoiceResponsesConstraint;
  update_columns?: Array<MultipleChoiceResponsesUpdateColumn>;
  where?: InputMaybe<MultipleChoiceResponsesBoolExp>;
};

/** Ordering options when selecting data from "multiple_choice_responses". */
export type MultipleChoiceResponsesOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCorrect?: InputMaybe<OrderBy>;
  multipleChoice?: InputMaybe<MultipleChoicesOrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: multiple_choice_responses */
export type MultipleChoiceResponsesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "multiple_choice_responses" */
export enum MultipleChoiceResponsesSelectColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  MultipleChoiceId = 'multipleChoiceId'
}

/** select "multiple_choice_responses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "multiple_choice_responses" */
export enum MultipleChoiceResponsesSelectColumnMultipleChoiceResponsesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** select "multiple_choice_responses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "multiple_choice_responses" */
export enum MultipleChoiceResponsesSelectColumnMultipleChoiceResponsesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** input type for updating data in table "multiple_choice_responses" */
export type MultipleChoiceResponsesSetInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  multipleChoiceId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type MultipleChoiceResponsesStddevFields = {
  __typename?: 'multiple_choice_responses_stddev_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesStddevOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type MultipleChoiceResponsesStddevPopFields = {
  __typename?: 'multiple_choice_responses_stddev_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesStddevPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type MultipleChoiceResponsesStddevSampFields = {
  __typename?: 'multiple_choice_responses_stddev_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesStddevSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "multiple_choice_responses" */
export type MultipleChoiceResponsesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MultipleChoiceResponsesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MultipleChoiceResponsesStreamCursorValueInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  multipleChoiceId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type MultipleChoiceResponsesSumFields = {
  __typename?: 'multiple_choice_responses_sum_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  multipleChoiceId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesSumOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** update columns of table "multiple_choice_responses" */
export enum MultipleChoiceResponsesUpdateColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  MultipleChoiceId = 'multipleChoiceId'
}

export type MultipleChoiceResponsesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MultipleChoiceResponsesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MultipleChoiceResponsesSetInput>;
  /** filter the rows which have to be updated */
  where: MultipleChoiceResponsesBoolExp;
};

/** aggregate var_pop on columns */
export type MultipleChoiceResponsesVarPopFields = {
  __typename?: 'multiple_choice_responses_var_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesVarPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type MultipleChoiceResponsesVarSampFields = {
  __typename?: 'multiple_choice_responses_var_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesVarSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MultipleChoiceResponsesVarianceFields = {
  __typename?: 'multiple_choice_responses_variance_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  multipleChoiceId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "multiple_choice_responses" */
export type MultipleChoiceResponsesVarianceOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multipleChoiceId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "multiple_choices" */
export type MultipleChoices = {
  __typename?: 'multiple_choices';
  activitySetId: Scalars['Int']['output'];
  audioUrl?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  explanation?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** An object relationship */
  image?: Maybe<Images>;
  imageId?: Maybe<Scalars['Int']['output']>;
  isMultiSelect: Scalars['Boolean']['output'];
  /** An array relationship */
  multipleChoiceOptions: Array<MultipleChoiceOptions>;
  /** An aggregate relationship */
  multipleChoiceOptions_aggregate: MultipleChoiceOptionsAggregate;
  order: Scalars['Int']['output'];
  prompt: Scalars['String']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "multiple_choices" */
export type MultipleChoicesMultipleChoiceOptionsArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceOptionsOrderBy>>;
  where?: InputMaybe<MultipleChoiceOptionsBoolExp>;
};


/** columns and relationships of "multiple_choices" */
export type MultipleChoicesMultipleChoiceOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceOptionsOrderBy>>;
  where?: InputMaybe<MultipleChoiceOptionsBoolExp>;
};

/** aggregated selection of "multiple_choices" */
export type MultipleChoicesAggregate = {
  __typename?: 'multiple_choices_aggregate';
  aggregate?: Maybe<MultipleChoicesAggregateFields>;
  nodes: Array<MultipleChoices>;
};

export type MultipleChoicesAggregateBoolExp = {
  bool_and?: InputMaybe<MultipleChoicesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<MultipleChoicesAggregateBoolExpBoolOr>;
  count?: InputMaybe<MultipleChoicesAggregateBoolExpCount>;
};

export type MultipleChoicesAggregateBoolExpBoolAnd = {
  arguments: MultipleChoicesSelectColumnMultipleChoicesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoicesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MultipleChoicesAggregateBoolExpBoolOr = {
  arguments: MultipleChoicesSelectColumnMultipleChoicesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoicesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MultipleChoicesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MultipleChoicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MultipleChoicesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "multiple_choices" */
export type MultipleChoicesAggregateFields = {
  __typename?: 'multiple_choices_aggregate_fields';
  avg?: Maybe<MultipleChoicesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MultipleChoicesMaxFields>;
  min?: Maybe<MultipleChoicesMinFields>;
  stddev?: Maybe<MultipleChoicesStddevFields>;
  stddev_pop?: Maybe<MultipleChoicesStddevPopFields>;
  stddev_samp?: Maybe<MultipleChoicesStddevSampFields>;
  sum?: Maybe<MultipleChoicesSumFields>;
  var_pop?: Maybe<MultipleChoicesVarPopFields>;
  var_samp?: Maybe<MultipleChoicesVarSampFields>;
  variance?: Maybe<MultipleChoicesVarianceFields>;
};


/** aggregate fields of "multiple_choices" */
export type MultipleChoicesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MultipleChoicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "multiple_choices" */
export type MultipleChoicesAggregateOrderBy = {
  avg?: InputMaybe<MultipleChoicesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MultipleChoicesMaxOrderBy>;
  min?: InputMaybe<MultipleChoicesMinOrderBy>;
  stddev?: InputMaybe<MultipleChoicesStddevOrderBy>;
  stddev_pop?: InputMaybe<MultipleChoicesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<MultipleChoicesStddevSampOrderBy>;
  sum?: InputMaybe<MultipleChoicesSumOrderBy>;
  var_pop?: InputMaybe<MultipleChoicesVarPopOrderBy>;
  var_samp?: InputMaybe<MultipleChoicesVarSampOrderBy>;
  variance?: InputMaybe<MultipleChoicesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "multiple_choices" */
export type MultipleChoicesArrRelInsertInput = {
  data: Array<MultipleChoicesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<MultipleChoicesOnConflict>;
};

/** aggregate avg on columns */
export type MultipleChoicesAvgFields = {
  __typename?: 'multiple_choices_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "multiple_choices" */
export type MultipleChoicesAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "multiple_choices". All fields are combined with a logical 'AND'. */
export type MultipleChoicesBoolExp = {
  _and?: InputMaybe<Array<MultipleChoicesBoolExp>>;
  _not?: InputMaybe<MultipleChoicesBoolExp>;
  _or?: InputMaybe<Array<MultipleChoicesBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  audioUrl?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  explanation?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  image?: InputMaybe<ImagesBoolExp>;
  imageId?: InputMaybe<IntComparisonExp>;
  isMultiSelect?: InputMaybe<BooleanComparisonExp>;
  multipleChoiceOptions?: InputMaybe<MultipleChoiceOptionsBoolExp>;
  multipleChoiceOptions_aggregate?: InputMaybe<MultipleChoiceOptionsAggregateBoolExp>;
  order?: InputMaybe<IntComparisonExp>;
  prompt?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "multiple_choices" */
export enum MultipleChoicesConstraint {
  /** unique or primary key constraint on columns "id" */
  MultipleChoicesPkey = 'multiple_choices_pkey'
}

/** input type for incrementing numeric columns in table "multiple_choices" */
export type MultipleChoicesIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "multiple_choices" */
export type MultipleChoicesInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  explanation?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<ImagesObjRelInsertInput>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isMultiSelect?: InputMaybe<Scalars['Boolean']['input']>;
  multipleChoiceOptions?: InputMaybe<MultipleChoiceOptionsArrRelInsertInput>;
  order?: InputMaybe<Scalars['Int']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type MultipleChoicesMaxFields = {
  __typename?: 'multiple_choices_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  audioUrl?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  explanation?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  prompt?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "multiple_choices" */
export type MultipleChoicesMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audioUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  explanation?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MultipleChoicesMinFields = {
  __typename?: 'multiple_choices_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  audioUrl?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  explanation?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  prompt?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "multiple_choices" */
export type MultipleChoicesMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audioUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  explanation?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "multiple_choices" */
export type MultipleChoicesMutationResponse = {
  __typename?: 'multiple_choices_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MultipleChoices>;
};

/** input type for inserting object relation for remote table "multiple_choices" */
export type MultipleChoicesObjRelInsertInput = {
  data: MultipleChoicesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<MultipleChoicesOnConflict>;
};

/** on_conflict condition type for table "multiple_choices" */
export type MultipleChoicesOnConflict = {
  constraint: MultipleChoicesConstraint;
  update_columns?: Array<MultipleChoicesUpdateColumn>;
  where?: InputMaybe<MultipleChoicesBoolExp>;
};

/** Ordering options when selecting data from "multiple_choices". */
export type MultipleChoicesOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  audioUrl?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  explanation?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  image?: InputMaybe<ImagesOrderBy>;
  imageId?: InputMaybe<OrderBy>;
  isMultiSelect?: InputMaybe<OrderBy>;
  multipleChoiceOptions_aggregate?: InputMaybe<MultipleChoiceOptionsAggregateOrderBy>;
  order?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: multiple_choices */
export type MultipleChoicesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "multiple_choices" */
export enum MultipleChoicesSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  AudioUrl = 'audioUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Explanation = 'explanation',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  IsMultiSelect = 'isMultiSelect',
  /** column name */
  Order = 'order',
  /** column name */
  Prompt = 'prompt',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "multiple_choices_aggregate_bool_exp_bool_and_arguments_columns" columns of table "multiple_choices" */
export enum MultipleChoicesSelectColumnMultipleChoicesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsMultiSelect = 'isMultiSelect'
}

/** select "multiple_choices_aggregate_bool_exp_bool_or_arguments_columns" columns of table "multiple_choices" */
export enum MultipleChoicesSelectColumnMultipleChoicesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsMultiSelect = 'isMultiSelect'
}

/** input type for updating data in table "multiple_choices" */
export type MultipleChoicesSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  explanation?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isMultiSelect?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type MultipleChoicesStddevFields = {
  __typename?: 'multiple_choices_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "multiple_choices" */
export type MultipleChoicesStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type MultipleChoicesStddevPopFields = {
  __typename?: 'multiple_choices_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "multiple_choices" */
export type MultipleChoicesStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type MultipleChoicesStddevSampFields = {
  __typename?: 'multiple_choices_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "multiple_choices" */
export type MultipleChoicesStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "multiple_choices" */
export type MultipleChoicesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MultipleChoicesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MultipleChoicesStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  explanation?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  isMultiSelect?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type MultipleChoicesSumFields = {
  __typename?: 'multiple_choices_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "multiple_choices" */
export type MultipleChoicesSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** update columns of table "multiple_choices" */
export enum MultipleChoicesUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  AudioUrl = 'audioUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Explanation = 'explanation',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  IsMultiSelect = 'isMultiSelect',
  /** column name */
  Order = 'order',
  /** column name */
  Prompt = 'prompt',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type MultipleChoicesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MultipleChoicesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MultipleChoicesSetInput>;
  /** filter the rows which have to be updated */
  where: MultipleChoicesBoolExp;
};

/** aggregate var_pop on columns */
export type MultipleChoicesVarPopFields = {
  __typename?: 'multiple_choices_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "multiple_choices" */
export type MultipleChoicesVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type MultipleChoicesVarSampFields = {
  __typename?: 'multiple_choices_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "multiple_choices" */
export type MultipleChoicesVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MultipleChoicesVarianceFields = {
  __typename?: 'multiple_choices_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "multiple_choices" */
export type MultipleChoicesVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
};

/** mutation root */
export type MutationRoot = {
  __typename?: 'mutation_root';
  /** delete data from the table: "activity_set_assignments" */
  delete_activity_set_assignments?: Maybe<ActivitySetAssignmentsMutationResponse>;
  /** delete single row from the table: "activity_set_assignments" */
  delete_activity_set_assignments_by_pk?: Maybe<ActivitySetAssignments>;
  /** delete data from the table: "activity_set_reports" */
  delete_activity_set_reports?: Maybe<ActivitySetReportsMutationResponse>;
  /** delete single row from the table: "activity_set_reports" */
  delete_activity_set_reports_by_pk?: Maybe<ActivitySetReports>;
  /** delete data from the table: "activity_set_responses" */
  delete_activity_set_responses?: Maybe<ActivitySetResponsesMutationResponse>;
  /** delete single row from the table: "activity_set_responses" */
  delete_activity_set_responses_by_pk?: Maybe<ActivitySetResponses>;
  /** delete data from the table: "activity_sets" */
  delete_activity_sets?: Maybe<ActivitySetsMutationResponse>;
  /** delete single row from the table: "activity_sets" */
  delete_activity_sets_by_pk?: Maybe<ActivitySets>;
  /** delete data from the table: "addresses" */
  delete_addresses?: Maybe<AddressesMutationResponse>;
  /** delete single row from the table: "addresses" */
  delete_addresses_by_pk?: Maybe<Addresses>;
  /** delete data from the table: "anagram_responses" */
  delete_anagram_responses?: Maybe<AnagramResponsesMutationResponse>;
  /** delete single row from the table: "anagram_responses" */
  delete_anagram_responses_by_pk?: Maybe<AnagramResponses>;
  /** delete data from the table: "anagrams" */
  delete_anagrams?: Maybe<AnagramsMutationResponse>;
  /** delete single row from the table: "anagrams" */
  delete_anagrams_by_pk?: Maybe<Anagrams>;
  /** delete data from the table: "annotations" */
  delete_annotations?: Maybe<AnnotationsMutationResponse>;
  /** delete single row from the table: "annotations" */
  delete_annotations_by_pk?: Maybe<Annotations>;
  /** delete data from the table: "application_reviews" */
  delete_application_reviews?: Maybe<ApplicationReviewsMutationResponse>;
  /** delete single row from the table: "application_reviews" */
  delete_application_reviews_by_pk?: Maybe<ApplicationReviews>;
  /** delete data from the table: "availability_times" */
  delete_availability_times?: Maybe<AvailabilityTimesMutationResponse>;
  /** delete single row from the table: "availability_times" */
  delete_availability_times_by_pk?: Maybe<AvailabilityTimes>;
  /** delete data from the table: "cefr_levels" */
  delete_cefr_levels?: Maybe<CefrLevelsMutationResponse>;
  /** delete single row from the table: "cefr_levels" */
  delete_cefr_levels_by_pk?: Maybe<CefrLevels>;
  /** delete data from the table: "class_activity_sets" */
  delete_class_activity_sets?: Maybe<ClassActivitySetsMutationResponse>;
  /** delete single row from the table: "class_activity_sets" */
  delete_class_activity_sets_by_pk?: Maybe<ClassActivitySets>;
  /** delete data from the table: "class_annotations" */
  delete_class_annotations?: Maybe<ClassAnnotationsMutationResponse>;
  /** delete single row from the table: "class_annotations" */
  delete_class_annotations_by_pk?: Maybe<ClassAnnotations>;
  /** delete data from the table: "class_courses" */
  delete_class_courses?: Maybe<ClassCoursesMutationResponse>;
  /** delete single row from the table: "class_courses" */
  delete_class_courses_by_pk?: Maybe<ClassCourses>;
  /** delete data from the table: "class_sessions" */
  delete_class_sessions?: Maybe<ClassSessionsMutationResponse>;
  /** delete single row from the table: "class_sessions" */
  delete_class_sessions_by_pk?: Maybe<ClassSessions>;
  /** delete data from the table: "class_slot_bookings" */
  delete_class_slot_bookings?: Maybe<ClassSlotBookingsMutationResponse>;
  /** delete single row from the table: "class_slot_bookings" */
  delete_class_slot_bookings_by_pk?: Maybe<ClassSlotBookings>;
  /** delete data from the table: "classes" */
  delete_classes?: Maybe<ClassesMutationResponse>;
  /** delete single row from the table: "classes" */
  delete_classes_by_pk?: Maybe<Classes>;
  /** delete data from the table: "course_activities" */
  delete_course_activities?: Maybe<CourseActivitiesMutationResponse>;
  /** delete single row from the table: "course_activities" */
  delete_course_activities_by_pk?: Maybe<CourseActivities>;
  /** delete data from the table: "course_reviews" */
  delete_course_reviews?: Maybe<CourseReviewsMutationResponse>;
  /** delete single row from the table: "course_reviews" */
  delete_course_reviews_by_pk?: Maybe<CourseReviews>;
  /** delete data from the table: "courses" */
  delete_courses?: Maybe<CoursesMutationResponse>;
  /** delete single row from the table: "courses" */
  delete_courses_by_pk?: Maybe<Courses>;
  /** delete data from the table: "daily_stats" */
  delete_daily_stats?: Maybe<DailyStatsMutationResponse>;
  /** delete single row from the table: "daily_stats" */
  delete_daily_stats_by_pk?: Maybe<DailyStats>;
  /** delete data from the table: "dictionaries" */
  delete_dictionaries?: Maybe<DictionariesMutationResponse>;
  /** delete single row from the table: "dictionaries" */
  delete_dictionaries_by_pk?: Maybe<Dictionaries>;
  /** delete data from the table: "emojis" */
  delete_emojis?: Maybe<EmojisMutationResponse>;
  /** delete single row from the table: "emojis" */
  delete_emojis_by_pk?: Maybe<Emojis>;
  /** delete data from the table: "employees" */
  delete_employees?: Maybe<EmployeesMutationResponse>;
  /** delete single row from the table: "employees" */
  delete_employees_by_pk?: Maybe<Employees>;
  /** delete data from the table: "example_joins" */
  delete_example_joins?: Maybe<ExampleJoinsMutationResponse>;
  /** delete single row from the table: "example_joins" */
  delete_example_joins_by_pk?: Maybe<ExampleJoins>;
  /** delete data from the table: "examples" */
  delete_examples?: Maybe<ExamplesMutationResponse>;
  /** delete single row from the table: "examples" */
  delete_examples_by_pk?: Maybe<Examples>;
  /** delete data from the table: "expired_refresh_tokens" */
  delete_expired_refresh_tokens?: Maybe<ExpiredRefreshTokensMutationResponse>;
  /** delete single row from the table: "expired_refresh_tokens" */
  delete_expired_refresh_tokens_by_pk?: Maybe<ExpiredRefreshTokens>;
  /** delete data from the table: "fill_in_the_blank_options" */
  delete_fill_in_the_blank_options?: Maybe<FillInTheBlankOptionsMutationResponse>;
  /** delete single row from the table: "fill_in_the_blank_options" */
  delete_fill_in_the_blank_options_by_pk?: Maybe<FillInTheBlankOptions>;
  /** delete data from the table: "fill_in_the_blank_responses" */
  delete_fill_in_the_blank_responses?: Maybe<FillInTheBlankResponsesMutationResponse>;
  /** delete single row from the table: "fill_in_the_blank_responses" */
  delete_fill_in_the_blank_responses_by_pk?: Maybe<FillInTheBlankResponses>;
  /** delete data from the table: "fill_in_the_blanks" */
  delete_fill_in_the_blanks?: Maybe<FillInTheBlanksMutationResponse>;
  /** delete single row from the table: "fill_in_the_blanks" */
  delete_fill_in_the_blanks_by_pk?: Maybe<FillInTheBlanks>;
  /** delete data from the table: "game_dailies" */
  delete_game_dailies?: Maybe<GameDailiesMutationResponse>;
  /** delete single row from the table: "game_dailies" */
  delete_game_dailies_by_pk?: Maybe<GameDailies>;
  /** delete data from the table: "game_difficulty" */
  delete_game_difficulty?: Maybe<GameDifficultyMutationResponse>;
  /** delete single row from the table: "game_difficulty" */
  delete_game_difficulty_by_pk?: Maybe<GameDifficulty>;
  /** delete data from the table: "game_types" */
  delete_game_types?: Maybe<GameTypesMutationResponse>;
  /** delete single row from the table: "game_types" */
  delete_game_types_by_pk?: Maybe<GameTypes>;
  /** delete data from the table: "game_users" */
  delete_game_users?: Maybe<GameUsersMutationResponse>;
  /** delete single row from the table: "game_users" */
  delete_game_users_by_pk?: Maybe<GameUsers>;
  /** delete data from the table: "games" */
  delete_games?: Maybe<GamesMutationResponse>;
  /** delete single row from the table: "games" */
  delete_games_by_pk?: Maybe<Games>;
  /** delete data from the table: "goals" */
  delete_goals?: Maybe<GoalsMutationResponse>;
  /** delete single row from the table: "goals" */
  delete_goals_by_pk?: Maybe<Goals>;
  /** delete data from the table: "images" */
  delete_images?: Maybe<ImagesMutationResponse>;
  /** delete single row from the table: "images" */
  delete_images_by_pk?: Maybe<Images>;
  /** delete data from the table: "interests" */
  delete_interests?: Maybe<InterestsMutationResponse>;
  /** delete single row from the table: "interests" */
  delete_interests_by_pk?: Maybe<Interests>;
  /** delete data from the table: "languages" */
  delete_languages?: Maybe<LanguagesMutationResponse>;
  /** delete single row from the table: "languages" */
  delete_languages_by_pk?: Maybe<Languages>;
  /** delete data from the table: "listenings" */
  delete_listenings?: Maybe<ListeningsMutationResponse>;
  /** delete single row from the table: "listenings" */
  delete_listenings_by_pk?: Maybe<Listenings>;
  /** delete data from the table: "live_class_activities" */
  delete_live_class_activities?: Maybe<LiveClassActivitiesMutationResponse>;
  /** delete single row from the table: "live_class_activities" */
  delete_live_class_activities_by_pk?: Maybe<LiveClassActivities>;
  /** delete data from the table: "live_messages" */
  delete_live_messages?: Maybe<LiveMessagesMutationResponse>;
  /** delete single row from the table: "live_messages" */
  delete_live_messages_by_pk?: Maybe<LiveMessages>;
  /** delete data from the table: "matching_options" */
  delete_matching_options?: Maybe<MatchingOptionsMutationResponse>;
  /** delete single row from the table: "matching_options" */
  delete_matching_options_by_pk?: Maybe<MatchingOptions>;
  /** delete data from the table: "matching_responses" */
  delete_matching_responses?: Maybe<MatchingResponsesMutationResponse>;
  /** delete single row from the table: "matching_responses" */
  delete_matching_responses_by_pk?: Maybe<MatchingResponses>;
  /** delete data from the table: "matchings" */
  delete_matchings?: Maybe<MatchingsMutationResponse>;
  /** delete single row from the table: "matchings" */
  delete_matchings_by_pk?: Maybe<Matchings>;
  /** delete data from the table: "messages" */
  delete_messages?: Maybe<MessagesMutationResponse>;
  /** delete single row from the table: "messages" */
  delete_messages_by_pk?: Maybe<Messages>;
  /** delete data from the table: "multiple_choice_options" */
  delete_multiple_choice_options?: Maybe<MultipleChoiceOptionsMutationResponse>;
  /** delete single row from the table: "multiple_choice_options" */
  delete_multiple_choice_options_by_pk?: Maybe<MultipleChoiceOptions>;
  /** delete data from the table: "multiple_choice_responses" */
  delete_multiple_choice_responses?: Maybe<MultipleChoiceResponsesMutationResponse>;
  /** delete single row from the table: "multiple_choice_responses" */
  delete_multiple_choice_responses_by_pk?: Maybe<MultipleChoiceResponses>;
  /** delete data from the table: "multiple_choices" */
  delete_multiple_choices?: Maybe<MultipleChoicesMutationResponse>;
  /** delete single row from the table: "multiple_choices" */
  delete_multiple_choices_by_pk?: Maybe<MultipleChoices>;
  /** delete data from the table: "open_answer_responses" */
  delete_open_answer_responses?: Maybe<OpenAnswerResponsesMutationResponse>;
  /** delete single row from the table: "open_answer_responses" */
  delete_open_answer_responses_by_pk?: Maybe<OpenAnswerResponses>;
  /** delete data from the table: "open_answers" */
  delete_open_answers?: Maybe<OpenAnswersMutationResponse>;
  /** delete single row from the table: "open_answers" */
  delete_open_answers_by_pk?: Maybe<OpenAnswers>;
  /** delete data from the table: "parts_of_speech" */
  delete_parts_of_speech?: Maybe<PartsOfSpeechMutationResponse>;
  /** delete single row from the table: "parts_of_speech" */
  delete_parts_of_speech_by_pk?: Maybe<PartsOfSpeech>;
  /** delete data from the table: "payments" */
  delete_payments?: Maybe<PaymentsMutationResponse>;
  /** delete single row from the table: "payments" */
  delete_payments_by_pk?: Maybe<Payments>;
  /** delete data from the table: "phrase_responses" */
  delete_phrase_responses?: Maybe<PhraseResponsesMutationResponse>;
  /** delete single row from the table: "phrase_responses" */
  delete_phrase_responses_by_pk?: Maybe<PhraseResponses>;
  /** delete data from the table: "phrases" */
  delete_phrases?: Maybe<PhrasesMutationResponse>;
  /** delete single row from the table: "phrases" */
  delete_phrases_by_pk?: Maybe<Phrases>;
  /** delete data from the table: "poem_lines" */
  delete_poem_lines?: Maybe<PoemLinesMutationResponse>;
  /** delete single row from the table: "poem_lines" */
  delete_poem_lines_by_pk?: Maybe<PoemLines>;
  /** delete data from the table: "poems" */
  delete_poems?: Maybe<PoemsMutationResponse>;
  /** delete single row from the table: "poems" */
  delete_poems_by_pk?: Maybe<Poems>;
  /** delete data from the table: "prepositions" */
  delete_prepositions?: Maybe<PrepositionsMutationResponse>;
  /** delete single row from the table: "prepositions" */
  delete_prepositions_by_pk?: Maybe<Prepositions>;
  /** delete data from the table: "readings" */
  delete_readings?: Maybe<ReadingsMutationResponse>;
  /** delete single row from the table: "readings" */
  delete_readings_by_pk?: Maybe<Readings>;
  /** delete data from the table: "session_statuses" */
  delete_session_statuses?: Maybe<SessionStatusesMutationResponse>;
  /** delete single row from the table: "session_statuses" */
  delete_session_statuses_by_pk?: Maybe<SessionStatuses>;
  /** delete data from the table: "sessions" */
  delete_sessions?: Maybe<SessionsMutationResponse>;
  /** delete single row from the table: "sessions" */
  delete_sessions_by_pk?: Maybe<Sessions>;
  /** delete data from the table: "slots" */
  delete_slots?: Maybe<SlotsMutationResponse>;
  /** delete single row from the table: "slots" */
  delete_slots_by_pk?: Maybe<Slots>;
  /** delete data from the table: "stats" */
  delete_stats?: Maybe<StatsMutationResponse>;
  /** delete single row from the table: "stats" */
  delete_stats_by_pk?: Maybe<Stats>;
  /** delete data from the table: "student_class_sessions" */
  delete_student_class_sessions?: Maybe<StudentClassSessionsMutationResponse>;
  /** delete single row from the table: "student_class_sessions" */
  delete_student_class_sessions_by_pk?: Maybe<StudentClassSessions>;
  /** delete data from the table: "student_classes" */
  delete_student_classes?: Maybe<StudentClassesMutationResponse>;
  /** delete single row from the table: "student_classes" */
  delete_student_classes_by_pk?: Maybe<StudentClasses>;
  /** delete data from the table: "student_favorite_teachers" */
  delete_student_favorite_teachers?: Maybe<StudentFavoriteTeachersMutationResponse>;
  /** delete single row from the table: "student_favorite_teachers" */
  delete_student_favorite_teachers_by_pk?: Maybe<StudentFavoriteTeachers>;
  /** delete data from the table: "student_live_class_activities" */
  delete_student_live_class_activities?: Maybe<StudentLiveClassActivitiesMutationResponse>;
  /** delete single row from the table: "student_live_class_activities" */
  delete_student_live_class_activities_by_pk?: Maybe<StudentLiveClassActivities>;
  /** delete data from the table: "subjects" */
  delete_subjects?: Maybe<SubjectsMutationResponse>;
  /** delete single row from the table: "subjects" */
  delete_subjects_by_pk?: Maybe<Subjects>;
  /** delete data from the table: "subscriptions" */
  delete_subscriptions?: Maybe<SubscriptionsMutationResponse>;
  /** delete single row from the table: "subscriptions" */
  delete_subscriptions_by_pk?: Maybe<Subscriptions>;
  /** delete data from the table: "synonyms" */
  delete_synonyms?: Maybe<SynonymsMutationResponse>;
  /** delete single row from the table: "synonyms" */
  delete_synonyms_by_pk?: Maybe<Synonyms>;
  /** delete data from the table: "teacher_credentials" */
  delete_teacher_credentials?: Maybe<TeacherCredentialsMutationResponse>;
  /** delete single row from the table: "teacher_credentials" */
  delete_teacher_credentials_by_pk?: Maybe<TeacherCredentials>;
  /** delete data from the table: "teacher_education" */
  delete_teacher_education?: Maybe<TeacherEducationMutationResponse>;
  /** delete single row from the table: "teacher_education" */
  delete_teacher_education_by_pk?: Maybe<TeacherEducation>;
  /** delete data from the table: "teacher_interests" */
  delete_teacher_interests?: Maybe<TeacherInterestsMutationResponse>;
  /** delete single row from the table: "teacher_interests" */
  delete_teacher_interests_by_pk?: Maybe<TeacherInterests>;
  /** delete data from the table: "teacher_languages" */
  delete_teacher_languages?: Maybe<TeacherLanguagesMutationResponse>;
  /** delete single row from the table: "teacher_languages" */
  delete_teacher_languages_by_pk?: Maybe<TeacherLanguages>;
  /** delete data from the table: "teacher_subjects" */
  delete_teacher_subjects?: Maybe<TeacherSubjectsMutationResponse>;
  /** delete single row from the table: "teacher_subjects" */
  delete_teacher_subjects_by_pk?: Maybe<TeacherSubjects>;
  /** delete data from the table: "teachers" */
  delete_teachers?: Maybe<TeachersMutationResponse>;
  /** delete single row from the table: "teachers" */
  delete_teachers_by_pk?: Maybe<Teachers>;
  /** delete data from the table: "user_courses" */
  delete_user_courses?: Maybe<UserCoursesMutationResponse>;
  /** delete single row from the table: "user_courses" */
  delete_user_courses_by_pk?: Maybe<UserCourses>;
  /** delete data from the table: "user_devices" */
  delete_user_devices?: Maybe<UserDevicesMutationResponse>;
  /** delete single row from the table: "user_devices" */
  delete_user_devices_by_pk?: Maybe<UserDevices>;
  /** delete data from the table: "user_dictionaries" */
  delete_user_dictionaries?: Maybe<UserDictionariesMutationResponse>;
  /** delete single row from the table: "user_dictionaries" */
  delete_user_dictionaries_by_pk?: Maybe<UserDictionaries>;
  /** delete data from the table: "user_messages" */
  delete_user_messages?: Maybe<UserMessagesMutationResponse>;
  /** delete single row from the table: "user_messages" */
  delete_user_messages_by_pk?: Maybe<UserMessages>;
  /** delete data from the table: "user_words" */
  delete_user_words?: Maybe<UserWordsMutationResponse>;
  /** delete single row from the table: "user_words" */
  delete_user_words_by_pk?: Maybe<UserWords>;
  /** delete data from the table: "user_words_count" */
  delete_user_words_count?: Maybe<UserWordsCountMutationResponse>;
  /** delete single row from the table: "user_words_count" */
  delete_user_words_count_by_pk?: Maybe<UserWordsCount>;
  /** delete data from the table: "users" */
  delete_users?: Maybe<UsersMutationResponse>;
  /** delete single row from the table: "users" */
  delete_users_by_pk?: Maybe<Users>;
  /** delete data from the table: "vocabulary_sets" */
  delete_vocabulary_sets?: Maybe<VocabularySetsMutationResponse>;
  /** delete single row from the table: "vocabulary_sets" */
  delete_vocabulary_sets_by_pk?: Maybe<VocabularySets>;
  /** delete data from the table: "vocabulary_words" */
  delete_vocabulary_words?: Maybe<VocabularyWordsMutationResponse>;
  /** delete single row from the table: "vocabulary_words" */
  delete_vocabulary_words_by_pk?: Maybe<VocabularyWords>;
  /** delete data from the table: "wordnet.english_words" */
  delete_wordnet_english_words?: Maybe<WordnetEnglishWordsMutationResponse>;
  /** delete single row from the table: "wordnet.english_words" */
  delete_wordnet_english_words_by_pk?: Maybe<WordnetEnglishWords>;
  /** delete data from the table: "wordnet.synsets" */
  delete_wordnet_synsets?: Maybe<WordnetSynsetsMutationResponse>;
  /** delete single row from the table: "wordnet.synsets" */
  delete_wordnet_synsets_by_pk?: Maybe<WordnetSynsets>;
  /** insert data into the table: "activity_set_assignments" */
  insert_activity_set_assignments?: Maybe<ActivitySetAssignmentsMutationResponse>;
  /** insert a single row into the table: "activity_set_assignments" */
  insert_activity_set_assignments_one?: Maybe<ActivitySetAssignments>;
  /** insert data into the table: "activity_set_reports" */
  insert_activity_set_reports?: Maybe<ActivitySetReportsMutationResponse>;
  /** insert a single row into the table: "activity_set_reports" */
  insert_activity_set_reports_one?: Maybe<ActivitySetReports>;
  /** insert data into the table: "activity_set_responses" */
  insert_activity_set_responses?: Maybe<ActivitySetResponsesMutationResponse>;
  /** insert a single row into the table: "activity_set_responses" */
  insert_activity_set_responses_one?: Maybe<ActivitySetResponses>;
  /** insert data into the table: "activity_sets" */
  insert_activity_sets?: Maybe<ActivitySetsMutationResponse>;
  /** insert a single row into the table: "activity_sets" */
  insert_activity_sets_one?: Maybe<ActivitySets>;
  /** insert data into the table: "addresses" */
  insert_addresses?: Maybe<AddressesMutationResponse>;
  /** insert a single row into the table: "addresses" */
  insert_addresses_one?: Maybe<Addresses>;
  /** insert data into the table: "anagram_responses" */
  insert_anagram_responses?: Maybe<AnagramResponsesMutationResponse>;
  /** insert a single row into the table: "anagram_responses" */
  insert_anagram_responses_one?: Maybe<AnagramResponses>;
  /** insert data into the table: "anagrams" */
  insert_anagrams?: Maybe<AnagramsMutationResponse>;
  /** insert a single row into the table: "anagrams" */
  insert_anagrams_one?: Maybe<Anagrams>;
  /** insert data into the table: "annotations" */
  insert_annotations?: Maybe<AnnotationsMutationResponse>;
  /** insert a single row into the table: "annotations" */
  insert_annotations_one?: Maybe<Annotations>;
  /** insert data into the table: "application_reviews" */
  insert_application_reviews?: Maybe<ApplicationReviewsMutationResponse>;
  /** insert a single row into the table: "application_reviews" */
  insert_application_reviews_one?: Maybe<ApplicationReviews>;
  /** insert data into the table: "availability_times" */
  insert_availability_times?: Maybe<AvailabilityTimesMutationResponse>;
  /** insert a single row into the table: "availability_times" */
  insert_availability_times_one?: Maybe<AvailabilityTimes>;
  /** insert data into the table: "cefr_levels" */
  insert_cefr_levels?: Maybe<CefrLevelsMutationResponse>;
  /** insert a single row into the table: "cefr_levels" */
  insert_cefr_levels_one?: Maybe<CefrLevels>;
  /** insert data into the table: "class_activity_sets" */
  insert_class_activity_sets?: Maybe<ClassActivitySetsMutationResponse>;
  /** insert a single row into the table: "class_activity_sets" */
  insert_class_activity_sets_one?: Maybe<ClassActivitySets>;
  /** insert data into the table: "class_annotations" */
  insert_class_annotations?: Maybe<ClassAnnotationsMutationResponse>;
  /** insert a single row into the table: "class_annotations" */
  insert_class_annotations_one?: Maybe<ClassAnnotations>;
  /** insert data into the table: "class_courses" */
  insert_class_courses?: Maybe<ClassCoursesMutationResponse>;
  /** insert a single row into the table: "class_courses" */
  insert_class_courses_one?: Maybe<ClassCourses>;
  /** insert data into the table: "class_sessions" */
  insert_class_sessions?: Maybe<ClassSessionsMutationResponse>;
  /** insert a single row into the table: "class_sessions" */
  insert_class_sessions_one?: Maybe<ClassSessions>;
  /** insert data into the table: "class_slot_bookings" */
  insert_class_slot_bookings?: Maybe<ClassSlotBookingsMutationResponse>;
  /** insert a single row into the table: "class_slot_bookings" */
  insert_class_slot_bookings_one?: Maybe<ClassSlotBookings>;
  /** insert data into the table: "classes" */
  insert_classes?: Maybe<ClassesMutationResponse>;
  /** insert a single row into the table: "classes" */
  insert_classes_one?: Maybe<Classes>;
  /** insert data into the table: "course_activities" */
  insert_course_activities?: Maybe<CourseActivitiesMutationResponse>;
  /** insert a single row into the table: "course_activities" */
  insert_course_activities_one?: Maybe<CourseActivities>;
  /** insert data into the table: "course_reviews" */
  insert_course_reviews?: Maybe<CourseReviewsMutationResponse>;
  /** insert a single row into the table: "course_reviews" */
  insert_course_reviews_one?: Maybe<CourseReviews>;
  /** insert data into the table: "courses" */
  insert_courses?: Maybe<CoursesMutationResponse>;
  /** insert a single row into the table: "courses" */
  insert_courses_one?: Maybe<Courses>;
  /** insert data into the table: "daily_stats" */
  insert_daily_stats?: Maybe<DailyStatsMutationResponse>;
  /** insert a single row into the table: "daily_stats" */
  insert_daily_stats_one?: Maybe<DailyStats>;
  /** insert data into the table: "dictionaries" */
  insert_dictionaries?: Maybe<DictionariesMutationResponse>;
  /** insert a single row into the table: "dictionaries" */
  insert_dictionaries_one?: Maybe<Dictionaries>;
  /** insert data into the table: "emojis" */
  insert_emojis?: Maybe<EmojisMutationResponse>;
  /** insert a single row into the table: "emojis" */
  insert_emojis_one?: Maybe<Emojis>;
  /** insert data into the table: "employees" */
  insert_employees?: Maybe<EmployeesMutationResponse>;
  /** insert a single row into the table: "employees" */
  insert_employees_one?: Maybe<Employees>;
  /** insert data into the table: "example_joins" */
  insert_example_joins?: Maybe<ExampleJoinsMutationResponse>;
  /** insert a single row into the table: "example_joins" */
  insert_example_joins_one?: Maybe<ExampleJoins>;
  /** insert data into the table: "examples" */
  insert_examples?: Maybe<ExamplesMutationResponse>;
  /** insert a single row into the table: "examples" */
  insert_examples_one?: Maybe<Examples>;
  /** insert data into the table: "expired_refresh_tokens" */
  insert_expired_refresh_tokens?: Maybe<ExpiredRefreshTokensMutationResponse>;
  /** insert a single row into the table: "expired_refresh_tokens" */
  insert_expired_refresh_tokens_one?: Maybe<ExpiredRefreshTokens>;
  /** insert data into the table: "fill_in_the_blank_options" */
  insert_fill_in_the_blank_options?: Maybe<FillInTheBlankOptionsMutationResponse>;
  /** insert a single row into the table: "fill_in_the_blank_options" */
  insert_fill_in_the_blank_options_one?: Maybe<FillInTheBlankOptions>;
  /** insert data into the table: "fill_in_the_blank_responses" */
  insert_fill_in_the_blank_responses?: Maybe<FillInTheBlankResponsesMutationResponse>;
  /** insert a single row into the table: "fill_in_the_blank_responses" */
  insert_fill_in_the_blank_responses_one?: Maybe<FillInTheBlankResponses>;
  /** insert data into the table: "fill_in_the_blanks" */
  insert_fill_in_the_blanks?: Maybe<FillInTheBlanksMutationResponse>;
  /** insert a single row into the table: "fill_in_the_blanks" */
  insert_fill_in_the_blanks_one?: Maybe<FillInTheBlanks>;
  /** insert data into the table: "game_dailies" */
  insert_game_dailies?: Maybe<GameDailiesMutationResponse>;
  /** insert a single row into the table: "game_dailies" */
  insert_game_dailies_one?: Maybe<GameDailies>;
  /** insert data into the table: "game_difficulty" */
  insert_game_difficulty?: Maybe<GameDifficultyMutationResponse>;
  /** insert a single row into the table: "game_difficulty" */
  insert_game_difficulty_one?: Maybe<GameDifficulty>;
  /** insert data into the table: "game_types" */
  insert_game_types?: Maybe<GameTypesMutationResponse>;
  /** insert a single row into the table: "game_types" */
  insert_game_types_one?: Maybe<GameTypes>;
  /** insert data into the table: "game_users" */
  insert_game_users?: Maybe<GameUsersMutationResponse>;
  /** insert a single row into the table: "game_users" */
  insert_game_users_one?: Maybe<GameUsers>;
  /** insert data into the table: "games" */
  insert_games?: Maybe<GamesMutationResponse>;
  /** insert a single row into the table: "games" */
  insert_games_one?: Maybe<Games>;
  /** insert data into the table: "goals" */
  insert_goals?: Maybe<GoalsMutationResponse>;
  /** insert a single row into the table: "goals" */
  insert_goals_one?: Maybe<Goals>;
  /** insert data into the table: "images" */
  insert_images?: Maybe<ImagesMutationResponse>;
  /** insert a single row into the table: "images" */
  insert_images_one?: Maybe<Images>;
  /** insert data into the table: "interests" */
  insert_interests?: Maybe<InterestsMutationResponse>;
  /** insert a single row into the table: "interests" */
  insert_interests_one?: Maybe<Interests>;
  /** insert data into the table: "languages" */
  insert_languages?: Maybe<LanguagesMutationResponse>;
  /** insert a single row into the table: "languages" */
  insert_languages_one?: Maybe<Languages>;
  /** insert data into the table: "listenings" */
  insert_listenings?: Maybe<ListeningsMutationResponse>;
  /** insert a single row into the table: "listenings" */
  insert_listenings_one?: Maybe<Listenings>;
  /** insert data into the table: "live_class_activities" */
  insert_live_class_activities?: Maybe<LiveClassActivitiesMutationResponse>;
  /** insert a single row into the table: "live_class_activities" */
  insert_live_class_activities_one?: Maybe<LiveClassActivities>;
  /** insert data into the table: "live_messages" */
  insert_live_messages?: Maybe<LiveMessagesMutationResponse>;
  /** insert a single row into the table: "live_messages" */
  insert_live_messages_one?: Maybe<LiveMessages>;
  /** insert data into the table: "matching_options" */
  insert_matching_options?: Maybe<MatchingOptionsMutationResponse>;
  /** insert a single row into the table: "matching_options" */
  insert_matching_options_one?: Maybe<MatchingOptions>;
  /** insert data into the table: "matching_responses" */
  insert_matching_responses?: Maybe<MatchingResponsesMutationResponse>;
  /** insert a single row into the table: "matching_responses" */
  insert_matching_responses_one?: Maybe<MatchingResponses>;
  /** insert data into the table: "matchings" */
  insert_matchings?: Maybe<MatchingsMutationResponse>;
  /** insert a single row into the table: "matchings" */
  insert_matchings_one?: Maybe<Matchings>;
  /** insert data into the table: "messages" */
  insert_messages?: Maybe<MessagesMutationResponse>;
  /** insert a single row into the table: "messages" */
  insert_messages_one?: Maybe<Messages>;
  /** insert data into the table: "multiple_choice_options" */
  insert_multiple_choice_options?: Maybe<MultipleChoiceOptionsMutationResponse>;
  /** insert a single row into the table: "multiple_choice_options" */
  insert_multiple_choice_options_one?: Maybe<MultipleChoiceOptions>;
  /** insert data into the table: "multiple_choice_responses" */
  insert_multiple_choice_responses?: Maybe<MultipleChoiceResponsesMutationResponse>;
  /** insert a single row into the table: "multiple_choice_responses" */
  insert_multiple_choice_responses_one?: Maybe<MultipleChoiceResponses>;
  /** insert data into the table: "multiple_choices" */
  insert_multiple_choices?: Maybe<MultipleChoicesMutationResponse>;
  /** insert a single row into the table: "multiple_choices" */
  insert_multiple_choices_one?: Maybe<MultipleChoices>;
  /** insert data into the table: "open_answer_responses" */
  insert_open_answer_responses?: Maybe<OpenAnswerResponsesMutationResponse>;
  /** insert a single row into the table: "open_answer_responses" */
  insert_open_answer_responses_one?: Maybe<OpenAnswerResponses>;
  /** insert data into the table: "open_answers" */
  insert_open_answers?: Maybe<OpenAnswersMutationResponse>;
  /** insert a single row into the table: "open_answers" */
  insert_open_answers_one?: Maybe<OpenAnswers>;
  /** insert data into the table: "parts_of_speech" */
  insert_parts_of_speech?: Maybe<PartsOfSpeechMutationResponse>;
  /** insert a single row into the table: "parts_of_speech" */
  insert_parts_of_speech_one?: Maybe<PartsOfSpeech>;
  /** insert data into the table: "payments" */
  insert_payments?: Maybe<PaymentsMutationResponse>;
  /** insert a single row into the table: "payments" */
  insert_payments_one?: Maybe<Payments>;
  /** insert data into the table: "phrase_responses" */
  insert_phrase_responses?: Maybe<PhraseResponsesMutationResponse>;
  /** insert a single row into the table: "phrase_responses" */
  insert_phrase_responses_one?: Maybe<PhraseResponses>;
  /** insert data into the table: "phrases" */
  insert_phrases?: Maybe<PhrasesMutationResponse>;
  /** insert a single row into the table: "phrases" */
  insert_phrases_one?: Maybe<Phrases>;
  /** insert data into the table: "poem_lines" */
  insert_poem_lines?: Maybe<PoemLinesMutationResponse>;
  /** insert a single row into the table: "poem_lines" */
  insert_poem_lines_one?: Maybe<PoemLines>;
  /** insert data into the table: "poems" */
  insert_poems?: Maybe<PoemsMutationResponse>;
  /** insert a single row into the table: "poems" */
  insert_poems_one?: Maybe<Poems>;
  /** insert data into the table: "prepositions" */
  insert_prepositions?: Maybe<PrepositionsMutationResponse>;
  /** insert a single row into the table: "prepositions" */
  insert_prepositions_one?: Maybe<Prepositions>;
  /** insert data into the table: "readings" */
  insert_readings?: Maybe<ReadingsMutationResponse>;
  /** insert a single row into the table: "readings" */
  insert_readings_one?: Maybe<Readings>;
  /** insert data into the table: "session_statuses" */
  insert_session_statuses?: Maybe<SessionStatusesMutationResponse>;
  /** insert a single row into the table: "session_statuses" */
  insert_session_statuses_one?: Maybe<SessionStatuses>;
  /** insert data into the table: "sessions" */
  insert_sessions?: Maybe<SessionsMutationResponse>;
  /** insert a single row into the table: "sessions" */
  insert_sessions_one?: Maybe<Sessions>;
  /** insert data into the table: "slots" */
  insert_slots?: Maybe<SlotsMutationResponse>;
  /** insert a single row into the table: "slots" */
  insert_slots_one?: Maybe<Slots>;
  /** insert data into the table: "stats" */
  insert_stats?: Maybe<StatsMutationResponse>;
  /** insert a single row into the table: "stats" */
  insert_stats_one?: Maybe<Stats>;
  /** insert data into the table: "student_class_sessions" */
  insert_student_class_sessions?: Maybe<StudentClassSessionsMutationResponse>;
  /** insert a single row into the table: "student_class_sessions" */
  insert_student_class_sessions_one?: Maybe<StudentClassSessions>;
  /** insert data into the table: "student_classes" */
  insert_student_classes?: Maybe<StudentClassesMutationResponse>;
  /** insert a single row into the table: "student_classes" */
  insert_student_classes_one?: Maybe<StudentClasses>;
  /** insert data into the table: "student_favorite_teachers" */
  insert_student_favorite_teachers?: Maybe<StudentFavoriteTeachersMutationResponse>;
  /** insert a single row into the table: "student_favorite_teachers" */
  insert_student_favorite_teachers_one?: Maybe<StudentFavoriteTeachers>;
  /** insert data into the table: "student_live_class_activities" */
  insert_student_live_class_activities?: Maybe<StudentLiveClassActivitiesMutationResponse>;
  /** insert a single row into the table: "student_live_class_activities" */
  insert_student_live_class_activities_one?: Maybe<StudentLiveClassActivities>;
  /** insert data into the table: "subjects" */
  insert_subjects?: Maybe<SubjectsMutationResponse>;
  /** insert a single row into the table: "subjects" */
  insert_subjects_one?: Maybe<Subjects>;
  /** insert data into the table: "subscriptions" */
  insert_subscriptions?: Maybe<SubscriptionsMutationResponse>;
  /** insert a single row into the table: "subscriptions" */
  insert_subscriptions_one?: Maybe<Subscriptions>;
  /** insert data into the table: "synonyms" */
  insert_synonyms?: Maybe<SynonymsMutationResponse>;
  /** insert a single row into the table: "synonyms" */
  insert_synonyms_one?: Maybe<Synonyms>;
  /** insert data into the table: "teacher_credentials" */
  insert_teacher_credentials?: Maybe<TeacherCredentialsMutationResponse>;
  /** insert a single row into the table: "teacher_credentials" */
  insert_teacher_credentials_one?: Maybe<TeacherCredentials>;
  /** insert data into the table: "teacher_education" */
  insert_teacher_education?: Maybe<TeacherEducationMutationResponse>;
  /** insert a single row into the table: "teacher_education" */
  insert_teacher_education_one?: Maybe<TeacherEducation>;
  /** insert data into the table: "teacher_interests" */
  insert_teacher_interests?: Maybe<TeacherInterestsMutationResponse>;
  /** insert a single row into the table: "teacher_interests" */
  insert_teacher_interests_one?: Maybe<TeacherInterests>;
  /** insert data into the table: "teacher_languages" */
  insert_teacher_languages?: Maybe<TeacherLanguagesMutationResponse>;
  /** insert a single row into the table: "teacher_languages" */
  insert_teacher_languages_one?: Maybe<TeacherLanguages>;
  /** insert data into the table: "teacher_subjects" */
  insert_teacher_subjects?: Maybe<TeacherSubjectsMutationResponse>;
  /** insert a single row into the table: "teacher_subjects" */
  insert_teacher_subjects_one?: Maybe<TeacherSubjects>;
  /** insert data into the table: "teachers" */
  insert_teachers?: Maybe<TeachersMutationResponse>;
  /** insert a single row into the table: "teachers" */
  insert_teachers_one?: Maybe<Teachers>;
  /** insert data into the table: "user_courses" */
  insert_user_courses?: Maybe<UserCoursesMutationResponse>;
  /** insert a single row into the table: "user_courses" */
  insert_user_courses_one?: Maybe<UserCourses>;
  /** insert data into the table: "user_devices" */
  insert_user_devices?: Maybe<UserDevicesMutationResponse>;
  /** insert a single row into the table: "user_devices" */
  insert_user_devices_one?: Maybe<UserDevices>;
  /** insert data into the table: "user_dictionaries" */
  insert_user_dictionaries?: Maybe<UserDictionariesMutationResponse>;
  /** insert a single row into the table: "user_dictionaries" */
  insert_user_dictionaries_one?: Maybe<UserDictionaries>;
  /** insert data into the table: "user_messages" */
  insert_user_messages?: Maybe<UserMessagesMutationResponse>;
  /** insert a single row into the table: "user_messages" */
  insert_user_messages_one?: Maybe<UserMessages>;
  /** insert data into the table: "user_words" */
  insert_user_words?: Maybe<UserWordsMutationResponse>;
  /** insert data into the table: "user_words_count" */
  insert_user_words_count?: Maybe<UserWordsCountMutationResponse>;
  /** insert a single row into the table: "user_words_count" */
  insert_user_words_count_one?: Maybe<UserWordsCount>;
  /** insert a single row into the table: "user_words" */
  insert_user_words_one?: Maybe<UserWords>;
  /** insert data into the table: "users" */
  insert_users?: Maybe<UsersMutationResponse>;
  /** insert a single row into the table: "users" */
  insert_users_one?: Maybe<Users>;
  /** insert data into the table: "vocabulary_sets" */
  insert_vocabulary_sets?: Maybe<VocabularySetsMutationResponse>;
  /** insert a single row into the table: "vocabulary_sets" */
  insert_vocabulary_sets_one?: Maybe<VocabularySets>;
  /** insert data into the table: "vocabulary_words" */
  insert_vocabulary_words?: Maybe<VocabularyWordsMutationResponse>;
  /** insert a single row into the table: "vocabulary_words" */
  insert_vocabulary_words_one?: Maybe<VocabularyWords>;
  /** insert data into the table: "wordnet.english_words" */
  insert_wordnet_english_words?: Maybe<WordnetEnglishWordsMutationResponse>;
  /** insert a single row into the table: "wordnet.english_words" */
  insert_wordnet_english_words_one?: Maybe<WordnetEnglishWords>;
  /** insert data into the table: "wordnet.synsets" */
  insert_wordnet_synsets?: Maybe<WordnetSynsetsMutationResponse>;
  /** insert a single row into the table: "wordnet.synsets" */
  insert_wordnet_synsets_one?: Maybe<WordnetSynsets>;
  /** update data of the table: "activity_set_assignments" */
  update_activity_set_assignments?: Maybe<ActivitySetAssignmentsMutationResponse>;
  /** update single row of the table: "activity_set_assignments" */
  update_activity_set_assignments_by_pk?: Maybe<ActivitySetAssignments>;
  /** update multiples rows of table: "activity_set_assignments" */
  update_activity_set_assignments_many?: Maybe<Array<Maybe<ActivitySetAssignmentsMutationResponse>>>;
  /** update data of the table: "activity_set_reports" */
  update_activity_set_reports?: Maybe<ActivitySetReportsMutationResponse>;
  /** update single row of the table: "activity_set_reports" */
  update_activity_set_reports_by_pk?: Maybe<ActivitySetReports>;
  /** update multiples rows of table: "activity_set_reports" */
  update_activity_set_reports_many?: Maybe<Array<Maybe<ActivitySetReportsMutationResponse>>>;
  /** update data of the table: "activity_set_responses" */
  update_activity_set_responses?: Maybe<ActivitySetResponsesMutationResponse>;
  /** update single row of the table: "activity_set_responses" */
  update_activity_set_responses_by_pk?: Maybe<ActivitySetResponses>;
  /** update multiples rows of table: "activity_set_responses" */
  update_activity_set_responses_many?: Maybe<Array<Maybe<ActivitySetResponsesMutationResponse>>>;
  /** update data of the table: "activity_sets" */
  update_activity_sets?: Maybe<ActivitySetsMutationResponse>;
  /** update single row of the table: "activity_sets" */
  update_activity_sets_by_pk?: Maybe<ActivitySets>;
  /** update multiples rows of table: "activity_sets" */
  update_activity_sets_many?: Maybe<Array<Maybe<ActivitySetsMutationResponse>>>;
  /** update data of the table: "addresses" */
  update_addresses?: Maybe<AddressesMutationResponse>;
  /** update single row of the table: "addresses" */
  update_addresses_by_pk?: Maybe<Addresses>;
  /** update multiples rows of table: "addresses" */
  update_addresses_many?: Maybe<Array<Maybe<AddressesMutationResponse>>>;
  /** update data of the table: "anagram_responses" */
  update_anagram_responses?: Maybe<AnagramResponsesMutationResponse>;
  /** update single row of the table: "anagram_responses" */
  update_anagram_responses_by_pk?: Maybe<AnagramResponses>;
  /** update multiples rows of table: "anagram_responses" */
  update_anagram_responses_many?: Maybe<Array<Maybe<AnagramResponsesMutationResponse>>>;
  /** update data of the table: "anagrams" */
  update_anagrams?: Maybe<AnagramsMutationResponse>;
  /** update single row of the table: "anagrams" */
  update_anagrams_by_pk?: Maybe<Anagrams>;
  /** update multiples rows of table: "anagrams" */
  update_anagrams_many?: Maybe<Array<Maybe<AnagramsMutationResponse>>>;
  /** update data of the table: "annotations" */
  update_annotations?: Maybe<AnnotationsMutationResponse>;
  /** update single row of the table: "annotations" */
  update_annotations_by_pk?: Maybe<Annotations>;
  /** update multiples rows of table: "annotations" */
  update_annotations_many?: Maybe<Array<Maybe<AnnotationsMutationResponse>>>;
  /** update data of the table: "application_reviews" */
  update_application_reviews?: Maybe<ApplicationReviewsMutationResponse>;
  /** update single row of the table: "application_reviews" */
  update_application_reviews_by_pk?: Maybe<ApplicationReviews>;
  /** update multiples rows of table: "application_reviews" */
  update_application_reviews_many?: Maybe<Array<Maybe<ApplicationReviewsMutationResponse>>>;
  /** update data of the table: "availability_times" */
  update_availability_times?: Maybe<AvailabilityTimesMutationResponse>;
  /** update single row of the table: "availability_times" */
  update_availability_times_by_pk?: Maybe<AvailabilityTimes>;
  /** update multiples rows of table: "availability_times" */
  update_availability_times_many?: Maybe<Array<Maybe<AvailabilityTimesMutationResponse>>>;
  /** update data of the table: "cefr_levels" */
  update_cefr_levels?: Maybe<CefrLevelsMutationResponse>;
  /** update single row of the table: "cefr_levels" */
  update_cefr_levels_by_pk?: Maybe<CefrLevels>;
  /** update multiples rows of table: "cefr_levels" */
  update_cefr_levels_many?: Maybe<Array<Maybe<CefrLevelsMutationResponse>>>;
  /** update data of the table: "class_activity_sets" */
  update_class_activity_sets?: Maybe<ClassActivitySetsMutationResponse>;
  /** update single row of the table: "class_activity_sets" */
  update_class_activity_sets_by_pk?: Maybe<ClassActivitySets>;
  /** update multiples rows of table: "class_activity_sets" */
  update_class_activity_sets_many?: Maybe<Array<Maybe<ClassActivitySetsMutationResponse>>>;
  /** update data of the table: "class_annotations" */
  update_class_annotations?: Maybe<ClassAnnotationsMutationResponse>;
  /** update single row of the table: "class_annotations" */
  update_class_annotations_by_pk?: Maybe<ClassAnnotations>;
  /** update multiples rows of table: "class_annotations" */
  update_class_annotations_many?: Maybe<Array<Maybe<ClassAnnotationsMutationResponse>>>;
  /** update data of the table: "class_courses" */
  update_class_courses?: Maybe<ClassCoursesMutationResponse>;
  /** update single row of the table: "class_courses" */
  update_class_courses_by_pk?: Maybe<ClassCourses>;
  /** update multiples rows of table: "class_courses" */
  update_class_courses_many?: Maybe<Array<Maybe<ClassCoursesMutationResponse>>>;
  /** update data of the table: "class_sessions" */
  update_class_sessions?: Maybe<ClassSessionsMutationResponse>;
  /** update single row of the table: "class_sessions" */
  update_class_sessions_by_pk?: Maybe<ClassSessions>;
  /** update multiples rows of table: "class_sessions" */
  update_class_sessions_many?: Maybe<Array<Maybe<ClassSessionsMutationResponse>>>;
  /** update data of the table: "class_slot_bookings" */
  update_class_slot_bookings?: Maybe<ClassSlotBookingsMutationResponse>;
  /** update single row of the table: "class_slot_bookings" */
  update_class_slot_bookings_by_pk?: Maybe<ClassSlotBookings>;
  /** update multiples rows of table: "class_slot_bookings" */
  update_class_slot_bookings_many?: Maybe<Array<Maybe<ClassSlotBookingsMutationResponse>>>;
  /** update data of the table: "classes" */
  update_classes?: Maybe<ClassesMutationResponse>;
  /** update single row of the table: "classes" */
  update_classes_by_pk?: Maybe<Classes>;
  /** update multiples rows of table: "classes" */
  update_classes_many?: Maybe<Array<Maybe<ClassesMutationResponse>>>;
  /** update data of the table: "course_activities" */
  update_course_activities?: Maybe<CourseActivitiesMutationResponse>;
  /** update single row of the table: "course_activities" */
  update_course_activities_by_pk?: Maybe<CourseActivities>;
  /** update multiples rows of table: "course_activities" */
  update_course_activities_many?: Maybe<Array<Maybe<CourseActivitiesMutationResponse>>>;
  /** update data of the table: "course_reviews" */
  update_course_reviews?: Maybe<CourseReviewsMutationResponse>;
  /** update single row of the table: "course_reviews" */
  update_course_reviews_by_pk?: Maybe<CourseReviews>;
  /** update multiples rows of table: "course_reviews" */
  update_course_reviews_many?: Maybe<Array<Maybe<CourseReviewsMutationResponse>>>;
  /** update data of the table: "courses" */
  update_courses?: Maybe<CoursesMutationResponse>;
  /** update single row of the table: "courses" */
  update_courses_by_pk?: Maybe<Courses>;
  /** update multiples rows of table: "courses" */
  update_courses_many?: Maybe<Array<Maybe<CoursesMutationResponse>>>;
  /** update data of the table: "daily_stats" */
  update_daily_stats?: Maybe<DailyStatsMutationResponse>;
  /** update single row of the table: "daily_stats" */
  update_daily_stats_by_pk?: Maybe<DailyStats>;
  /** update multiples rows of table: "daily_stats" */
  update_daily_stats_many?: Maybe<Array<Maybe<DailyStatsMutationResponse>>>;
  /** update data of the table: "dictionaries" */
  update_dictionaries?: Maybe<DictionariesMutationResponse>;
  /** update single row of the table: "dictionaries" */
  update_dictionaries_by_pk?: Maybe<Dictionaries>;
  /** update multiples rows of table: "dictionaries" */
  update_dictionaries_many?: Maybe<Array<Maybe<DictionariesMutationResponse>>>;
  /** update data of the table: "emojis" */
  update_emojis?: Maybe<EmojisMutationResponse>;
  /** update single row of the table: "emojis" */
  update_emojis_by_pk?: Maybe<Emojis>;
  /** update multiples rows of table: "emojis" */
  update_emojis_many?: Maybe<Array<Maybe<EmojisMutationResponse>>>;
  /** update data of the table: "employees" */
  update_employees?: Maybe<EmployeesMutationResponse>;
  /** update single row of the table: "employees" */
  update_employees_by_pk?: Maybe<Employees>;
  /** update multiples rows of table: "employees" */
  update_employees_many?: Maybe<Array<Maybe<EmployeesMutationResponse>>>;
  /** update data of the table: "example_joins" */
  update_example_joins?: Maybe<ExampleJoinsMutationResponse>;
  /** update single row of the table: "example_joins" */
  update_example_joins_by_pk?: Maybe<ExampleJoins>;
  /** update multiples rows of table: "example_joins" */
  update_example_joins_many?: Maybe<Array<Maybe<ExampleJoinsMutationResponse>>>;
  /** update data of the table: "examples" */
  update_examples?: Maybe<ExamplesMutationResponse>;
  /** update single row of the table: "examples" */
  update_examples_by_pk?: Maybe<Examples>;
  /** update multiples rows of table: "examples" */
  update_examples_many?: Maybe<Array<Maybe<ExamplesMutationResponse>>>;
  /** update data of the table: "expired_refresh_tokens" */
  update_expired_refresh_tokens?: Maybe<ExpiredRefreshTokensMutationResponse>;
  /** update single row of the table: "expired_refresh_tokens" */
  update_expired_refresh_tokens_by_pk?: Maybe<ExpiredRefreshTokens>;
  /** update multiples rows of table: "expired_refresh_tokens" */
  update_expired_refresh_tokens_many?: Maybe<Array<Maybe<ExpiredRefreshTokensMutationResponse>>>;
  /** update data of the table: "fill_in_the_blank_options" */
  update_fill_in_the_blank_options?: Maybe<FillInTheBlankOptionsMutationResponse>;
  /** update single row of the table: "fill_in_the_blank_options" */
  update_fill_in_the_blank_options_by_pk?: Maybe<FillInTheBlankOptions>;
  /** update multiples rows of table: "fill_in_the_blank_options" */
  update_fill_in_the_blank_options_many?: Maybe<Array<Maybe<FillInTheBlankOptionsMutationResponse>>>;
  /** update data of the table: "fill_in_the_blank_responses" */
  update_fill_in_the_blank_responses?: Maybe<FillInTheBlankResponsesMutationResponse>;
  /** update single row of the table: "fill_in_the_blank_responses" */
  update_fill_in_the_blank_responses_by_pk?: Maybe<FillInTheBlankResponses>;
  /** update multiples rows of table: "fill_in_the_blank_responses" */
  update_fill_in_the_blank_responses_many?: Maybe<Array<Maybe<FillInTheBlankResponsesMutationResponse>>>;
  /** update data of the table: "fill_in_the_blanks" */
  update_fill_in_the_blanks?: Maybe<FillInTheBlanksMutationResponse>;
  /** update single row of the table: "fill_in_the_blanks" */
  update_fill_in_the_blanks_by_pk?: Maybe<FillInTheBlanks>;
  /** update multiples rows of table: "fill_in_the_blanks" */
  update_fill_in_the_blanks_many?: Maybe<Array<Maybe<FillInTheBlanksMutationResponse>>>;
  /** update data of the table: "game_dailies" */
  update_game_dailies?: Maybe<GameDailiesMutationResponse>;
  /** update single row of the table: "game_dailies" */
  update_game_dailies_by_pk?: Maybe<GameDailies>;
  /** update multiples rows of table: "game_dailies" */
  update_game_dailies_many?: Maybe<Array<Maybe<GameDailiesMutationResponse>>>;
  /** update data of the table: "game_difficulty" */
  update_game_difficulty?: Maybe<GameDifficultyMutationResponse>;
  /** update single row of the table: "game_difficulty" */
  update_game_difficulty_by_pk?: Maybe<GameDifficulty>;
  /** update multiples rows of table: "game_difficulty" */
  update_game_difficulty_many?: Maybe<Array<Maybe<GameDifficultyMutationResponse>>>;
  /** update data of the table: "game_types" */
  update_game_types?: Maybe<GameTypesMutationResponse>;
  /** update single row of the table: "game_types" */
  update_game_types_by_pk?: Maybe<GameTypes>;
  /** update multiples rows of table: "game_types" */
  update_game_types_many?: Maybe<Array<Maybe<GameTypesMutationResponse>>>;
  /** update data of the table: "game_users" */
  update_game_users?: Maybe<GameUsersMutationResponse>;
  /** update single row of the table: "game_users" */
  update_game_users_by_pk?: Maybe<GameUsers>;
  /** update multiples rows of table: "game_users" */
  update_game_users_many?: Maybe<Array<Maybe<GameUsersMutationResponse>>>;
  /** update data of the table: "games" */
  update_games?: Maybe<GamesMutationResponse>;
  /** update single row of the table: "games" */
  update_games_by_pk?: Maybe<Games>;
  /** update multiples rows of table: "games" */
  update_games_many?: Maybe<Array<Maybe<GamesMutationResponse>>>;
  /** update data of the table: "goals" */
  update_goals?: Maybe<GoalsMutationResponse>;
  /** update single row of the table: "goals" */
  update_goals_by_pk?: Maybe<Goals>;
  /** update multiples rows of table: "goals" */
  update_goals_many?: Maybe<Array<Maybe<GoalsMutationResponse>>>;
  /** update data of the table: "images" */
  update_images?: Maybe<ImagesMutationResponse>;
  /** update single row of the table: "images" */
  update_images_by_pk?: Maybe<Images>;
  /** update multiples rows of table: "images" */
  update_images_many?: Maybe<Array<Maybe<ImagesMutationResponse>>>;
  /** update data of the table: "interests" */
  update_interests?: Maybe<InterestsMutationResponse>;
  /** update single row of the table: "interests" */
  update_interests_by_pk?: Maybe<Interests>;
  /** update multiples rows of table: "interests" */
  update_interests_many?: Maybe<Array<Maybe<InterestsMutationResponse>>>;
  /** update data of the table: "languages" */
  update_languages?: Maybe<LanguagesMutationResponse>;
  /** update single row of the table: "languages" */
  update_languages_by_pk?: Maybe<Languages>;
  /** update multiples rows of table: "languages" */
  update_languages_many?: Maybe<Array<Maybe<LanguagesMutationResponse>>>;
  /** update data of the table: "listenings" */
  update_listenings?: Maybe<ListeningsMutationResponse>;
  /** update single row of the table: "listenings" */
  update_listenings_by_pk?: Maybe<Listenings>;
  /** update multiples rows of table: "listenings" */
  update_listenings_many?: Maybe<Array<Maybe<ListeningsMutationResponse>>>;
  /** update data of the table: "live_class_activities" */
  update_live_class_activities?: Maybe<LiveClassActivitiesMutationResponse>;
  /** update single row of the table: "live_class_activities" */
  update_live_class_activities_by_pk?: Maybe<LiveClassActivities>;
  /** update multiples rows of table: "live_class_activities" */
  update_live_class_activities_many?: Maybe<Array<Maybe<LiveClassActivitiesMutationResponse>>>;
  /** update data of the table: "live_messages" */
  update_live_messages?: Maybe<LiveMessagesMutationResponse>;
  /** update single row of the table: "live_messages" */
  update_live_messages_by_pk?: Maybe<LiveMessages>;
  /** update multiples rows of table: "live_messages" */
  update_live_messages_many?: Maybe<Array<Maybe<LiveMessagesMutationResponse>>>;
  /** update data of the table: "matching_options" */
  update_matching_options?: Maybe<MatchingOptionsMutationResponse>;
  /** update single row of the table: "matching_options" */
  update_matching_options_by_pk?: Maybe<MatchingOptions>;
  /** update multiples rows of table: "matching_options" */
  update_matching_options_many?: Maybe<Array<Maybe<MatchingOptionsMutationResponse>>>;
  /** update data of the table: "matching_responses" */
  update_matching_responses?: Maybe<MatchingResponsesMutationResponse>;
  /** update single row of the table: "matching_responses" */
  update_matching_responses_by_pk?: Maybe<MatchingResponses>;
  /** update multiples rows of table: "matching_responses" */
  update_matching_responses_many?: Maybe<Array<Maybe<MatchingResponsesMutationResponse>>>;
  /** update data of the table: "matchings" */
  update_matchings?: Maybe<MatchingsMutationResponse>;
  /** update single row of the table: "matchings" */
  update_matchings_by_pk?: Maybe<Matchings>;
  /** update multiples rows of table: "matchings" */
  update_matchings_many?: Maybe<Array<Maybe<MatchingsMutationResponse>>>;
  /** update data of the table: "messages" */
  update_messages?: Maybe<MessagesMutationResponse>;
  /** update single row of the table: "messages" */
  update_messages_by_pk?: Maybe<Messages>;
  /** update multiples rows of table: "messages" */
  update_messages_many?: Maybe<Array<Maybe<MessagesMutationResponse>>>;
  /** update data of the table: "multiple_choice_options" */
  update_multiple_choice_options?: Maybe<MultipleChoiceOptionsMutationResponse>;
  /** update single row of the table: "multiple_choice_options" */
  update_multiple_choice_options_by_pk?: Maybe<MultipleChoiceOptions>;
  /** update multiples rows of table: "multiple_choice_options" */
  update_multiple_choice_options_many?: Maybe<Array<Maybe<MultipleChoiceOptionsMutationResponse>>>;
  /** update data of the table: "multiple_choice_responses" */
  update_multiple_choice_responses?: Maybe<MultipleChoiceResponsesMutationResponse>;
  /** update single row of the table: "multiple_choice_responses" */
  update_multiple_choice_responses_by_pk?: Maybe<MultipleChoiceResponses>;
  /** update multiples rows of table: "multiple_choice_responses" */
  update_multiple_choice_responses_many?: Maybe<Array<Maybe<MultipleChoiceResponsesMutationResponse>>>;
  /** update data of the table: "multiple_choices" */
  update_multiple_choices?: Maybe<MultipleChoicesMutationResponse>;
  /** update single row of the table: "multiple_choices" */
  update_multiple_choices_by_pk?: Maybe<MultipleChoices>;
  /** update multiples rows of table: "multiple_choices" */
  update_multiple_choices_many?: Maybe<Array<Maybe<MultipleChoicesMutationResponse>>>;
  /** update data of the table: "open_answer_responses" */
  update_open_answer_responses?: Maybe<OpenAnswerResponsesMutationResponse>;
  /** update single row of the table: "open_answer_responses" */
  update_open_answer_responses_by_pk?: Maybe<OpenAnswerResponses>;
  /** update multiples rows of table: "open_answer_responses" */
  update_open_answer_responses_many?: Maybe<Array<Maybe<OpenAnswerResponsesMutationResponse>>>;
  /** update data of the table: "open_answers" */
  update_open_answers?: Maybe<OpenAnswersMutationResponse>;
  /** update single row of the table: "open_answers" */
  update_open_answers_by_pk?: Maybe<OpenAnswers>;
  /** update multiples rows of table: "open_answers" */
  update_open_answers_many?: Maybe<Array<Maybe<OpenAnswersMutationResponse>>>;
  /** update data of the table: "parts_of_speech" */
  update_parts_of_speech?: Maybe<PartsOfSpeechMutationResponse>;
  /** update single row of the table: "parts_of_speech" */
  update_parts_of_speech_by_pk?: Maybe<PartsOfSpeech>;
  /** update multiples rows of table: "parts_of_speech" */
  update_parts_of_speech_many?: Maybe<Array<Maybe<PartsOfSpeechMutationResponse>>>;
  /** update data of the table: "payments" */
  update_payments?: Maybe<PaymentsMutationResponse>;
  /** update single row of the table: "payments" */
  update_payments_by_pk?: Maybe<Payments>;
  /** update multiples rows of table: "payments" */
  update_payments_many?: Maybe<Array<Maybe<PaymentsMutationResponse>>>;
  /** update data of the table: "phrase_responses" */
  update_phrase_responses?: Maybe<PhraseResponsesMutationResponse>;
  /** update single row of the table: "phrase_responses" */
  update_phrase_responses_by_pk?: Maybe<PhraseResponses>;
  /** update multiples rows of table: "phrase_responses" */
  update_phrase_responses_many?: Maybe<Array<Maybe<PhraseResponsesMutationResponse>>>;
  /** update data of the table: "phrases" */
  update_phrases?: Maybe<PhrasesMutationResponse>;
  /** update single row of the table: "phrases" */
  update_phrases_by_pk?: Maybe<Phrases>;
  /** update multiples rows of table: "phrases" */
  update_phrases_many?: Maybe<Array<Maybe<PhrasesMutationResponse>>>;
  /** update data of the table: "poem_lines" */
  update_poem_lines?: Maybe<PoemLinesMutationResponse>;
  /** update single row of the table: "poem_lines" */
  update_poem_lines_by_pk?: Maybe<PoemLines>;
  /** update multiples rows of table: "poem_lines" */
  update_poem_lines_many?: Maybe<Array<Maybe<PoemLinesMutationResponse>>>;
  /** update data of the table: "poems" */
  update_poems?: Maybe<PoemsMutationResponse>;
  /** update single row of the table: "poems" */
  update_poems_by_pk?: Maybe<Poems>;
  /** update multiples rows of table: "poems" */
  update_poems_many?: Maybe<Array<Maybe<PoemsMutationResponse>>>;
  /** update data of the table: "prepositions" */
  update_prepositions?: Maybe<PrepositionsMutationResponse>;
  /** update single row of the table: "prepositions" */
  update_prepositions_by_pk?: Maybe<Prepositions>;
  /** update multiples rows of table: "prepositions" */
  update_prepositions_many?: Maybe<Array<Maybe<PrepositionsMutationResponse>>>;
  /** update data of the table: "readings" */
  update_readings?: Maybe<ReadingsMutationResponse>;
  /** update single row of the table: "readings" */
  update_readings_by_pk?: Maybe<Readings>;
  /** update multiples rows of table: "readings" */
  update_readings_many?: Maybe<Array<Maybe<ReadingsMutationResponse>>>;
  /** update data of the table: "session_statuses" */
  update_session_statuses?: Maybe<SessionStatusesMutationResponse>;
  /** update single row of the table: "session_statuses" */
  update_session_statuses_by_pk?: Maybe<SessionStatuses>;
  /** update multiples rows of table: "session_statuses" */
  update_session_statuses_many?: Maybe<Array<Maybe<SessionStatusesMutationResponse>>>;
  /** update data of the table: "sessions" */
  update_sessions?: Maybe<SessionsMutationResponse>;
  /** update single row of the table: "sessions" */
  update_sessions_by_pk?: Maybe<Sessions>;
  /** update multiples rows of table: "sessions" */
  update_sessions_many?: Maybe<Array<Maybe<SessionsMutationResponse>>>;
  /** update data of the table: "slots" */
  update_slots?: Maybe<SlotsMutationResponse>;
  /** update single row of the table: "slots" */
  update_slots_by_pk?: Maybe<Slots>;
  /** update multiples rows of table: "slots" */
  update_slots_many?: Maybe<Array<Maybe<SlotsMutationResponse>>>;
  /** update data of the table: "stats" */
  update_stats?: Maybe<StatsMutationResponse>;
  /** update single row of the table: "stats" */
  update_stats_by_pk?: Maybe<Stats>;
  /** update multiples rows of table: "stats" */
  update_stats_many?: Maybe<Array<Maybe<StatsMutationResponse>>>;
  /** update data of the table: "student_class_sessions" */
  update_student_class_sessions?: Maybe<StudentClassSessionsMutationResponse>;
  /** update single row of the table: "student_class_sessions" */
  update_student_class_sessions_by_pk?: Maybe<StudentClassSessions>;
  /** update multiples rows of table: "student_class_sessions" */
  update_student_class_sessions_many?: Maybe<Array<Maybe<StudentClassSessionsMutationResponse>>>;
  /** update data of the table: "student_classes" */
  update_student_classes?: Maybe<StudentClassesMutationResponse>;
  /** update single row of the table: "student_classes" */
  update_student_classes_by_pk?: Maybe<StudentClasses>;
  /** update multiples rows of table: "student_classes" */
  update_student_classes_many?: Maybe<Array<Maybe<StudentClassesMutationResponse>>>;
  /** update data of the table: "student_favorite_teachers" */
  update_student_favorite_teachers?: Maybe<StudentFavoriteTeachersMutationResponse>;
  /** update single row of the table: "student_favorite_teachers" */
  update_student_favorite_teachers_by_pk?: Maybe<StudentFavoriteTeachers>;
  /** update multiples rows of table: "student_favorite_teachers" */
  update_student_favorite_teachers_many?: Maybe<Array<Maybe<StudentFavoriteTeachersMutationResponse>>>;
  /** update data of the table: "student_live_class_activities" */
  update_student_live_class_activities?: Maybe<StudentLiveClassActivitiesMutationResponse>;
  /** update single row of the table: "student_live_class_activities" */
  update_student_live_class_activities_by_pk?: Maybe<StudentLiveClassActivities>;
  /** update multiples rows of table: "student_live_class_activities" */
  update_student_live_class_activities_many?: Maybe<Array<Maybe<StudentLiveClassActivitiesMutationResponse>>>;
  /** update data of the table: "subjects" */
  update_subjects?: Maybe<SubjectsMutationResponse>;
  /** update single row of the table: "subjects" */
  update_subjects_by_pk?: Maybe<Subjects>;
  /** update multiples rows of table: "subjects" */
  update_subjects_many?: Maybe<Array<Maybe<SubjectsMutationResponse>>>;
  /** update data of the table: "subscriptions" */
  update_subscriptions?: Maybe<SubscriptionsMutationResponse>;
  /** update single row of the table: "subscriptions" */
  update_subscriptions_by_pk?: Maybe<Subscriptions>;
  /** update multiples rows of table: "subscriptions" */
  update_subscriptions_many?: Maybe<Array<Maybe<SubscriptionsMutationResponse>>>;
  /** update data of the table: "synonyms" */
  update_synonyms?: Maybe<SynonymsMutationResponse>;
  /** update single row of the table: "synonyms" */
  update_synonyms_by_pk?: Maybe<Synonyms>;
  /** update multiples rows of table: "synonyms" */
  update_synonyms_many?: Maybe<Array<Maybe<SynonymsMutationResponse>>>;
  /** update data of the table: "teacher_credentials" */
  update_teacher_credentials?: Maybe<TeacherCredentialsMutationResponse>;
  /** update single row of the table: "teacher_credentials" */
  update_teacher_credentials_by_pk?: Maybe<TeacherCredentials>;
  /** update multiples rows of table: "teacher_credentials" */
  update_teacher_credentials_many?: Maybe<Array<Maybe<TeacherCredentialsMutationResponse>>>;
  /** update data of the table: "teacher_education" */
  update_teacher_education?: Maybe<TeacherEducationMutationResponse>;
  /** update single row of the table: "teacher_education" */
  update_teacher_education_by_pk?: Maybe<TeacherEducation>;
  /** update multiples rows of table: "teacher_education" */
  update_teacher_education_many?: Maybe<Array<Maybe<TeacherEducationMutationResponse>>>;
  /** update data of the table: "teacher_interests" */
  update_teacher_interests?: Maybe<TeacherInterestsMutationResponse>;
  /** update single row of the table: "teacher_interests" */
  update_teacher_interests_by_pk?: Maybe<TeacherInterests>;
  /** update multiples rows of table: "teacher_interests" */
  update_teacher_interests_many?: Maybe<Array<Maybe<TeacherInterestsMutationResponse>>>;
  /** update data of the table: "teacher_languages" */
  update_teacher_languages?: Maybe<TeacherLanguagesMutationResponse>;
  /** update single row of the table: "teacher_languages" */
  update_teacher_languages_by_pk?: Maybe<TeacherLanguages>;
  /** update multiples rows of table: "teacher_languages" */
  update_teacher_languages_many?: Maybe<Array<Maybe<TeacherLanguagesMutationResponse>>>;
  /** update data of the table: "teacher_subjects" */
  update_teacher_subjects?: Maybe<TeacherSubjectsMutationResponse>;
  /** update single row of the table: "teacher_subjects" */
  update_teacher_subjects_by_pk?: Maybe<TeacherSubjects>;
  /** update multiples rows of table: "teacher_subjects" */
  update_teacher_subjects_many?: Maybe<Array<Maybe<TeacherSubjectsMutationResponse>>>;
  /** update data of the table: "teachers" */
  update_teachers?: Maybe<TeachersMutationResponse>;
  /** update single row of the table: "teachers" */
  update_teachers_by_pk?: Maybe<Teachers>;
  /** update multiples rows of table: "teachers" */
  update_teachers_many?: Maybe<Array<Maybe<TeachersMutationResponse>>>;
  /** update data of the table: "user_courses" */
  update_user_courses?: Maybe<UserCoursesMutationResponse>;
  /** update single row of the table: "user_courses" */
  update_user_courses_by_pk?: Maybe<UserCourses>;
  /** update multiples rows of table: "user_courses" */
  update_user_courses_many?: Maybe<Array<Maybe<UserCoursesMutationResponse>>>;
  /** update data of the table: "user_devices" */
  update_user_devices?: Maybe<UserDevicesMutationResponse>;
  /** update single row of the table: "user_devices" */
  update_user_devices_by_pk?: Maybe<UserDevices>;
  /** update multiples rows of table: "user_devices" */
  update_user_devices_many?: Maybe<Array<Maybe<UserDevicesMutationResponse>>>;
  /** update data of the table: "user_dictionaries" */
  update_user_dictionaries?: Maybe<UserDictionariesMutationResponse>;
  /** update single row of the table: "user_dictionaries" */
  update_user_dictionaries_by_pk?: Maybe<UserDictionaries>;
  /** update multiples rows of table: "user_dictionaries" */
  update_user_dictionaries_many?: Maybe<Array<Maybe<UserDictionariesMutationResponse>>>;
  /** update data of the table: "user_messages" */
  update_user_messages?: Maybe<UserMessagesMutationResponse>;
  /** update single row of the table: "user_messages" */
  update_user_messages_by_pk?: Maybe<UserMessages>;
  /** update multiples rows of table: "user_messages" */
  update_user_messages_many?: Maybe<Array<Maybe<UserMessagesMutationResponse>>>;
  /** update data of the table: "user_words" */
  update_user_words?: Maybe<UserWordsMutationResponse>;
  /** update single row of the table: "user_words" */
  update_user_words_by_pk?: Maybe<UserWords>;
  /** update data of the table: "user_words_count" */
  update_user_words_count?: Maybe<UserWordsCountMutationResponse>;
  /** update single row of the table: "user_words_count" */
  update_user_words_count_by_pk?: Maybe<UserWordsCount>;
  /** update multiples rows of table: "user_words_count" */
  update_user_words_count_many?: Maybe<Array<Maybe<UserWordsCountMutationResponse>>>;
  /** update multiples rows of table: "user_words" */
  update_user_words_many?: Maybe<Array<Maybe<UserWordsMutationResponse>>>;
  /** update data of the table: "users" */
  update_users?: Maybe<UsersMutationResponse>;
  /** update single row of the table: "users" */
  update_users_by_pk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  update_users_many?: Maybe<Array<Maybe<UsersMutationResponse>>>;
  /** update data of the table: "vocabulary_sets" */
  update_vocabulary_sets?: Maybe<VocabularySetsMutationResponse>;
  /** update single row of the table: "vocabulary_sets" */
  update_vocabulary_sets_by_pk?: Maybe<VocabularySets>;
  /** update multiples rows of table: "vocabulary_sets" */
  update_vocabulary_sets_many?: Maybe<Array<Maybe<VocabularySetsMutationResponse>>>;
  /** update data of the table: "vocabulary_words" */
  update_vocabulary_words?: Maybe<VocabularyWordsMutationResponse>;
  /** update single row of the table: "vocabulary_words" */
  update_vocabulary_words_by_pk?: Maybe<VocabularyWords>;
  /** update multiples rows of table: "vocabulary_words" */
  update_vocabulary_words_many?: Maybe<Array<Maybe<VocabularyWordsMutationResponse>>>;
  /** update data of the table: "wordnet.english_words" */
  update_wordnet_english_words?: Maybe<WordnetEnglishWordsMutationResponse>;
  /** update single row of the table: "wordnet.english_words" */
  update_wordnet_english_words_by_pk?: Maybe<WordnetEnglishWords>;
  /** update multiples rows of table: "wordnet.english_words" */
  update_wordnet_english_words_many?: Maybe<Array<Maybe<WordnetEnglishWordsMutationResponse>>>;
  /** update data of the table: "wordnet.synsets" */
  update_wordnet_synsets?: Maybe<WordnetSynsetsMutationResponse>;
  /** update single row of the table: "wordnet.synsets" */
  update_wordnet_synsets_by_pk?: Maybe<WordnetSynsets>;
  /** update multiples rows of table: "wordnet.synsets" */
  update_wordnet_synsets_many?: Maybe<Array<Maybe<WordnetSynsetsMutationResponse>>>;
};


/** mutation root */
export type MutationRootDeleteActivitySetAssignmentsArgs = {
  where: ActivitySetAssignmentsBoolExp;
};


/** mutation root */
export type MutationRootDeleteActivitySetAssignmentsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteActivitySetReportsArgs = {
  where: ActivitySetReportsBoolExp;
};


/** mutation root */
export type MutationRootDeleteActivitySetReportsByPkArgs = {
  activitySetId: Scalars['Int']['input'];
  createdBy: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteActivitySetResponsesArgs = {
  where: ActivitySetResponsesBoolExp;
};


/** mutation root */
export type MutationRootDeleteActivitySetResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteActivitySetsArgs = {
  where: ActivitySetsBoolExp;
};


/** mutation root */
export type MutationRootDeleteActivitySetsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteAddressesArgs = {
  where: AddressesBoolExp;
};


/** mutation root */
export type MutationRootDeleteAddressesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteAnagramResponsesArgs = {
  where: AnagramResponsesBoolExp;
};


/** mutation root */
export type MutationRootDeleteAnagramResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteAnagramsArgs = {
  where: AnagramsBoolExp;
};


/** mutation root */
export type MutationRootDeleteAnagramsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteAnnotationsArgs = {
  where: AnnotationsBoolExp;
};


/** mutation root */
export type MutationRootDeleteAnnotationsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteApplicationReviewsArgs = {
  where: ApplicationReviewsBoolExp;
};


/** mutation root */
export type MutationRootDeleteApplicationReviewsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteAvailabilityTimesArgs = {
  where: AvailabilityTimesBoolExp;
};


/** mutation root */
export type MutationRootDeleteAvailabilityTimesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteCefrLevelsArgs = {
  where: CefrLevelsBoolExp;
};


/** mutation root */
export type MutationRootDeleteCefrLevelsByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteClassActivitySetsArgs = {
  where: ClassActivitySetsBoolExp;
};


/** mutation root */
export type MutationRootDeleteClassActivitySetsByPkArgs = {
  activitySetId: Scalars['Int']['input'];
  classId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteClassAnnotationsArgs = {
  where: ClassAnnotationsBoolExp;
};


/** mutation root */
export type MutationRootDeleteClassAnnotationsByPkArgs = {
  annotationId: Scalars['Int']['input'];
  classId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteClassCoursesArgs = {
  where: ClassCoursesBoolExp;
};


/** mutation root */
export type MutationRootDeleteClassCoursesByPkArgs = {
  classId: Scalars['Int']['input'];
  courseId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteClassSessionsArgs = {
  where: ClassSessionsBoolExp;
};


/** mutation root */
export type MutationRootDeleteClassSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteClassSlotBookingsArgs = {
  where: ClassSlotBookingsBoolExp;
};


/** mutation root */
export type MutationRootDeleteClassSlotBookingsByPkArgs = {
  slotId: Scalars['Int']['input'];
  studentId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteClassesArgs = {
  where: ClassesBoolExp;
};


/** mutation root */
export type MutationRootDeleteClassesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteCourseActivitiesArgs = {
  where: CourseActivitiesBoolExp;
};


/** mutation root */
export type MutationRootDeleteCourseActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteCourseReviewsArgs = {
  where: CourseReviewsBoolExp;
};


/** mutation root */
export type MutationRootDeleteCourseReviewsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteCoursesArgs = {
  where: CoursesBoolExp;
};


/** mutation root */
export type MutationRootDeleteCoursesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteDailyStatsArgs = {
  where: DailyStatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteDailyStatsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteDictionariesArgs = {
  where: DictionariesBoolExp;
};


/** mutation root */
export type MutationRootDeleteDictionariesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteEmojisArgs = {
  where: EmojisBoolExp;
};


/** mutation root */
export type MutationRootDeleteEmojisByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteEmployeesArgs = {
  where: EmployeesBoolExp;
};


/** mutation root */
export type MutationRootDeleteEmployeesByPkArgs = {
  userId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteExampleJoinsArgs = {
  where: ExampleJoinsBoolExp;
};


/** mutation root */
export type MutationRootDeleteExampleJoinsByPkArgs = {
  from_id: Scalars['Int']['input'];
  to_id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteExamplesArgs = {
  where: ExamplesBoolExp;
};


/** mutation root */
export type MutationRootDeleteExamplesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteExpiredRefreshTokensArgs = {
  where: ExpiredRefreshTokensBoolExp;
};


/** mutation root */
export type MutationRootDeleteExpiredRefreshTokensByPkArgs = {
  token: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteFillInTheBlankOptionsArgs = {
  where: FillInTheBlankOptionsBoolExp;
};


/** mutation root */
export type MutationRootDeleteFillInTheBlankOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteFillInTheBlankResponsesArgs = {
  where: FillInTheBlankResponsesBoolExp;
};


/** mutation root */
export type MutationRootDeleteFillInTheBlankResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteFillInTheBlanksArgs = {
  where: FillInTheBlanksBoolExp;
};


/** mutation root */
export type MutationRootDeleteFillInTheBlanksByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteGameDailiesArgs = {
  where: GameDailiesBoolExp;
};


/** mutation root */
export type MutationRootDeleteGameDailiesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteGameDifficultyArgs = {
  where: GameDifficultyBoolExp;
};


/** mutation root */
export type MutationRootDeleteGameDifficultyByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteGameTypesArgs = {
  where: GameTypesBoolExp;
};


/** mutation root */
export type MutationRootDeleteGameTypesByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteGameUsersArgs = {
  where: GameUsersBoolExp;
};


/** mutation root */
export type MutationRootDeleteGameUsersByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteGamesArgs = {
  where: GamesBoolExp;
};


/** mutation root */
export type MutationRootDeleteGamesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteGoalsArgs = {
  where: GoalsBoolExp;
};


/** mutation root */
export type MutationRootDeleteGoalsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteImagesArgs = {
  where: ImagesBoolExp;
};


/** mutation root */
export type MutationRootDeleteImagesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteInterestsArgs = {
  where: InterestsBoolExp;
};


/** mutation root */
export type MutationRootDeleteInterestsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteLanguagesArgs = {
  where: LanguagesBoolExp;
};


/** mutation root */
export type MutationRootDeleteLanguagesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteListeningsArgs = {
  where: ListeningsBoolExp;
};


/** mutation root */
export type MutationRootDeleteListeningsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteLiveClassActivitiesArgs = {
  where: LiveClassActivitiesBoolExp;
};


/** mutation root */
export type MutationRootDeleteLiveClassActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteLiveMessagesArgs = {
  where: LiveMessagesBoolExp;
};


/** mutation root */
export type MutationRootDeleteLiveMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteMatchingOptionsArgs = {
  where: MatchingOptionsBoolExp;
};


/** mutation root */
export type MutationRootDeleteMatchingOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteMatchingResponsesArgs = {
  where: MatchingResponsesBoolExp;
};


/** mutation root */
export type MutationRootDeleteMatchingResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteMatchingsArgs = {
  where: MatchingsBoolExp;
};


/** mutation root */
export type MutationRootDeleteMatchingsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteMessagesArgs = {
  where: MessagesBoolExp;
};


/** mutation root */
export type MutationRootDeleteMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteMultipleChoiceOptionsArgs = {
  where: MultipleChoiceOptionsBoolExp;
};


/** mutation root */
export type MutationRootDeleteMultipleChoiceOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteMultipleChoiceResponsesArgs = {
  where: MultipleChoiceResponsesBoolExp;
};


/** mutation root */
export type MutationRootDeleteMultipleChoiceResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteMultipleChoicesArgs = {
  where: MultipleChoicesBoolExp;
};


/** mutation root */
export type MutationRootDeleteMultipleChoicesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteOpenAnswerResponsesArgs = {
  where: OpenAnswerResponsesBoolExp;
};


/** mutation root */
export type MutationRootDeleteOpenAnswerResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteOpenAnswersArgs = {
  where: OpenAnswersBoolExp;
};


/** mutation root */
export type MutationRootDeleteOpenAnswersByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeletePartsOfSpeechArgs = {
  where: PartsOfSpeechBoolExp;
};


/** mutation root */
export type MutationRootDeletePartsOfSpeechByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeletePaymentsArgs = {
  where: PaymentsBoolExp;
};


/** mutation root */
export type MutationRootDeletePaymentsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeletePhraseResponsesArgs = {
  where: PhraseResponsesBoolExp;
};


/** mutation root */
export type MutationRootDeletePhraseResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeletePhrasesArgs = {
  where: PhrasesBoolExp;
};


/** mutation root */
export type MutationRootDeletePhrasesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeletePoemLinesArgs = {
  where: PoemLinesBoolExp;
};


/** mutation root */
export type MutationRootDeletePoemLinesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeletePoemsArgs = {
  where: PoemsBoolExp;
};


/** mutation root */
export type MutationRootDeletePoemsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeletePrepositionsArgs = {
  where: PrepositionsBoolExp;
};


/** mutation root */
export type MutationRootDeletePrepositionsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteReadingsArgs = {
  where: ReadingsBoolExp;
};


/** mutation root */
export type MutationRootDeleteReadingsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteSessionStatusesArgs = {
  where: SessionStatusesBoolExp;
};


/** mutation root */
export type MutationRootDeleteSessionStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteSessionsArgs = {
  where: SessionsBoolExp;
};


/** mutation root */
export type MutationRootDeleteSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteSlotsArgs = {
  where: SlotsBoolExp;
};


/** mutation root */
export type MutationRootDeleteSlotsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteStatsArgs = {
  where: StatsBoolExp;
};


/** mutation root */
export type MutationRootDeleteStatsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteStudentClassSessionsArgs = {
  where: StudentClassSessionsBoolExp;
};


/** mutation root */
export type MutationRootDeleteStudentClassSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteStudentClassesArgs = {
  where: StudentClassesBoolExp;
};


/** mutation root */
export type MutationRootDeleteStudentClassesByPkArgs = {
  classId: Scalars['Int']['input'];
  studentId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteStudentFavoriteTeachersArgs = {
  where: StudentFavoriteTeachersBoolExp;
};


/** mutation root */
export type MutationRootDeleteStudentFavoriteTeachersByPkArgs = {
  studentId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteStudentLiveClassActivitiesArgs = {
  where: StudentLiveClassActivitiesBoolExp;
};


/** mutation root */
export type MutationRootDeleteStudentLiveClassActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteSubjectsArgs = {
  where: SubjectsBoolExp;
};


/** mutation root */
export type MutationRootDeleteSubjectsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteSubscriptionsArgs = {
  where: SubscriptionsBoolExp;
};


/** mutation root */
export type MutationRootDeleteSubscriptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteSynonymsArgs = {
  where: SynonymsBoolExp;
};


/** mutation root */
export type MutationRootDeleteSynonymsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteTeacherCredentialsArgs = {
  where: TeacherCredentialsBoolExp;
};


/** mutation root */
export type MutationRootDeleteTeacherCredentialsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteTeacherEducationArgs = {
  where: TeacherEducationBoolExp;
};


/** mutation root */
export type MutationRootDeleteTeacherEducationByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteTeacherInterestsArgs = {
  where: TeacherInterestsBoolExp;
};


/** mutation root */
export type MutationRootDeleteTeacherInterestsByPkArgs = {
  interestId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteTeacherLanguagesArgs = {
  where: TeacherLanguagesBoolExp;
};


/** mutation root */
export type MutationRootDeleteTeacherLanguagesByPkArgs = {
  languageId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteTeacherSubjectsArgs = {
  where: TeacherSubjectsBoolExp;
};


/** mutation root */
export type MutationRootDeleteTeacherSubjectsByPkArgs = {
  subjectId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteTeachersArgs = {
  where: TeachersBoolExp;
};


/** mutation root */
export type MutationRootDeleteTeachersByPkArgs = {
  userId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteUserCoursesArgs = {
  where: UserCoursesBoolExp;
};


/** mutation root */
export type MutationRootDeleteUserCoursesByPkArgs = {
  courseId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteUserDevicesArgs = {
  where: UserDevicesBoolExp;
};


/** mutation root */
export type MutationRootDeleteUserDevicesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteUserDictionariesArgs = {
  where: UserDictionariesBoolExp;
};


/** mutation root */
export type MutationRootDeleteUserDictionariesByPkArgs = {
  dictionaryId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteUserMessagesArgs = {
  where: UserMessagesBoolExp;
};


/** mutation root */
export type MutationRootDeleteUserMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteUserWordsArgs = {
  where: UserWordsBoolExp;
};


/** mutation root */
export type MutationRootDeleteUserWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteUserWordsCountArgs = {
  where: UserWordsCountBoolExp;
};


/** mutation root */
export type MutationRootDeleteUserWordsCountByPkArgs = {
  date: Scalars['date']['input'];
};


/** mutation root */
export type MutationRootDeleteUsersArgs = {
  where: UsersBoolExp;
};


/** mutation root */
export type MutationRootDeleteUsersByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteVocabularySetsArgs = {
  where: VocabularySetsBoolExp;
};


/** mutation root */
export type MutationRootDeleteVocabularySetsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteVocabularyWordsArgs = {
  where: VocabularyWordsBoolExp;
};


/** mutation root */
export type MutationRootDeleteVocabularyWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteWordnetEnglishWordsArgs = {
  where: WordnetEnglishWordsBoolExp;
};


/** mutation root */
export type MutationRootDeleteWordnetEnglishWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteWordnetSynsetsArgs = {
  where: WordnetSynsetsBoolExp;
};


/** mutation root */
export type MutationRootDeleteWordnetSynsetsByPkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootInsertActivitySetAssignmentsArgs = {
  objects: Array<ActivitySetAssignmentsInsertInput>;
  on_conflict?: InputMaybe<ActivitySetAssignmentsOnConflict>;
};


/** mutation root */
export type MutationRootInsertActivitySetAssignmentsOneArgs = {
  object: ActivitySetAssignmentsInsertInput;
  on_conflict?: InputMaybe<ActivitySetAssignmentsOnConflict>;
};


/** mutation root */
export type MutationRootInsertActivitySetReportsArgs = {
  objects: Array<ActivitySetReportsInsertInput>;
  on_conflict?: InputMaybe<ActivitySetReportsOnConflict>;
};


/** mutation root */
export type MutationRootInsertActivitySetReportsOneArgs = {
  object: ActivitySetReportsInsertInput;
  on_conflict?: InputMaybe<ActivitySetReportsOnConflict>;
};


/** mutation root */
export type MutationRootInsertActivitySetResponsesArgs = {
  objects: Array<ActivitySetResponsesInsertInput>;
  on_conflict?: InputMaybe<ActivitySetResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertActivitySetResponsesOneArgs = {
  object: ActivitySetResponsesInsertInput;
  on_conflict?: InputMaybe<ActivitySetResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertActivitySetsArgs = {
  objects: Array<ActivitySetsInsertInput>;
  on_conflict?: InputMaybe<ActivitySetsOnConflict>;
};


/** mutation root */
export type MutationRootInsertActivitySetsOneArgs = {
  object: ActivitySetsInsertInput;
  on_conflict?: InputMaybe<ActivitySetsOnConflict>;
};


/** mutation root */
export type MutationRootInsertAddressesArgs = {
  objects: Array<AddressesInsertInput>;
  on_conflict?: InputMaybe<AddressesOnConflict>;
};


/** mutation root */
export type MutationRootInsertAddressesOneArgs = {
  object: AddressesInsertInput;
  on_conflict?: InputMaybe<AddressesOnConflict>;
};


/** mutation root */
export type MutationRootInsertAnagramResponsesArgs = {
  objects: Array<AnagramResponsesInsertInput>;
  on_conflict?: InputMaybe<AnagramResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertAnagramResponsesOneArgs = {
  object: AnagramResponsesInsertInput;
  on_conflict?: InputMaybe<AnagramResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertAnagramsArgs = {
  objects: Array<AnagramsInsertInput>;
  on_conflict?: InputMaybe<AnagramsOnConflict>;
};


/** mutation root */
export type MutationRootInsertAnagramsOneArgs = {
  object: AnagramsInsertInput;
  on_conflict?: InputMaybe<AnagramsOnConflict>;
};


/** mutation root */
export type MutationRootInsertAnnotationsArgs = {
  objects: Array<AnnotationsInsertInput>;
  on_conflict?: InputMaybe<AnnotationsOnConflict>;
};


/** mutation root */
export type MutationRootInsertAnnotationsOneArgs = {
  object: AnnotationsInsertInput;
  on_conflict?: InputMaybe<AnnotationsOnConflict>;
};


/** mutation root */
export type MutationRootInsertApplicationReviewsArgs = {
  objects: Array<ApplicationReviewsInsertInput>;
  on_conflict?: InputMaybe<ApplicationReviewsOnConflict>;
};


/** mutation root */
export type MutationRootInsertApplicationReviewsOneArgs = {
  object: ApplicationReviewsInsertInput;
  on_conflict?: InputMaybe<ApplicationReviewsOnConflict>;
};


/** mutation root */
export type MutationRootInsertAvailabilityTimesArgs = {
  objects: Array<AvailabilityTimesInsertInput>;
  on_conflict?: InputMaybe<AvailabilityTimesOnConflict>;
};


/** mutation root */
export type MutationRootInsertAvailabilityTimesOneArgs = {
  object: AvailabilityTimesInsertInput;
  on_conflict?: InputMaybe<AvailabilityTimesOnConflict>;
};


/** mutation root */
export type MutationRootInsertCefrLevelsArgs = {
  objects: Array<CefrLevelsInsertInput>;
  on_conflict?: InputMaybe<CefrLevelsOnConflict>;
};


/** mutation root */
export type MutationRootInsertCefrLevelsOneArgs = {
  object: CefrLevelsInsertInput;
  on_conflict?: InputMaybe<CefrLevelsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassActivitySetsArgs = {
  objects: Array<ClassActivitySetsInsertInput>;
  on_conflict?: InputMaybe<ClassActivitySetsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassActivitySetsOneArgs = {
  object: ClassActivitySetsInsertInput;
  on_conflict?: InputMaybe<ClassActivitySetsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassAnnotationsArgs = {
  objects: Array<ClassAnnotationsInsertInput>;
  on_conflict?: InputMaybe<ClassAnnotationsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassAnnotationsOneArgs = {
  object: ClassAnnotationsInsertInput;
  on_conflict?: InputMaybe<ClassAnnotationsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassCoursesArgs = {
  objects: Array<ClassCoursesInsertInput>;
  on_conflict?: InputMaybe<ClassCoursesOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassCoursesOneArgs = {
  object: ClassCoursesInsertInput;
  on_conflict?: InputMaybe<ClassCoursesOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassSessionsArgs = {
  objects: Array<ClassSessionsInsertInput>;
  on_conflict?: InputMaybe<ClassSessionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassSessionsOneArgs = {
  object: ClassSessionsInsertInput;
  on_conflict?: InputMaybe<ClassSessionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassSlotBookingsArgs = {
  objects: Array<ClassSlotBookingsInsertInput>;
  on_conflict?: InputMaybe<ClassSlotBookingsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassSlotBookingsOneArgs = {
  object: ClassSlotBookingsInsertInput;
  on_conflict?: InputMaybe<ClassSlotBookingsOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassesArgs = {
  objects: Array<ClassesInsertInput>;
  on_conflict?: InputMaybe<ClassesOnConflict>;
};


/** mutation root */
export type MutationRootInsertClassesOneArgs = {
  object: ClassesInsertInput;
  on_conflict?: InputMaybe<ClassesOnConflict>;
};


/** mutation root */
export type MutationRootInsertCourseActivitiesArgs = {
  objects: Array<CourseActivitiesInsertInput>;
  on_conflict?: InputMaybe<CourseActivitiesOnConflict>;
};


/** mutation root */
export type MutationRootInsertCourseActivitiesOneArgs = {
  object: CourseActivitiesInsertInput;
  on_conflict?: InputMaybe<CourseActivitiesOnConflict>;
};


/** mutation root */
export type MutationRootInsertCourseReviewsArgs = {
  objects: Array<CourseReviewsInsertInput>;
  on_conflict?: InputMaybe<CourseReviewsOnConflict>;
};


/** mutation root */
export type MutationRootInsertCourseReviewsOneArgs = {
  object: CourseReviewsInsertInput;
  on_conflict?: InputMaybe<CourseReviewsOnConflict>;
};


/** mutation root */
export type MutationRootInsertCoursesArgs = {
  objects: Array<CoursesInsertInput>;
  on_conflict?: InputMaybe<CoursesOnConflict>;
};


/** mutation root */
export type MutationRootInsertCoursesOneArgs = {
  object: CoursesInsertInput;
  on_conflict?: InputMaybe<CoursesOnConflict>;
};


/** mutation root */
export type MutationRootInsertDailyStatsArgs = {
  objects: Array<DailyStatsInsertInput>;
  on_conflict?: InputMaybe<DailyStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertDailyStatsOneArgs = {
  object: DailyStatsInsertInput;
  on_conflict?: InputMaybe<DailyStatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertDictionariesArgs = {
  objects: Array<DictionariesInsertInput>;
  on_conflict?: InputMaybe<DictionariesOnConflict>;
};


/** mutation root */
export type MutationRootInsertDictionariesOneArgs = {
  object: DictionariesInsertInput;
  on_conflict?: InputMaybe<DictionariesOnConflict>;
};


/** mutation root */
export type MutationRootInsertEmojisArgs = {
  objects: Array<EmojisInsertInput>;
  on_conflict?: InputMaybe<EmojisOnConflict>;
};


/** mutation root */
export type MutationRootInsertEmojisOneArgs = {
  object: EmojisInsertInput;
  on_conflict?: InputMaybe<EmojisOnConflict>;
};


/** mutation root */
export type MutationRootInsertEmployeesArgs = {
  objects: Array<EmployeesInsertInput>;
  on_conflict?: InputMaybe<EmployeesOnConflict>;
};


/** mutation root */
export type MutationRootInsertEmployeesOneArgs = {
  object: EmployeesInsertInput;
  on_conflict?: InputMaybe<EmployeesOnConflict>;
};


/** mutation root */
export type MutationRootInsertExampleJoinsArgs = {
  objects: Array<ExampleJoinsInsertInput>;
  on_conflict?: InputMaybe<ExampleJoinsOnConflict>;
};


/** mutation root */
export type MutationRootInsertExampleJoinsOneArgs = {
  object: ExampleJoinsInsertInput;
  on_conflict?: InputMaybe<ExampleJoinsOnConflict>;
};


/** mutation root */
export type MutationRootInsertExamplesArgs = {
  objects: Array<ExamplesInsertInput>;
  on_conflict?: InputMaybe<ExamplesOnConflict>;
};


/** mutation root */
export type MutationRootInsertExamplesOneArgs = {
  object: ExamplesInsertInput;
  on_conflict?: InputMaybe<ExamplesOnConflict>;
};


/** mutation root */
export type MutationRootInsertExpiredRefreshTokensArgs = {
  objects: Array<ExpiredRefreshTokensInsertInput>;
  on_conflict?: InputMaybe<ExpiredRefreshTokensOnConflict>;
};


/** mutation root */
export type MutationRootInsertExpiredRefreshTokensOneArgs = {
  object: ExpiredRefreshTokensInsertInput;
  on_conflict?: InputMaybe<ExpiredRefreshTokensOnConflict>;
};


/** mutation root */
export type MutationRootInsertFillInTheBlankOptionsArgs = {
  objects: Array<FillInTheBlankOptionsInsertInput>;
  on_conflict?: InputMaybe<FillInTheBlankOptionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertFillInTheBlankOptionsOneArgs = {
  object: FillInTheBlankOptionsInsertInput;
  on_conflict?: InputMaybe<FillInTheBlankOptionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertFillInTheBlankResponsesArgs = {
  objects: Array<FillInTheBlankResponsesInsertInput>;
  on_conflict?: InputMaybe<FillInTheBlankResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertFillInTheBlankResponsesOneArgs = {
  object: FillInTheBlankResponsesInsertInput;
  on_conflict?: InputMaybe<FillInTheBlankResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertFillInTheBlanksArgs = {
  objects: Array<FillInTheBlanksInsertInput>;
  on_conflict?: InputMaybe<FillInTheBlanksOnConflict>;
};


/** mutation root */
export type MutationRootInsertFillInTheBlanksOneArgs = {
  object: FillInTheBlanksInsertInput;
  on_conflict?: InputMaybe<FillInTheBlanksOnConflict>;
};


/** mutation root */
export type MutationRootInsertGameDailiesArgs = {
  objects: Array<GameDailiesInsertInput>;
  on_conflict?: InputMaybe<GameDailiesOnConflict>;
};


/** mutation root */
export type MutationRootInsertGameDailiesOneArgs = {
  object: GameDailiesInsertInput;
  on_conflict?: InputMaybe<GameDailiesOnConflict>;
};


/** mutation root */
export type MutationRootInsertGameDifficultyArgs = {
  objects: Array<GameDifficultyInsertInput>;
  on_conflict?: InputMaybe<GameDifficultyOnConflict>;
};


/** mutation root */
export type MutationRootInsertGameDifficultyOneArgs = {
  object: GameDifficultyInsertInput;
  on_conflict?: InputMaybe<GameDifficultyOnConflict>;
};


/** mutation root */
export type MutationRootInsertGameTypesArgs = {
  objects: Array<GameTypesInsertInput>;
  on_conflict?: InputMaybe<GameTypesOnConflict>;
};


/** mutation root */
export type MutationRootInsertGameTypesOneArgs = {
  object: GameTypesInsertInput;
  on_conflict?: InputMaybe<GameTypesOnConflict>;
};


/** mutation root */
export type MutationRootInsertGameUsersArgs = {
  objects: Array<GameUsersInsertInput>;
  on_conflict?: InputMaybe<GameUsersOnConflict>;
};


/** mutation root */
export type MutationRootInsertGameUsersOneArgs = {
  object: GameUsersInsertInput;
  on_conflict?: InputMaybe<GameUsersOnConflict>;
};


/** mutation root */
export type MutationRootInsertGamesArgs = {
  objects: Array<GamesInsertInput>;
  on_conflict?: InputMaybe<GamesOnConflict>;
};


/** mutation root */
export type MutationRootInsertGamesOneArgs = {
  object: GamesInsertInput;
  on_conflict?: InputMaybe<GamesOnConflict>;
};


/** mutation root */
export type MutationRootInsertGoalsArgs = {
  objects: Array<GoalsInsertInput>;
  on_conflict?: InputMaybe<GoalsOnConflict>;
};


/** mutation root */
export type MutationRootInsertGoalsOneArgs = {
  object: GoalsInsertInput;
  on_conflict?: InputMaybe<GoalsOnConflict>;
};


/** mutation root */
export type MutationRootInsertImagesArgs = {
  objects: Array<ImagesInsertInput>;
  on_conflict?: InputMaybe<ImagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertImagesOneArgs = {
  object: ImagesInsertInput;
  on_conflict?: InputMaybe<ImagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertInterestsArgs = {
  objects: Array<InterestsInsertInput>;
  on_conflict?: InputMaybe<InterestsOnConflict>;
};


/** mutation root */
export type MutationRootInsertInterestsOneArgs = {
  object: InterestsInsertInput;
  on_conflict?: InputMaybe<InterestsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLanguagesArgs = {
  objects: Array<LanguagesInsertInput>;
  on_conflict?: InputMaybe<LanguagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertLanguagesOneArgs = {
  object: LanguagesInsertInput;
  on_conflict?: InputMaybe<LanguagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertListeningsArgs = {
  objects: Array<ListeningsInsertInput>;
  on_conflict?: InputMaybe<ListeningsOnConflict>;
};


/** mutation root */
export type MutationRootInsertListeningsOneArgs = {
  object: ListeningsInsertInput;
  on_conflict?: InputMaybe<ListeningsOnConflict>;
};


/** mutation root */
export type MutationRootInsertLiveClassActivitiesArgs = {
  objects: Array<LiveClassActivitiesInsertInput>;
  on_conflict?: InputMaybe<LiveClassActivitiesOnConflict>;
};


/** mutation root */
export type MutationRootInsertLiveClassActivitiesOneArgs = {
  object: LiveClassActivitiesInsertInput;
  on_conflict?: InputMaybe<LiveClassActivitiesOnConflict>;
};


/** mutation root */
export type MutationRootInsertLiveMessagesArgs = {
  objects: Array<LiveMessagesInsertInput>;
  on_conflict?: InputMaybe<LiveMessagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertLiveMessagesOneArgs = {
  object: LiveMessagesInsertInput;
  on_conflict?: InputMaybe<LiveMessagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertMatchingOptionsArgs = {
  objects: Array<MatchingOptionsInsertInput>;
  on_conflict?: InputMaybe<MatchingOptionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertMatchingOptionsOneArgs = {
  object: MatchingOptionsInsertInput;
  on_conflict?: InputMaybe<MatchingOptionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertMatchingResponsesArgs = {
  objects: Array<MatchingResponsesInsertInput>;
  on_conflict?: InputMaybe<MatchingResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertMatchingResponsesOneArgs = {
  object: MatchingResponsesInsertInput;
  on_conflict?: InputMaybe<MatchingResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertMatchingsArgs = {
  objects: Array<MatchingsInsertInput>;
  on_conflict?: InputMaybe<MatchingsOnConflict>;
};


/** mutation root */
export type MutationRootInsertMatchingsOneArgs = {
  object: MatchingsInsertInput;
  on_conflict?: InputMaybe<MatchingsOnConflict>;
};


/** mutation root */
export type MutationRootInsertMessagesArgs = {
  objects: Array<MessagesInsertInput>;
  on_conflict?: InputMaybe<MessagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertMessagesOneArgs = {
  object: MessagesInsertInput;
  on_conflict?: InputMaybe<MessagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertMultipleChoiceOptionsArgs = {
  objects: Array<MultipleChoiceOptionsInsertInput>;
  on_conflict?: InputMaybe<MultipleChoiceOptionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertMultipleChoiceOptionsOneArgs = {
  object: MultipleChoiceOptionsInsertInput;
  on_conflict?: InputMaybe<MultipleChoiceOptionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertMultipleChoiceResponsesArgs = {
  objects: Array<MultipleChoiceResponsesInsertInput>;
  on_conflict?: InputMaybe<MultipleChoiceResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertMultipleChoiceResponsesOneArgs = {
  object: MultipleChoiceResponsesInsertInput;
  on_conflict?: InputMaybe<MultipleChoiceResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertMultipleChoicesArgs = {
  objects: Array<MultipleChoicesInsertInput>;
  on_conflict?: InputMaybe<MultipleChoicesOnConflict>;
};


/** mutation root */
export type MutationRootInsertMultipleChoicesOneArgs = {
  object: MultipleChoicesInsertInput;
  on_conflict?: InputMaybe<MultipleChoicesOnConflict>;
};


/** mutation root */
export type MutationRootInsertOpenAnswerResponsesArgs = {
  objects: Array<OpenAnswerResponsesInsertInput>;
  on_conflict?: InputMaybe<OpenAnswerResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertOpenAnswerResponsesOneArgs = {
  object: OpenAnswerResponsesInsertInput;
  on_conflict?: InputMaybe<OpenAnswerResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertOpenAnswersArgs = {
  objects: Array<OpenAnswersInsertInput>;
  on_conflict?: InputMaybe<OpenAnswersOnConflict>;
};


/** mutation root */
export type MutationRootInsertOpenAnswersOneArgs = {
  object: OpenAnswersInsertInput;
  on_conflict?: InputMaybe<OpenAnswersOnConflict>;
};


/** mutation root */
export type MutationRootInsertPartsOfSpeechArgs = {
  objects: Array<PartsOfSpeechInsertInput>;
  on_conflict?: InputMaybe<PartsOfSpeechOnConflict>;
};


/** mutation root */
export type MutationRootInsertPartsOfSpeechOneArgs = {
  object: PartsOfSpeechInsertInput;
  on_conflict?: InputMaybe<PartsOfSpeechOnConflict>;
};


/** mutation root */
export type MutationRootInsertPaymentsArgs = {
  objects: Array<PaymentsInsertInput>;
  on_conflict?: InputMaybe<PaymentsOnConflict>;
};


/** mutation root */
export type MutationRootInsertPaymentsOneArgs = {
  object: PaymentsInsertInput;
  on_conflict?: InputMaybe<PaymentsOnConflict>;
};


/** mutation root */
export type MutationRootInsertPhraseResponsesArgs = {
  objects: Array<PhraseResponsesInsertInput>;
  on_conflict?: InputMaybe<PhraseResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertPhraseResponsesOneArgs = {
  object: PhraseResponsesInsertInput;
  on_conflict?: InputMaybe<PhraseResponsesOnConflict>;
};


/** mutation root */
export type MutationRootInsertPhrasesArgs = {
  objects: Array<PhrasesInsertInput>;
  on_conflict?: InputMaybe<PhrasesOnConflict>;
};


/** mutation root */
export type MutationRootInsertPhrasesOneArgs = {
  object: PhrasesInsertInput;
  on_conflict?: InputMaybe<PhrasesOnConflict>;
};


/** mutation root */
export type MutationRootInsertPoemLinesArgs = {
  objects: Array<PoemLinesInsertInput>;
  on_conflict?: InputMaybe<PoemLinesOnConflict>;
};


/** mutation root */
export type MutationRootInsertPoemLinesOneArgs = {
  object: PoemLinesInsertInput;
  on_conflict?: InputMaybe<PoemLinesOnConflict>;
};


/** mutation root */
export type MutationRootInsertPoemsArgs = {
  objects: Array<PoemsInsertInput>;
  on_conflict?: InputMaybe<PoemsOnConflict>;
};


/** mutation root */
export type MutationRootInsertPoemsOneArgs = {
  object: PoemsInsertInput;
  on_conflict?: InputMaybe<PoemsOnConflict>;
};


/** mutation root */
export type MutationRootInsertPrepositionsArgs = {
  objects: Array<PrepositionsInsertInput>;
  on_conflict?: InputMaybe<PrepositionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertPrepositionsOneArgs = {
  object: PrepositionsInsertInput;
  on_conflict?: InputMaybe<PrepositionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertReadingsArgs = {
  objects: Array<ReadingsInsertInput>;
  on_conflict?: InputMaybe<ReadingsOnConflict>;
};


/** mutation root */
export type MutationRootInsertReadingsOneArgs = {
  object: ReadingsInsertInput;
  on_conflict?: InputMaybe<ReadingsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSessionStatusesArgs = {
  objects: Array<SessionStatusesInsertInput>;
  on_conflict?: InputMaybe<SessionStatusesOnConflict>;
};


/** mutation root */
export type MutationRootInsertSessionStatusesOneArgs = {
  object: SessionStatusesInsertInput;
  on_conflict?: InputMaybe<SessionStatusesOnConflict>;
};


/** mutation root */
export type MutationRootInsertSessionsArgs = {
  objects: Array<SessionsInsertInput>;
  on_conflict?: InputMaybe<SessionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSessionsOneArgs = {
  object: SessionsInsertInput;
  on_conflict?: InputMaybe<SessionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSlotsArgs = {
  objects: Array<SlotsInsertInput>;
  on_conflict?: InputMaybe<SlotsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSlotsOneArgs = {
  object: SlotsInsertInput;
  on_conflict?: InputMaybe<SlotsOnConflict>;
};


/** mutation root */
export type MutationRootInsertStatsArgs = {
  objects: Array<StatsInsertInput>;
  on_conflict?: InputMaybe<StatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertStatsOneArgs = {
  object: StatsInsertInput;
  on_conflict?: InputMaybe<StatsOnConflict>;
};


/** mutation root */
export type MutationRootInsertStudentClassSessionsArgs = {
  objects: Array<StudentClassSessionsInsertInput>;
  on_conflict?: InputMaybe<StudentClassSessionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertStudentClassSessionsOneArgs = {
  object: StudentClassSessionsInsertInput;
  on_conflict?: InputMaybe<StudentClassSessionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertStudentClassesArgs = {
  objects: Array<StudentClassesInsertInput>;
  on_conflict?: InputMaybe<StudentClassesOnConflict>;
};


/** mutation root */
export type MutationRootInsertStudentClassesOneArgs = {
  object: StudentClassesInsertInput;
  on_conflict?: InputMaybe<StudentClassesOnConflict>;
};


/** mutation root */
export type MutationRootInsertStudentFavoriteTeachersArgs = {
  objects: Array<StudentFavoriteTeachersInsertInput>;
  on_conflict?: InputMaybe<StudentFavoriteTeachersOnConflict>;
};


/** mutation root */
export type MutationRootInsertStudentFavoriteTeachersOneArgs = {
  object: StudentFavoriteTeachersInsertInput;
  on_conflict?: InputMaybe<StudentFavoriteTeachersOnConflict>;
};


/** mutation root */
export type MutationRootInsertStudentLiveClassActivitiesArgs = {
  objects: Array<StudentLiveClassActivitiesInsertInput>;
  on_conflict?: InputMaybe<StudentLiveClassActivitiesOnConflict>;
};


/** mutation root */
export type MutationRootInsertStudentLiveClassActivitiesOneArgs = {
  object: StudentLiveClassActivitiesInsertInput;
  on_conflict?: InputMaybe<StudentLiveClassActivitiesOnConflict>;
};


/** mutation root */
export type MutationRootInsertSubjectsArgs = {
  objects: Array<SubjectsInsertInput>;
  on_conflict?: InputMaybe<SubjectsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSubjectsOneArgs = {
  object: SubjectsInsertInput;
  on_conflict?: InputMaybe<SubjectsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSubscriptionsArgs = {
  objects: Array<SubscriptionsInsertInput>;
  on_conflict?: InputMaybe<SubscriptionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSubscriptionsOneArgs = {
  object: SubscriptionsInsertInput;
  on_conflict?: InputMaybe<SubscriptionsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSynonymsArgs = {
  objects: Array<SynonymsInsertInput>;
  on_conflict?: InputMaybe<SynonymsOnConflict>;
};


/** mutation root */
export type MutationRootInsertSynonymsOneArgs = {
  object: SynonymsInsertInput;
  on_conflict?: InputMaybe<SynonymsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherCredentialsArgs = {
  objects: Array<TeacherCredentialsInsertInput>;
  on_conflict?: InputMaybe<TeacherCredentialsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherCredentialsOneArgs = {
  object: TeacherCredentialsInsertInput;
  on_conflict?: InputMaybe<TeacherCredentialsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherEducationArgs = {
  objects: Array<TeacherEducationInsertInput>;
  on_conflict?: InputMaybe<TeacherEducationOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherEducationOneArgs = {
  object: TeacherEducationInsertInput;
  on_conflict?: InputMaybe<TeacherEducationOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherInterestsArgs = {
  objects: Array<TeacherInterestsInsertInput>;
  on_conflict?: InputMaybe<TeacherInterestsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherInterestsOneArgs = {
  object: TeacherInterestsInsertInput;
  on_conflict?: InputMaybe<TeacherInterestsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherLanguagesArgs = {
  objects: Array<TeacherLanguagesInsertInput>;
  on_conflict?: InputMaybe<TeacherLanguagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherLanguagesOneArgs = {
  object: TeacherLanguagesInsertInput;
  on_conflict?: InputMaybe<TeacherLanguagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherSubjectsArgs = {
  objects: Array<TeacherSubjectsInsertInput>;
  on_conflict?: InputMaybe<TeacherSubjectsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeacherSubjectsOneArgs = {
  object: TeacherSubjectsInsertInput;
  on_conflict?: InputMaybe<TeacherSubjectsOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeachersArgs = {
  objects: Array<TeachersInsertInput>;
  on_conflict?: InputMaybe<TeachersOnConflict>;
};


/** mutation root */
export type MutationRootInsertTeachersOneArgs = {
  object: TeachersInsertInput;
  on_conflict?: InputMaybe<TeachersOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserCoursesArgs = {
  objects: Array<UserCoursesInsertInput>;
  on_conflict?: InputMaybe<UserCoursesOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserCoursesOneArgs = {
  object: UserCoursesInsertInput;
  on_conflict?: InputMaybe<UserCoursesOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserDevicesArgs = {
  objects: Array<UserDevicesInsertInput>;
  on_conflict?: InputMaybe<UserDevicesOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserDevicesOneArgs = {
  object: UserDevicesInsertInput;
  on_conflict?: InputMaybe<UserDevicesOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserDictionariesArgs = {
  objects: Array<UserDictionariesInsertInput>;
  on_conflict?: InputMaybe<UserDictionariesOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserDictionariesOneArgs = {
  object: UserDictionariesInsertInput;
  on_conflict?: InputMaybe<UserDictionariesOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserMessagesArgs = {
  objects: Array<UserMessagesInsertInput>;
  on_conflict?: InputMaybe<UserMessagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserMessagesOneArgs = {
  object: UserMessagesInsertInput;
  on_conflict?: InputMaybe<UserMessagesOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserWordsArgs = {
  objects: Array<UserWordsInsertInput>;
  on_conflict?: InputMaybe<UserWordsOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserWordsCountArgs = {
  objects: Array<UserWordsCountInsertInput>;
  on_conflict?: InputMaybe<UserWordsCountOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserWordsCountOneArgs = {
  object: UserWordsCountInsertInput;
  on_conflict?: InputMaybe<UserWordsCountOnConflict>;
};


/** mutation root */
export type MutationRootInsertUserWordsOneArgs = {
  object: UserWordsInsertInput;
  on_conflict?: InputMaybe<UserWordsOnConflict>;
};


/** mutation root */
export type MutationRootInsertUsersArgs = {
  objects: Array<UsersInsertInput>;
  on_conflict?: InputMaybe<UsersOnConflict>;
};


/** mutation root */
export type MutationRootInsertUsersOneArgs = {
  object: UsersInsertInput;
  on_conflict?: InputMaybe<UsersOnConflict>;
};


/** mutation root */
export type MutationRootInsertVocabularySetsArgs = {
  objects: Array<VocabularySetsInsertInput>;
  on_conflict?: InputMaybe<VocabularySetsOnConflict>;
};


/** mutation root */
export type MutationRootInsertVocabularySetsOneArgs = {
  object: VocabularySetsInsertInput;
  on_conflict?: InputMaybe<VocabularySetsOnConflict>;
};


/** mutation root */
export type MutationRootInsertVocabularyWordsArgs = {
  objects: Array<VocabularyWordsInsertInput>;
  on_conflict?: InputMaybe<VocabularyWordsOnConflict>;
};


/** mutation root */
export type MutationRootInsertVocabularyWordsOneArgs = {
  object: VocabularyWordsInsertInput;
  on_conflict?: InputMaybe<VocabularyWordsOnConflict>;
};


/** mutation root */
export type MutationRootInsertWordnetEnglishWordsArgs = {
  objects: Array<WordnetEnglishWordsInsertInput>;
  on_conflict?: InputMaybe<WordnetEnglishWordsOnConflict>;
};


/** mutation root */
export type MutationRootInsertWordnetEnglishWordsOneArgs = {
  object: WordnetEnglishWordsInsertInput;
  on_conflict?: InputMaybe<WordnetEnglishWordsOnConflict>;
};


/** mutation root */
export type MutationRootInsertWordnetSynsetsArgs = {
  objects: Array<WordnetSynsetsInsertInput>;
  on_conflict?: InputMaybe<WordnetSynsetsOnConflict>;
};


/** mutation root */
export type MutationRootInsertWordnetSynsetsOneArgs = {
  object: WordnetSynsetsInsertInput;
  on_conflict?: InputMaybe<WordnetSynsetsOnConflict>;
};


/** mutation root */
export type MutationRootUpdateActivitySetAssignmentsArgs = {
  _inc?: InputMaybe<ActivitySetAssignmentsIncInput>;
  _set?: InputMaybe<ActivitySetAssignmentsSetInput>;
  where: ActivitySetAssignmentsBoolExp;
};


/** mutation root */
export type MutationRootUpdateActivitySetAssignmentsByPkArgs = {
  _inc?: InputMaybe<ActivitySetAssignmentsIncInput>;
  _set?: InputMaybe<ActivitySetAssignmentsSetInput>;
  pk_columns: ActivitySetAssignmentsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateActivitySetAssignmentsManyArgs = {
  updates: Array<ActivitySetAssignmentsUpdates>;
};


/** mutation root */
export type MutationRootUpdateActivitySetReportsArgs = {
  _append?: InputMaybe<ActivitySetReportsAppendInput>;
  _delete_at_path?: InputMaybe<ActivitySetReportsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<ActivitySetReportsDeleteElemInput>;
  _delete_key?: InputMaybe<ActivitySetReportsDeleteKeyInput>;
  _inc?: InputMaybe<ActivitySetReportsIncInput>;
  _prepend?: InputMaybe<ActivitySetReportsPrependInput>;
  _set?: InputMaybe<ActivitySetReportsSetInput>;
  where: ActivitySetReportsBoolExp;
};


/** mutation root */
export type MutationRootUpdateActivitySetReportsByPkArgs = {
  _append?: InputMaybe<ActivitySetReportsAppendInput>;
  _delete_at_path?: InputMaybe<ActivitySetReportsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<ActivitySetReportsDeleteElemInput>;
  _delete_key?: InputMaybe<ActivitySetReportsDeleteKeyInput>;
  _inc?: InputMaybe<ActivitySetReportsIncInput>;
  _prepend?: InputMaybe<ActivitySetReportsPrependInput>;
  _set?: InputMaybe<ActivitySetReportsSetInput>;
  pk_columns: ActivitySetReportsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateActivitySetReportsManyArgs = {
  updates: Array<ActivitySetReportsUpdates>;
};


/** mutation root */
export type MutationRootUpdateActivitySetResponsesArgs = {
  _inc?: InputMaybe<ActivitySetResponsesIncInput>;
  _set?: InputMaybe<ActivitySetResponsesSetInput>;
  where: ActivitySetResponsesBoolExp;
};


/** mutation root */
export type MutationRootUpdateActivitySetResponsesByPkArgs = {
  _inc?: InputMaybe<ActivitySetResponsesIncInput>;
  _set?: InputMaybe<ActivitySetResponsesSetInput>;
  pk_columns: ActivitySetResponsesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateActivitySetResponsesManyArgs = {
  updates: Array<ActivitySetResponsesUpdates>;
};


/** mutation root */
export type MutationRootUpdateActivitySetsArgs = {
  _inc?: InputMaybe<ActivitySetsIncInput>;
  _set?: InputMaybe<ActivitySetsSetInput>;
  where: ActivitySetsBoolExp;
};


/** mutation root */
export type MutationRootUpdateActivitySetsByPkArgs = {
  _inc?: InputMaybe<ActivitySetsIncInput>;
  _set?: InputMaybe<ActivitySetsSetInput>;
  pk_columns: ActivitySetsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateActivitySetsManyArgs = {
  updates: Array<ActivitySetsUpdates>;
};


/** mutation root */
export type MutationRootUpdateAddressesArgs = {
  _inc?: InputMaybe<AddressesIncInput>;
  _set?: InputMaybe<AddressesSetInput>;
  where: AddressesBoolExp;
};


/** mutation root */
export type MutationRootUpdateAddressesByPkArgs = {
  _inc?: InputMaybe<AddressesIncInput>;
  _set?: InputMaybe<AddressesSetInput>;
  pk_columns: AddressesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateAddressesManyArgs = {
  updates: Array<AddressesUpdates>;
};


/** mutation root */
export type MutationRootUpdateAnagramResponsesArgs = {
  _inc?: InputMaybe<AnagramResponsesIncInput>;
  _set?: InputMaybe<AnagramResponsesSetInput>;
  where: AnagramResponsesBoolExp;
};


/** mutation root */
export type MutationRootUpdateAnagramResponsesByPkArgs = {
  _inc?: InputMaybe<AnagramResponsesIncInput>;
  _set?: InputMaybe<AnagramResponsesSetInput>;
  pk_columns: AnagramResponsesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateAnagramResponsesManyArgs = {
  updates: Array<AnagramResponsesUpdates>;
};


/** mutation root */
export type MutationRootUpdateAnagramsArgs = {
  _inc?: InputMaybe<AnagramsIncInput>;
  _set?: InputMaybe<AnagramsSetInput>;
  where: AnagramsBoolExp;
};


/** mutation root */
export type MutationRootUpdateAnagramsByPkArgs = {
  _inc?: InputMaybe<AnagramsIncInput>;
  _set?: InputMaybe<AnagramsSetInput>;
  pk_columns: AnagramsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateAnagramsManyArgs = {
  updates: Array<AnagramsUpdates>;
};


/** mutation root */
export type MutationRootUpdateAnnotationsArgs = {
  _inc?: InputMaybe<AnnotationsIncInput>;
  _set?: InputMaybe<AnnotationsSetInput>;
  where: AnnotationsBoolExp;
};


/** mutation root */
export type MutationRootUpdateAnnotationsByPkArgs = {
  _inc?: InputMaybe<AnnotationsIncInput>;
  _set?: InputMaybe<AnnotationsSetInput>;
  pk_columns: AnnotationsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateAnnotationsManyArgs = {
  updates: Array<AnnotationsUpdates>;
};


/** mutation root */
export type MutationRootUpdateApplicationReviewsArgs = {
  _inc?: InputMaybe<ApplicationReviewsIncInput>;
  _set?: InputMaybe<ApplicationReviewsSetInput>;
  where: ApplicationReviewsBoolExp;
};


/** mutation root */
export type MutationRootUpdateApplicationReviewsByPkArgs = {
  _inc?: InputMaybe<ApplicationReviewsIncInput>;
  _set?: InputMaybe<ApplicationReviewsSetInput>;
  pk_columns: ApplicationReviewsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateApplicationReviewsManyArgs = {
  updates: Array<ApplicationReviewsUpdates>;
};


/** mutation root */
export type MutationRootUpdateAvailabilityTimesArgs = {
  _inc?: InputMaybe<AvailabilityTimesIncInput>;
  _set?: InputMaybe<AvailabilityTimesSetInput>;
  where: AvailabilityTimesBoolExp;
};


/** mutation root */
export type MutationRootUpdateAvailabilityTimesByPkArgs = {
  _inc?: InputMaybe<AvailabilityTimesIncInput>;
  _set?: InputMaybe<AvailabilityTimesSetInput>;
  pk_columns: AvailabilityTimesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateAvailabilityTimesManyArgs = {
  updates: Array<AvailabilityTimesUpdates>;
};


/** mutation root */
export type MutationRootUpdateCefrLevelsArgs = {
  _set?: InputMaybe<CefrLevelsSetInput>;
  where: CefrLevelsBoolExp;
};


/** mutation root */
export type MutationRootUpdateCefrLevelsByPkArgs = {
  _set?: InputMaybe<CefrLevelsSetInput>;
  pk_columns: CefrLevelsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateCefrLevelsManyArgs = {
  updates: Array<CefrLevelsUpdates>;
};


/** mutation root */
export type MutationRootUpdateClassActivitySetsArgs = {
  _inc?: InputMaybe<ClassActivitySetsIncInput>;
  _set?: InputMaybe<ClassActivitySetsSetInput>;
  where: ClassActivitySetsBoolExp;
};


/** mutation root */
export type MutationRootUpdateClassActivitySetsByPkArgs = {
  _inc?: InputMaybe<ClassActivitySetsIncInput>;
  _set?: InputMaybe<ClassActivitySetsSetInput>;
  pk_columns: ClassActivitySetsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateClassActivitySetsManyArgs = {
  updates: Array<ClassActivitySetsUpdates>;
};


/** mutation root */
export type MutationRootUpdateClassAnnotationsArgs = {
  _inc?: InputMaybe<ClassAnnotationsIncInput>;
  _set?: InputMaybe<ClassAnnotationsSetInput>;
  where: ClassAnnotationsBoolExp;
};


/** mutation root */
export type MutationRootUpdateClassAnnotationsByPkArgs = {
  _inc?: InputMaybe<ClassAnnotationsIncInput>;
  _set?: InputMaybe<ClassAnnotationsSetInput>;
  pk_columns: ClassAnnotationsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateClassAnnotationsManyArgs = {
  updates: Array<ClassAnnotationsUpdates>;
};


/** mutation root */
export type MutationRootUpdateClassCoursesArgs = {
  _inc?: InputMaybe<ClassCoursesIncInput>;
  _set?: InputMaybe<ClassCoursesSetInput>;
  where: ClassCoursesBoolExp;
};


/** mutation root */
export type MutationRootUpdateClassCoursesByPkArgs = {
  _inc?: InputMaybe<ClassCoursesIncInput>;
  _set?: InputMaybe<ClassCoursesSetInput>;
  pk_columns: ClassCoursesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateClassCoursesManyArgs = {
  updates: Array<ClassCoursesUpdates>;
};


/** mutation root */
export type MutationRootUpdateClassSessionsArgs = {
  _append?: InputMaybe<ClassSessionsAppendInput>;
  _delete_at_path?: InputMaybe<ClassSessionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<ClassSessionsDeleteElemInput>;
  _delete_key?: InputMaybe<ClassSessionsDeleteKeyInput>;
  _inc?: InputMaybe<ClassSessionsIncInput>;
  _prepend?: InputMaybe<ClassSessionsPrependInput>;
  _set?: InputMaybe<ClassSessionsSetInput>;
  where: ClassSessionsBoolExp;
};


/** mutation root */
export type MutationRootUpdateClassSessionsByPkArgs = {
  _append?: InputMaybe<ClassSessionsAppendInput>;
  _delete_at_path?: InputMaybe<ClassSessionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<ClassSessionsDeleteElemInput>;
  _delete_key?: InputMaybe<ClassSessionsDeleteKeyInput>;
  _inc?: InputMaybe<ClassSessionsIncInput>;
  _prepend?: InputMaybe<ClassSessionsPrependInput>;
  _set?: InputMaybe<ClassSessionsSetInput>;
  pk_columns: ClassSessionsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateClassSessionsManyArgs = {
  updates: Array<ClassSessionsUpdates>;
};


/** mutation root */
export type MutationRootUpdateClassSlotBookingsArgs = {
  _inc?: InputMaybe<ClassSlotBookingsIncInput>;
  _set?: InputMaybe<ClassSlotBookingsSetInput>;
  where: ClassSlotBookingsBoolExp;
};


/** mutation root */
export type MutationRootUpdateClassSlotBookingsByPkArgs = {
  _inc?: InputMaybe<ClassSlotBookingsIncInput>;
  _set?: InputMaybe<ClassSlotBookingsSetInput>;
  pk_columns: ClassSlotBookingsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateClassSlotBookingsManyArgs = {
  updates: Array<ClassSlotBookingsUpdates>;
};


/** mutation root */
export type MutationRootUpdateClassesArgs = {
  _inc?: InputMaybe<ClassesIncInput>;
  _set?: InputMaybe<ClassesSetInput>;
  where: ClassesBoolExp;
};


/** mutation root */
export type MutationRootUpdateClassesByPkArgs = {
  _inc?: InputMaybe<ClassesIncInput>;
  _set?: InputMaybe<ClassesSetInput>;
  pk_columns: ClassesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateClassesManyArgs = {
  updates: Array<ClassesUpdates>;
};


/** mutation root */
export type MutationRootUpdateCourseActivitiesArgs = {
  _inc?: InputMaybe<CourseActivitiesIncInput>;
  _set?: InputMaybe<CourseActivitiesSetInput>;
  where: CourseActivitiesBoolExp;
};


/** mutation root */
export type MutationRootUpdateCourseActivitiesByPkArgs = {
  _inc?: InputMaybe<CourseActivitiesIncInput>;
  _set?: InputMaybe<CourseActivitiesSetInput>;
  pk_columns: CourseActivitiesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateCourseActivitiesManyArgs = {
  updates: Array<CourseActivitiesUpdates>;
};


/** mutation root */
export type MutationRootUpdateCourseReviewsArgs = {
  _inc?: InputMaybe<CourseReviewsIncInput>;
  _set?: InputMaybe<CourseReviewsSetInput>;
  where: CourseReviewsBoolExp;
};


/** mutation root */
export type MutationRootUpdateCourseReviewsByPkArgs = {
  _inc?: InputMaybe<CourseReviewsIncInput>;
  _set?: InputMaybe<CourseReviewsSetInput>;
  pk_columns: CourseReviewsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateCourseReviewsManyArgs = {
  updates: Array<CourseReviewsUpdates>;
};


/** mutation root */
export type MutationRootUpdateCoursesArgs = {
  _inc?: InputMaybe<CoursesIncInput>;
  _set?: InputMaybe<CoursesSetInput>;
  where: CoursesBoolExp;
};


/** mutation root */
export type MutationRootUpdateCoursesByPkArgs = {
  _inc?: InputMaybe<CoursesIncInput>;
  _set?: InputMaybe<CoursesSetInput>;
  pk_columns: CoursesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateCoursesManyArgs = {
  updates: Array<CoursesUpdates>;
};


/** mutation root */
export type MutationRootUpdateDailyStatsArgs = {
  _inc?: InputMaybe<DailyStatsIncInput>;
  _set?: InputMaybe<DailyStatsSetInput>;
  where: DailyStatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateDailyStatsByPkArgs = {
  _inc?: InputMaybe<DailyStatsIncInput>;
  _set?: InputMaybe<DailyStatsSetInput>;
  pk_columns: DailyStatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateDailyStatsManyArgs = {
  updates: Array<DailyStatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateDictionariesArgs = {
  _inc?: InputMaybe<DictionariesIncInput>;
  _set?: InputMaybe<DictionariesSetInput>;
  where: DictionariesBoolExp;
};


/** mutation root */
export type MutationRootUpdateDictionariesByPkArgs = {
  _inc?: InputMaybe<DictionariesIncInput>;
  _set?: InputMaybe<DictionariesSetInput>;
  pk_columns: DictionariesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateDictionariesManyArgs = {
  updates: Array<DictionariesUpdates>;
};


/** mutation root */
export type MutationRootUpdateEmojisArgs = {
  _append?: InputMaybe<EmojisAppendInput>;
  _delete_at_path?: InputMaybe<EmojisDeleteAtPathInput>;
  _delete_elem?: InputMaybe<EmojisDeleteElemInput>;
  _delete_key?: InputMaybe<EmojisDeleteKeyInput>;
  _inc?: InputMaybe<EmojisIncInput>;
  _prepend?: InputMaybe<EmojisPrependInput>;
  _set?: InputMaybe<EmojisSetInput>;
  where: EmojisBoolExp;
};


/** mutation root */
export type MutationRootUpdateEmojisByPkArgs = {
  _append?: InputMaybe<EmojisAppendInput>;
  _delete_at_path?: InputMaybe<EmojisDeleteAtPathInput>;
  _delete_elem?: InputMaybe<EmojisDeleteElemInput>;
  _delete_key?: InputMaybe<EmojisDeleteKeyInput>;
  _inc?: InputMaybe<EmojisIncInput>;
  _prepend?: InputMaybe<EmojisPrependInput>;
  _set?: InputMaybe<EmojisSetInput>;
  pk_columns: EmojisPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateEmojisManyArgs = {
  updates: Array<EmojisUpdates>;
};


/** mutation root */
export type MutationRootUpdateEmployeesArgs = {
  _inc?: InputMaybe<EmployeesIncInput>;
  _set?: InputMaybe<EmployeesSetInput>;
  where: EmployeesBoolExp;
};


/** mutation root */
export type MutationRootUpdateEmployeesByPkArgs = {
  _inc?: InputMaybe<EmployeesIncInput>;
  _set?: InputMaybe<EmployeesSetInput>;
  pk_columns: EmployeesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateEmployeesManyArgs = {
  updates: Array<EmployeesUpdates>;
};


/** mutation root */
export type MutationRootUpdateExampleJoinsArgs = {
  _inc?: InputMaybe<ExampleJoinsIncInput>;
  _set?: InputMaybe<ExampleJoinsSetInput>;
  where: ExampleJoinsBoolExp;
};


/** mutation root */
export type MutationRootUpdateExampleJoinsByPkArgs = {
  _inc?: InputMaybe<ExampleJoinsIncInput>;
  _set?: InputMaybe<ExampleJoinsSetInput>;
  pk_columns: ExampleJoinsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateExampleJoinsManyArgs = {
  updates: Array<ExampleJoinsUpdates>;
};


/** mutation root */
export type MutationRootUpdateExamplesArgs = {
  _inc?: InputMaybe<ExamplesIncInput>;
  _set?: InputMaybe<ExamplesSetInput>;
  where: ExamplesBoolExp;
};


/** mutation root */
export type MutationRootUpdateExamplesByPkArgs = {
  _inc?: InputMaybe<ExamplesIncInput>;
  _set?: InputMaybe<ExamplesSetInput>;
  pk_columns: ExamplesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateExamplesManyArgs = {
  updates: Array<ExamplesUpdates>;
};


/** mutation root */
export type MutationRootUpdateExpiredRefreshTokensArgs = {
  _inc?: InputMaybe<ExpiredRefreshTokensIncInput>;
  _set?: InputMaybe<ExpiredRefreshTokensSetInput>;
  where: ExpiredRefreshTokensBoolExp;
};


/** mutation root */
export type MutationRootUpdateExpiredRefreshTokensByPkArgs = {
  _inc?: InputMaybe<ExpiredRefreshTokensIncInput>;
  _set?: InputMaybe<ExpiredRefreshTokensSetInput>;
  pk_columns: ExpiredRefreshTokensPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateExpiredRefreshTokensManyArgs = {
  updates: Array<ExpiredRefreshTokensUpdates>;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlankOptionsArgs = {
  _inc?: InputMaybe<FillInTheBlankOptionsIncInput>;
  _set?: InputMaybe<FillInTheBlankOptionsSetInput>;
  where: FillInTheBlankOptionsBoolExp;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlankOptionsByPkArgs = {
  _inc?: InputMaybe<FillInTheBlankOptionsIncInput>;
  _set?: InputMaybe<FillInTheBlankOptionsSetInput>;
  pk_columns: FillInTheBlankOptionsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlankOptionsManyArgs = {
  updates: Array<FillInTheBlankOptionsUpdates>;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlankResponsesArgs = {
  _inc?: InputMaybe<FillInTheBlankResponsesIncInput>;
  _set?: InputMaybe<FillInTheBlankResponsesSetInput>;
  where: FillInTheBlankResponsesBoolExp;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlankResponsesByPkArgs = {
  _inc?: InputMaybe<FillInTheBlankResponsesIncInput>;
  _set?: InputMaybe<FillInTheBlankResponsesSetInput>;
  pk_columns: FillInTheBlankResponsesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlankResponsesManyArgs = {
  updates: Array<FillInTheBlankResponsesUpdates>;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlanksArgs = {
  _inc?: InputMaybe<FillInTheBlanksIncInput>;
  _set?: InputMaybe<FillInTheBlanksSetInput>;
  where: FillInTheBlanksBoolExp;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlanksByPkArgs = {
  _inc?: InputMaybe<FillInTheBlanksIncInput>;
  _set?: InputMaybe<FillInTheBlanksSetInput>;
  pk_columns: FillInTheBlanksPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateFillInTheBlanksManyArgs = {
  updates: Array<FillInTheBlanksUpdates>;
};


/** mutation root */
export type MutationRootUpdateGameDailiesArgs = {
  _append?: InputMaybe<GameDailiesAppendInput>;
  _delete_at_path?: InputMaybe<GameDailiesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<GameDailiesDeleteElemInput>;
  _delete_key?: InputMaybe<GameDailiesDeleteKeyInput>;
  _inc?: InputMaybe<GameDailiesIncInput>;
  _prepend?: InputMaybe<GameDailiesPrependInput>;
  _set?: InputMaybe<GameDailiesSetInput>;
  where: GameDailiesBoolExp;
};


/** mutation root */
export type MutationRootUpdateGameDailiesByPkArgs = {
  _append?: InputMaybe<GameDailiesAppendInput>;
  _delete_at_path?: InputMaybe<GameDailiesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<GameDailiesDeleteElemInput>;
  _delete_key?: InputMaybe<GameDailiesDeleteKeyInput>;
  _inc?: InputMaybe<GameDailiesIncInput>;
  _prepend?: InputMaybe<GameDailiesPrependInput>;
  _set?: InputMaybe<GameDailiesSetInput>;
  pk_columns: GameDailiesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateGameDailiesManyArgs = {
  updates: Array<GameDailiesUpdates>;
};


/** mutation root */
export type MutationRootUpdateGameDifficultyArgs = {
  _set?: InputMaybe<GameDifficultySetInput>;
  where: GameDifficultyBoolExp;
};


/** mutation root */
export type MutationRootUpdateGameDifficultyByPkArgs = {
  _set?: InputMaybe<GameDifficultySetInput>;
  pk_columns: GameDifficultyPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateGameDifficultyManyArgs = {
  updates: Array<GameDifficultyUpdates>;
};


/** mutation root */
export type MutationRootUpdateGameTypesArgs = {
  _set?: InputMaybe<GameTypesSetInput>;
  where: GameTypesBoolExp;
};


/** mutation root */
export type MutationRootUpdateGameTypesByPkArgs = {
  _set?: InputMaybe<GameTypesSetInput>;
  pk_columns: GameTypesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateGameTypesManyArgs = {
  updates: Array<GameTypesUpdates>;
};


/** mutation root */
export type MutationRootUpdateGameUsersArgs = {
  _append?: InputMaybe<GameUsersAppendInput>;
  _delete_at_path?: InputMaybe<GameUsersDeleteAtPathInput>;
  _delete_elem?: InputMaybe<GameUsersDeleteElemInput>;
  _delete_key?: InputMaybe<GameUsersDeleteKeyInput>;
  _inc?: InputMaybe<GameUsersIncInput>;
  _prepend?: InputMaybe<GameUsersPrependInput>;
  _set?: InputMaybe<GameUsersSetInput>;
  where: GameUsersBoolExp;
};


/** mutation root */
export type MutationRootUpdateGameUsersByPkArgs = {
  _append?: InputMaybe<GameUsersAppendInput>;
  _delete_at_path?: InputMaybe<GameUsersDeleteAtPathInput>;
  _delete_elem?: InputMaybe<GameUsersDeleteElemInput>;
  _delete_key?: InputMaybe<GameUsersDeleteKeyInput>;
  _inc?: InputMaybe<GameUsersIncInput>;
  _prepend?: InputMaybe<GameUsersPrependInput>;
  _set?: InputMaybe<GameUsersSetInput>;
  pk_columns: GameUsersPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateGameUsersManyArgs = {
  updates: Array<GameUsersUpdates>;
};


/** mutation root */
export type MutationRootUpdateGamesArgs = {
  _append?: InputMaybe<GamesAppendInput>;
  _delete_at_path?: InputMaybe<GamesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<GamesDeleteElemInput>;
  _delete_key?: InputMaybe<GamesDeleteKeyInput>;
  _inc?: InputMaybe<GamesIncInput>;
  _prepend?: InputMaybe<GamesPrependInput>;
  _set?: InputMaybe<GamesSetInput>;
  where: GamesBoolExp;
};


/** mutation root */
export type MutationRootUpdateGamesByPkArgs = {
  _append?: InputMaybe<GamesAppendInput>;
  _delete_at_path?: InputMaybe<GamesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<GamesDeleteElemInput>;
  _delete_key?: InputMaybe<GamesDeleteKeyInput>;
  _inc?: InputMaybe<GamesIncInput>;
  _prepend?: InputMaybe<GamesPrependInput>;
  _set?: InputMaybe<GamesSetInput>;
  pk_columns: GamesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateGamesManyArgs = {
  updates: Array<GamesUpdates>;
};


/** mutation root */
export type MutationRootUpdateGoalsArgs = {
  _inc?: InputMaybe<GoalsIncInput>;
  _set?: InputMaybe<GoalsSetInput>;
  where: GoalsBoolExp;
};


/** mutation root */
export type MutationRootUpdateGoalsByPkArgs = {
  _inc?: InputMaybe<GoalsIncInput>;
  _set?: InputMaybe<GoalsSetInput>;
  pk_columns: GoalsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateGoalsManyArgs = {
  updates: Array<GoalsUpdates>;
};


/** mutation root */
export type MutationRootUpdateImagesArgs = {
  _inc?: InputMaybe<ImagesIncInput>;
  _set?: InputMaybe<ImagesSetInput>;
  where: ImagesBoolExp;
};


/** mutation root */
export type MutationRootUpdateImagesByPkArgs = {
  _inc?: InputMaybe<ImagesIncInput>;
  _set?: InputMaybe<ImagesSetInput>;
  pk_columns: ImagesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateImagesManyArgs = {
  updates: Array<ImagesUpdates>;
};


/** mutation root */
export type MutationRootUpdateInterestsArgs = {
  _inc?: InputMaybe<InterestsIncInput>;
  _set?: InputMaybe<InterestsSetInput>;
  where: InterestsBoolExp;
};


/** mutation root */
export type MutationRootUpdateInterestsByPkArgs = {
  _inc?: InputMaybe<InterestsIncInput>;
  _set?: InputMaybe<InterestsSetInput>;
  pk_columns: InterestsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateInterestsManyArgs = {
  updates: Array<InterestsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLanguagesArgs = {
  _inc?: InputMaybe<LanguagesIncInput>;
  _set?: InputMaybe<LanguagesSetInput>;
  where: LanguagesBoolExp;
};


/** mutation root */
export type MutationRootUpdateLanguagesByPkArgs = {
  _inc?: InputMaybe<LanguagesIncInput>;
  _set?: InputMaybe<LanguagesSetInput>;
  pk_columns: LanguagesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLanguagesManyArgs = {
  updates: Array<LanguagesUpdates>;
};


/** mutation root */
export type MutationRootUpdateListeningsArgs = {
  _inc?: InputMaybe<ListeningsIncInput>;
  _set?: InputMaybe<ListeningsSetInput>;
  where: ListeningsBoolExp;
};


/** mutation root */
export type MutationRootUpdateListeningsByPkArgs = {
  _inc?: InputMaybe<ListeningsIncInput>;
  _set?: InputMaybe<ListeningsSetInput>;
  pk_columns: ListeningsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateListeningsManyArgs = {
  updates: Array<ListeningsUpdates>;
};


/** mutation root */
export type MutationRootUpdateLiveClassActivitiesArgs = {
  _append?: InputMaybe<LiveClassActivitiesAppendInput>;
  _delete_at_path?: InputMaybe<LiveClassActivitiesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LiveClassActivitiesDeleteElemInput>;
  _delete_key?: InputMaybe<LiveClassActivitiesDeleteKeyInput>;
  _inc?: InputMaybe<LiveClassActivitiesIncInput>;
  _prepend?: InputMaybe<LiveClassActivitiesPrependInput>;
  _set?: InputMaybe<LiveClassActivitiesSetInput>;
  where: LiveClassActivitiesBoolExp;
};


/** mutation root */
export type MutationRootUpdateLiveClassActivitiesByPkArgs = {
  _append?: InputMaybe<LiveClassActivitiesAppendInput>;
  _delete_at_path?: InputMaybe<LiveClassActivitiesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<LiveClassActivitiesDeleteElemInput>;
  _delete_key?: InputMaybe<LiveClassActivitiesDeleteKeyInput>;
  _inc?: InputMaybe<LiveClassActivitiesIncInput>;
  _prepend?: InputMaybe<LiveClassActivitiesPrependInput>;
  _set?: InputMaybe<LiveClassActivitiesSetInput>;
  pk_columns: LiveClassActivitiesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLiveClassActivitiesManyArgs = {
  updates: Array<LiveClassActivitiesUpdates>;
};


/** mutation root */
export type MutationRootUpdateLiveMessagesArgs = {
  _inc?: InputMaybe<LiveMessagesIncInput>;
  _set?: InputMaybe<LiveMessagesSetInput>;
  where: LiveMessagesBoolExp;
};


/** mutation root */
export type MutationRootUpdateLiveMessagesByPkArgs = {
  _inc?: InputMaybe<LiveMessagesIncInput>;
  _set?: InputMaybe<LiveMessagesSetInput>;
  pk_columns: LiveMessagesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateLiveMessagesManyArgs = {
  updates: Array<LiveMessagesUpdates>;
};


/** mutation root */
export type MutationRootUpdateMatchingOptionsArgs = {
  _inc?: InputMaybe<MatchingOptionsIncInput>;
  _set?: InputMaybe<MatchingOptionsSetInput>;
  where: MatchingOptionsBoolExp;
};


/** mutation root */
export type MutationRootUpdateMatchingOptionsByPkArgs = {
  _inc?: InputMaybe<MatchingOptionsIncInput>;
  _set?: InputMaybe<MatchingOptionsSetInput>;
  pk_columns: MatchingOptionsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateMatchingOptionsManyArgs = {
  updates: Array<MatchingOptionsUpdates>;
};


/** mutation root */
export type MutationRootUpdateMatchingResponsesArgs = {
  _inc?: InputMaybe<MatchingResponsesIncInput>;
  _set?: InputMaybe<MatchingResponsesSetInput>;
  where: MatchingResponsesBoolExp;
};


/** mutation root */
export type MutationRootUpdateMatchingResponsesByPkArgs = {
  _inc?: InputMaybe<MatchingResponsesIncInput>;
  _set?: InputMaybe<MatchingResponsesSetInput>;
  pk_columns: MatchingResponsesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateMatchingResponsesManyArgs = {
  updates: Array<MatchingResponsesUpdates>;
};


/** mutation root */
export type MutationRootUpdateMatchingsArgs = {
  _inc?: InputMaybe<MatchingsIncInput>;
  _set?: InputMaybe<MatchingsSetInput>;
  where: MatchingsBoolExp;
};


/** mutation root */
export type MutationRootUpdateMatchingsByPkArgs = {
  _inc?: InputMaybe<MatchingsIncInput>;
  _set?: InputMaybe<MatchingsSetInput>;
  pk_columns: MatchingsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateMatchingsManyArgs = {
  updates: Array<MatchingsUpdates>;
};


/** mutation root */
export type MutationRootUpdateMessagesArgs = {
  _inc?: InputMaybe<MessagesIncInput>;
  _set?: InputMaybe<MessagesSetInput>;
  where: MessagesBoolExp;
};


/** mutation root */
export type MutationRootUpdateMessagesByPkArgs = {
  _inc?: InputMaybe<MessagesIncInput>;
  _set?: InputMaybe<MessagesSetInput>;
  pk_columns: MessagesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateMessagesManyArgs = {
  updates: Array<MessagesUpdates>;
};


/** mutation root */
export type MutationRootUpdateMultipleChoiceOptionsArgs = {
  _inc?: InputMaybe<MultipleChoiceOptionsIncInput>;
  _set?: InputMaybe<MultipleChoiceOptionsSetInput>;
  where: MultipleChoiceOptionsBoolExp;
};


/** mutation root */
export type MutationRootUpdateMultipleChoiceOptionsByPkArgs = {
  _inc?: InputMaybe<MultipleChoiceOptionsIncInput>;
  _set?: InputMaybe<MultipleChoiceOptionsSetInput>;
  pk_columns: MultipleChoiceOptionsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateMultipleChoiceOptionsManyArgs = {
  updates: Array<MultipleChoiceOptionsUpdates>;
};


/** mutation root */
export type MutationRootUpdateMultipleChoiceResponsesArgs = {
  _inc?: InputMaybe<MultipleChoiceResponsesIncInput>;
  _set?: InputMaybe<MultipleChoiceResponsesSetInput>;
  where: MultipleChoiceResponsesBoolExp;
};


/** mutation root */
export type MutationRootUpdateMultipleChoiceResponsesByPkArgs = {
  _inc?: InputMaybe<MultipleChoiceResponsesIncInput>;
  _set?: InputMaybe<MultipleChoiceResponsesSetInput>;
  pk_columns: MultipleChoiceResponsesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateMultipleChoiceResponsesManyArgs = {
  updates: Array<MultipleChoiceResponsesUpdates>;
};


/** mutation root */
export type MutationRootUpdateMultipleChoicesArgs = {
  _inc?: InputMaybe<MultipleChoicesIncInput>;
  _set?: InputMaybe<MultipleChoicesSetInput>;
  where: MultipleChoicesBoolExp;
};


/** mutation root */
export type MutationRootUpdateMultipleChoicesByPkArgs = {
  _inc?: InputMaybe<MultipleChoicesIncInput>;
  _set?: InputMaybe<MultipleChoicesSetInput>;
  pk_columns: MultipleChoicesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateMultipleChoicesManyArgs = {
  updates: Array<MultipleChoicesUpdates>;
};


/** mutation root */
export type MutationRootUpdateOpenAnswerResponsesArgs = {
  _inc?: InputMaybe<OpenAnswerResponsesIncInput>;
  _set?: InputMaybe<OpenAnswerResponsesSetInput>;
  where: OpenAnswerResponsesBoolExp;
};


/** mutation root */
export type MutationRootUpdateOpenAnswerResponsesByPkArgs = {
  _inc?: InputMaybe<OpenAnswerResponsesIncInput>;
  _set?: InputMaybe<OpenAnswerResponsesSetInput>;
  pk_columns: OpenAnswerResponsesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateOpenAnswerResponsesManyArgs = {
  updates: Array<OpenAnswerResponsesUpdates>;
};


/** mutation root */
export type MutationRootUpdateOpenAnswersArgs = {
  _inc?: InputMaybe<OpenAnswersIncInput>;
  _set?: InputMaybe<OpenAnswersSetInput>;
  where: OpenAnswersBoolExp;
};


/** mutation root */
export type MutationRootUpdateOpenAnswersByPkArgs = {
  _inc?: InputMaybe<OpenAnswersIncInput>;
  _set?: InputMaybe<OpenAnswersSetInput>;
  pk_columns: OpenAnswersPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateOpenAnswersManyArgs = {
  updates: Array<OpenAnswersUpdates>;
};


/** mutation root */
export type MutationRootUpdatePartsOfSpeechArgs = {
  _set?: InputMaybe<PartsOfSpeechSetInput>;
  where: PartsOfSpeechBoolExp;
};


/** mutation root */
export type MutationRootUpdatePartsOfSpeechByPkArgs = {
  _set?: InputMaybe<PartsOfSpeechSetInput>;
  pk_columns: PartsOfSpeechPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdatePartsOfSpeechManyArgs = {
  updates: Array<PartsOfSpeechUpdates>;
};


/** mutation root */
export type MutationRootUpdatePaymentsArgs = {
  _inc?: InputMaybe<PaymentsIncInput>;
  _set?: InputMaybe<PaymentsSetInput>;
  where: PaymentsBoolExp;
};


/** mutation root */
export type MutationRootUpdatePaymentsByPkArgs = {
  _inc?: InputMaybe<PaymentsIncInput>;
  _set?: InputMaybe<PaymentsSetInput>;
  pk_columns: PaymentsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdatePaymentsManyArgs = {
  updates: Array<PaymentsUpdates>;
};


/** mutation root */
export type MutationRootUpdatePhraseResponsesArgs = {
  _inc?: InputMaybe<PhraseResponsesIncInput>;
  _set?: InputMaybe<PhraseResponsesSetInput>;
  where: PhraseResponsesBoolExp;
};


/** mutation root */
export type MutationRootUpdatePhraseResponsesByPkArgs = {
  _inc?: InputMaybe<PhraseResponsesIncInput>;
  _set?: InputMaybe<PhraseResponsesSetInput>;
  pk_columns: PhraseResponsesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdatePhraseResponsesManyArgs = {
  updates: Array<PhraseResponsesUpdates>;
};


/** mutation root */
export type MutationRootUpdatePhrasesArgs = {
  _inc?: InputMaybe<PhrasesIncInput>;
  _set?: InputMaybe<PhrasesSetInput>;
  where: PhrasesBoolExp;
};


/** mutation root */
export type MutationRootUpdatePhrasesByPkArgs = {
  _inc?: InputMaybe<PhrasesIncInput>;
  _set?: InputMaybe<PhrasesSetInput>;
  pk_columns: PhrasesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdatePhrasesManyArgs = {
  updates: Array<PhrasesUpdates>;
};


/** mutation root */
export type MutationRootUpdatePoemLinesArgs = {
  _append?: InputMaybe<PoemLinesAppendInput>;
  _delete_at_path?: InputMaybe<PoemLinesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<PoemLinesDeleteElemInput>;
  _delete_key?: InputMaybe<PoemLinesDeleteKeyInput>;
  _inc?: InputMaybe<PoemLinesIncInput>;
  _prepend?: InputMaybe<PoemLinesPrependInput>;
  _set?: InputMaybe<PoemLinesSetInput>;
  where: PoemLinesBoolExp;
};


/** mutation root */
export type MutationRootUpdatePoemLinesByPkArgs = {
  _append?: InputMaybe<PoemLinesAppendInput>;
  _delete_at_path?: InputMaybe<PoemLinesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<PoemLinesDeleteElemInput>;
  _delete_key?: InputMaybe<PoemLinesDeleteKeyInput>;
  _inc?: InputMaybe<PoemLinesIncInput>;
  _prepend?: InputMaybe<PoemLinesPrependInput>;
  _set?: InputMaybe<PoemLinesSetInput>;
  pk_columns: PoemLinesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdatePoemLinesManyArgs = {
  updates: Array<PoemLinesUpdates>;
};


/** mutation root */
export type MutationRootUpdatePoemsArgs = {
  _inc?: InputMaybe<PoemsIncInput>;
  _set?: InputMaybe<PoemsSetInput>;
  where: PoemsBoolExp;
};


/** mutation root */
export type MutationRootUpdatePoemsByPkArgs = {
  _inc?: InputMaybe<PoemsIncInput>;
  _set?: InputMaybe<PoemsSetInput>;
  pk_columns: PoemsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdatePoemsManyArgs = {
  updates: Array<PoemsUpdates>;
};


/** mutation root */
export type MutationRootUpdatePrepositionsArgs = {
  _append?: InputMaybe<PrepositionsAppendInput>;
  _delete_at_path?: InputMaybe<PrepositionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<PrepositionsDeleteElemInput>;
  _delete_key?: InputMaybe<PrepositionsDeleteKeyInput>;
  _inc?: InputMaybe<PrepositionsIncInput>;
  _prepend?: InputMaybe<PrepositionsPrependInput>;
  _set?: InputMaybe<PrepositionsSetInput>;
  where: PrepositionsBoolExp;
};


/** mutation root */
export type MutationRootUpdatePrepositionsByPkArgs = {
  _append?: InputMaybe<PrepositionsAppendInput>;
  _delete_at_path?: InputMaybe<PrepositionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<PrepositionsDeleteElemInput>;
  _delete_key?: InputMaybe<PrepositionsDeleteKeyInput>;
  _inc?: InputMaybe<PrepositionsIncInput>;
  _prepend?: InputMaybe<PrepositionsPrependInput>;
  _set?: InputMaybe<PrepositionsSetInput>;
  pk_columns: PrepositionsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdatePrepositionsManyArgs = {
  updates: Array<PrepositionsUpdates>;
};


/** mutation root */
export type MutationRootUpdateReadingsArgs = {
  _inc?: InputMaybe<ReadingsIncInput>;
  _set?: InputMaybe<ReadingsSetInput>;
  where: ReadingsBoolExp;
};


/** mutation root */
export type MutationRootUpdateReadingsByPkArgs = {
  _inc?: InputMaybe<ReadingsIncInput>;
  _set?: InputMaybe<ReadingsSetInput>;
  pk_columns: ReadingsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateReadingsManyArgs = {
  updates: Array<ReadingsUpdates>;
};


/** mutation root */
export type MutationRootUpdateSessionStatusesArgs = {
  _set?: InputMaybe<SessionStatusesSetInput>;
  where: SessionStatusesBoolExp;
};


/** mutation root */
export type MutationRootUpdateSessionStatusesByPkArgs = {
  _set?: InputMaybe<SessionStatusesSetInput>;
  pk_columns: SessionStatusesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateSessionStatusesManyArgs = {
  updates: Array<SessionStatusesUpdates>;
};


/** mutation root */
export type MutationRootUpdateSessionsArgs = {
  _append?: InputMaybe<SessionsAppendInput>;
  _delete_at_path?: InputMaybe<SessionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<SessionsDeleteElemInput>;
  _delete_key?: InputMaybe<SessionsDeleteKeyInput>;
  _inc?: InputMaybe<SessionsIncInput>;
  _prepend?: InputMaybe<SessionsPrependInput>;
  _set?: InputMaybe<SessionsSetInput>;
  where: SessionsBoolExp;
};


/** mutation root */
export type MutationRootUpdateSessionsByPkArgs = {
  _append?: InputMaybe<SessionsAppendInput>;
  _delete_at_path?: InputMaybe<SessionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<SessionsDeleteElemInput>;
  _delete_key?: InputMaybe<SessionsDeleteKeyInput>;
  _inc?: InputMaybe<SessionsIncInput>;
  _prepend?: InputMaybe<SessionsPrependInput>;
  _set?: InputMaybe<SessionsSetInput>;
  pk_columns: SessionsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateSessionsManyArgs = {
  updates: Array<SessionsUpdates>;
};


/** mutation root */
export type MutationRootUpdateSlotsArgs = {
  _inc?: InputMaybe<SlotsIncInput>;
  _set?: InputMaybe<SlotsSetInput>;
  where: SlotsBoolExp;
};


/** mutation root */
export type MutationRootUpdateSlotsByPkArgs = {
  _inc?: InputMaybe<SlotsIncInput>;
  _set?: InputMaybe<SlotsSetInput>;
  pk_columns: SlotsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateSlotsManyArgs = {
  updates: Array<SlotsUpdates>;
};


/** mutation root */
export type MutationRootUpdateStatsArgs = {
  _inc?: InputMaybe<StatsIncInput>;
  _set?: InputMaybe<StatsSetInput>;
  where: StatsBoolExp;
};


/** mutation root */
export type MutationRootUpdateStatsByPkArgs = {
  _inc?: InputMaybe<StatsIncInput>;
  _set?: InputMaybe<StatsSetInput>;
  pk_columns: StatsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateStatsManyArgs = {
  updates: Array<StatsUpdates>;
};


/** mutation root */
export type MutationRootUpdateStudentClassSessionsArgs = {
  _append?: InputMaybe<StudentClassSessionsAppendInput>;
  _delete_at_path?: InputMaybe<StudentClassSessionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<StudentClassSessionsDeleteElemInput>;
  _delete_key?: InputMaybe<StudentClassSessionsDeleteKeyInput>;
  _inc?: InputMaybe<StudentClassSessionsIncInput>;
  _prepend?: InputMaybe<StudentClassSessionsPrependInput>;
  _set?: InputMaybe<StudentClassSessionsSetInput>;
  where: StudentClassSessionsBoolExp;
};


/** mutation root */
export type MutationRootUpdateStudentClassSessionsByPkArgs = {
  _append?: InputMaybe<StudentClassSessionsAppendInput>;
  _delete_at_path?: InputMaybe<StudentClassSessionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<StudentClassSessionsDeleteElemInput>;
  _delete_key?: InputMaybe<StudentClassSessionsDeleteKeyInput>;
  _inc?: InputMaybe<StudentClassSessionsIncInput>;
  _prepend?: InputMaybe<StudentClassSessionsPrependInput>;
  _set?: InputMaybe<StudentClassSessionsSetInput>;
  pk_columns: StudentClassSessionsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateStudentClassSessionsManyArgs = {
  updates: Array<StudentClassSessionsUpdates>;
};


/** mutation root */
export type MutationRootUpdateStudentClassesArgs = {
  _inc?: InputMaybe<StudentClassesIncInput>;
  _set?: InputMaybe<StudentClassesSetInput>;
  where: StudentClassesBoolExp;
};


/** mutation root */
export type MutationRootUpdateStudentClassesByPkArgs = {
  _inc?: InputMaybe<StudentClassesIncInput>;
  _set?: InputMaybe<StudentClassesSetInput>;
  pk_columns: StudentClassesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateStudentClassesManyArgs = {
  updates: Array<StudentClassesUpdates>;
};


/** mutation root */
export type MutationRootUpdateStudentFavoriteTeachersArgs = {
  _inc?: InputMaybe<StudentFavoriteTeachersIncInput>;
  _set?: InputMaybe<StudentFavoriteTeachersSetInput>;
  where: StudentFavoriteTeachersBoolExp;
};


/** mutation root */
export type MutationRootUpdateStudentFavoriteTeachersByPkArgs = {
  _inc?: InputMaybe<StudentFavoriteTeachersIncInput>;
  _set?: InputMaybe<StudentFavoriteTeachersSetInput>;
  pk_columns: StudentFavoriteTeachersPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateStudentFavoriteTeachersManyArgs = {
  updates: Array<StudentFavoriteTeachersUpdates>;
};


/** mutation root */
export type MutationRootUpdateStudentLiveClassActivitiesArgs = {
  _append?: InputMaybe<StudentLiveClassActivitiesAppendInput>;
  _delete_at_path?: InputMaybe<StudentLiveClassActivitiesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<StudentLiveClassActivitiesDeleteElemInput>;
  _delete_key?: InputMaybe<StudentLiveClassActivitiesDeleteKeyInput>;
  _inc?: InputMaybe<StudentLiveClassActivitiesIncInput>;
  _prepend?: InputMaybe<StudentLiveClassActivitiesPrependInput>;
  _set?: InputMaybe<StudentLiveClassActivitiesSetInput>;
  where: StudentLiveClassActivitiesBoolExp;
};


/** mutation root */
export type MutationRootUpdateStudentLiveClassActivitiesByPkArgs = {
  _append?: InputMaybe<StudentLiveClassActivitiesAppendInput>;
  _delete_at_path?: InputMaybe<StudentLiveClassActivitiesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<StudentLiveClassActivitiesDeleteElemInput>;
  _delete_key?: InputMaybe<StudentLiveClassActivitiesDeleteKeyInput>;
  _inc?: InputMaybe<StudentLiveClassActivitiesIncInput>;
  _prepend?: InputMaybe<StudentLiveClassActivitiesPrependInput>;
  _set?: InputMaybe<StudentLiveClassActivitiesSetInput>;
  pk_columns: StudentLiveClassActivitiesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateStudentLiveClassActivitiesManyArgs = {
  updates: Array<StudentLiveClassActivitiesUpdates>;
};


/** mutation root */
export type MutationRootUpdateSubjectsArgs = {
  _inc?: InputMaybe<SubjectsIncInput>;
  _set?: InputMaybe<SubjectsSetInput>;
  where: SubjectsBoolExp;
};


/** mutation root */
export type MutationRootUpdateSubjectsByPkArgs = {
  _inc?: InputMaybe<SubjectsIncInput>;
  _set?: InputMaybe<SubjectsSetInput>;
  pk_columns: SubjectsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateSubjectsManyArgs = {
  updates: Array<SubjectsUpdates>;
};


/** mutation root */
export type MutationRootUpdateSubscriptionsArgs = {
  _inc?: InputMaybe<SubscriptionsIncInput>;
  _set?: InputMaybe<SubscriptionsSetInput>;
  where: SubscriptionsBoolExp;
};


/** mutation root */
export type MutationRootUpdateSubscriptionsByPkArgs = {
  _inc?: InputMaybe<SubscriptionsIncInput>;
  _set?: InputMaybe<SubscriptionsSetInput>;
  pk_columns: SubscriptionsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateSubscriptionsManyArgs = {
  updates: Array<SubscriptionsUpdates>;
};


/** mutation root */
export type MutationRootUpdateSynonymsArgs = {
  _append?: InputMaybe<SynonymsAppendInput>;
  _delete_at_path?: InputMaybe<SynonymsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<SynonymsDeleteElemInput>;
  _delete_key?: InputMaybe<SynonymsDeleteKeyInput>;
  _inc?: InputMaybe<SynonymsIncInput>;
  _prepend?: InputMaybe<SynonymsPrependInput>;
  _set?: InputMaybe<SynonymsSetInput>;
  where: SynonymsBoolExp;
};


/** mutation root */
export type MutationRootUpdateSynonymsByPkArgs = {
  _append?: InputMaybe<SynonymsAppendInput>;
  _delete_at_path?: InputMaybe<SynonymsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<SynonymsDeleteElemInput>;
  _delete_key?: InputMaybe<SynonymsDeleteKeyInput>;
  _inc?: InputMaybe<SynonymsIncInput>;
  _prepend?: InputMaybe<SynonymsPrependInput>;
  _set?: InputMaybe<SynonymsSetInput>;
  pk_columns: SynonymsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateSynonymsManyArgs = {
  updates: Array<SynonymsUpdates>;
};


/** mutation root */
export type MutationRootUpdateTeacherCredentialsArgs = {
  _inc?: InputMaybe<TeacherCredentialsIncInput>;
  _set?: InputMaybe<TeacherCredentialsSetInput>;
  where: TeacherCredentialsBoolExp;
};


/** mutation root */
export type MutationRootUpdateTeacherCredentialsByPkArgs = {
  _inc?: InputMaybe<TeacherCredentialsIncInput>;
  _set?: InputMaybe<TeacherCredentialsSetInput>;
  pk_columns: TeacherCredentialsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateTeacherCredentialsManyArgs = {
  updates: Array<TeacherCredentialsUpdates>;
};


/** mutation root */
export type MutationRootUpdateTeacherEducationArgs = {
  _inc?: InputMaybe<TeacherEducationIncInput>;
  _set?: InputMaybe<TeacherEducationSetInput>;
  where: TeacherEducationBoolExp;
};


/** mutation root */
export type MutationRootUpdateTeacherEducationByPkArgs = {
  _inc?: InputMaybe<TeacherEducationIncInput>;
  _set?: InputMaybe<TeacherEducationSetInput>;
  pk_columns: TeacherEducationPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateTeacherEducationManyArgs = {
  updates: Array<TeacherEducationUpdates>;
};


/** mutation root */
export type MutationRootUpdateTeacherInterestsArgs = {
  _inc?: InputMaybe<TeacherInterestsIncInput>;
  _set?: InputMaybe<TeacherInterestsSetInput>;
  where: TeacherInterestsBoolExp;
};


/** mutation root */
export type MutationRootUpdateTeacherInterestsByPkArgs = {
  _inc?: InputMaybe<TeacherInterestsIncInput>;
  _set?: InputMaybe<TeacherInterestsSetInput>;
  pk_columns: TeacherInterestsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateTeacherInterestsManyArgs = {
  updates: Array<TeacherInterestsUpdates>;
};


/** mutation root */
export type MutationRootUpdateTeacherLanguagesArgs = {
  _inc?: InputMaybe<TeacherLanguagesIncInput>;
  _set?: InputMaybe<TeacherLanguagesSetInput>;
  where: TeacherLanguagesBoolExp;
};


/** mutation root */
export type MutationRootUpdateTeacherLanguagesByPkArgs = {
  _inc?: InputMaybe<TeacherLanguagesIncInput>;
  _set?: InputMaybe<TeacherLanguagesSetInput>;
  pk_columns: TeacherLanguagesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateTeacherLanguagesManyArgs = {
  updates: Array<TeacherLanguagesUpdates>;
};


/** mutation root */
export type MutationRootUpdateTeacherSubjectsArgs = {
  _inc?: InputMaybe<TeacherSubjectsIncInput>;
  _set?: InputMaybe<TeacherSubjectsSetInput>;
  where: TeacherSubjectsBoolExp;
};


/** mutation root */
export type MutationRootUpdateTeacherSubjectsByPkArgs = {
  _inc?: InputMaybe<TeacherSubjectsIncInput>;
  _set?: InputMaybe<TeacherSubjectsSetInput>;
  pk_columns: TeacherSubjectsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateTeacherSubjectsManyArgs = {
  updates: Array<TeacherSubjectsUpdates>;
};


/** mutation root */
export type MutationRootUpdateTeachersArgs = {
  _inc?: InputMaybe<TeachersIncInput>;
  _set?: InputMaybe<TeachersSetInput>;
  where: TeachersBoolExp;
};


/** mutation root */
export type MutationRootUpdateTeachersByPkArgs = {
  _inc?: InputMaybe<TeachersIncInput>;
  _set?: InputMaybe<TeachersSetInput>;
  pk_columns: TeachersPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateTeachersManyArgs = {
  updates: Array<TeachersUpdates>;
};


/** mutation root */
export type MutationRootUpdateUserCoursesArgs = {
  _inc?: InputMaybe<UserCoursesIncInput>;
  _set?: InputMaybe<UserCoursesSetInput>;
  where: UserCoursesBoolExp;
};


/** mutation root */
export type MutationRootUpdateUserCoursesByPkArgs = {
  _inc?: InputMaybe<UserCoursesIncInput>;
  _set?: InputMaybe<UserCoursesSetInput>;
  pk_columns: UserCoursesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateUserCoursesManyArgs = {
  updates: Array<UserCoursesUpdates>;
};


/** mutation root */
export type MutationRootUpdateUserDevicesArgs = {
  _inc?: InputMaybe<UserDevicesIncInput>;
  _set?: InputMaybe<UserDevicesSetInput>;
  where: UserDevicesBoolExp;
};


/** mutation root */
export type MutationRootUpdateUserDevicesByPkArgs = {
  _inc?: InputMaybe<UserDevicesIncInput>;
  _set?: InputMaybe<UserDevicesSetInput>;
  pk_columns: UserDevicesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateUserDevicesManyArgs = {
  updates: Array<UserDevicesUpdates>;
};


/** mutation root */
export type MutationRootUpdateUserDictionariesArgs = {
  _inc?: InputMaybe<UserDictionariesIncInput>;
  _set?: InputMaybe<UserDictionariesSetInput>;
  where: UserDictionariesBoolExp;
};


/** mutation root */
export type MutationRootUpdateUserDictionariesByPkArgs = {
  _inc?: InputMaybe<UserDictionariesIncInput>;
  _set?: InputMaybe<UserDictionariesSetInput>;
  pk_columns: UserDictionariesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateUserDictionariesManyArgs = {
  updates: Array<UserDictionariesUpdates>;
};


/** mutation root */
export type MutationRootUpdateUserMessagesArgs = {
  _inc?: InputMaybe<UserMessagesIncInput>;
  _set?: InputMaybe<UserMessagesSetInput>;
  where: UserMessagesBoolExp;
};


/** mutation root */
export type MutationRootUpdateUserMessagesByPkArgs = {
  _inc?: InputMaybe<UserMessagesIncInput>;
  _set?: InputMaybe<UserMessagesSetInput>;
  pk_columns: UserMessagesPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateUserMessagesManyArgs = {
  updates: Array<UserMessagesUpdates>;
};


/** mutation root */
export type MutationRootUpdateUserWordsArgs = {
  _inc?: InputMaybe<UserWordsIncInput>;
  _set?: InputMaybe<UserWordsSetInput>;
  where: UserWordsBoolExp;
};


/** mutation root */
export type MutationRootUpdateUserWordsByPkArgs = {
  _inc?: InputMaybe<UserWordsIncInput>;
  _set?: InputMaybe<UserWordsSetInput>;
  pk_columns: UserWordsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateUserWordsCountArgs = {
  _inc?: InputMaybe<UserWordsCountIncInput>;
  _set?: InputMaybe<UserWordsCountSetInput>;
  where: UserWordsCountBoolExp;
};


/** mutation root */
export type MutationRootUpdateUserWordsCountByPkArgs = {
  _inc?: InputMaybe<UserWordsCountIncInput>;
  _set?: InputMaybe<UserWordsCountSetInput>;
  pk_columns: UserWordsCountPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateUserWordsCountManyArgs = {
  updates: Array<UserWordsCountUpdates>;
};


/** mutation root */
export type MutationRootUpdateUserWordsManyArgs = {
  updates: Array<UserWordsUpdates>;
};


/** mutation root */
export type MutationRootUpdateUsersArgs = {
  _append?: InputMaybe<UsersAppendInput>;
  _delete_at_path?: InputMaybe<UsersDeleteAtPathInput>;
  _delete_elem?: InputMaybe<UsersDeleteElemInput>;
  _delete_key?: InputMaybe<UsersDeleteKeyInput>;
  _inc?: InputMaybe<UsersIncInput>;
  _prepend?: InputMaybe<UsersPrependInput>;
  _set?: InputMaybe<UsersSetInput>;
  where: UsersBoolExp;
};


/** mutation root */
export type MutationRootUpdateUsersByPkArgs = {
  _append?: InputMaybe<UsersAppendInput>;
  _delete_at_path?: InputMaybe<UsersDeleteAtPathInput>;
  _delete_elem?: InputMaybe<UsersDeleteElemInput>;
  _delete_key?: InputMaybe<UsersDeleteKeyInput>;
  _inc?: InputMaybe<UsersIncInput>;
  _prepend?: InputMaybe<UsersPrependInput>;
  _set?: InputMaybe<UsersSetInput>;
  pk_columns: UsersPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateUsersManyArgs = {
  updates: Array<UsersUpdates>;
};


/** mutation root */
export type MutationRootUpdateVocabularySetsArgs = {
  _inc?: InputMaybe<VocabularySetsIncInput>;
  _set?: InputMaybe<VocabularySetsSetInput>;
  where: VocabularySetsBoolExp;
};


/** mutation root */
export type MutationRootUpdateVocabularySetsByPkArgs = {
  _inc?: InputMaybe<VocabularySetsIncInput>;
  _set?: InputMaybe<VocabularySetsSetInput>;
  pk_columns: VocabularySetsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateVocabularySetsManyArgs = {
  updates: Array<VocabularySetsUpdates>;
};


/** mutation root */
export type MutationRootUpdateVocabularyWordsArgs = {
  _inc?: InputMaybe<VocabularyWordsIncInput>;
  _set?: InputMaybe<VocabularyWordsSetInput>;
  where: VocabularyWordsBoolExp;
};


/** mutation root */
export type MutationRootUpdateVocabularyWordsByPkArgs = {
  _inc?: InputMaybe<VocabularyWordsIncInput>;
  _set?: InputMaybe<VocabularyWordsSetInput>;
  pk_columns: VocabularyWordsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateVocabularyWordsManyArgs = {
  updates: Array<VocabularyWordsUpdates>;
};


/** mutation root */
export type MutationRootUpdateWordnetEnglishWordsArgs = {
  _inc?: InputMaybe<WordnetEnglishWordsIncInput>;
  _set?: InputMaybe<WordnetEnglishWordsSetInput>;
  where: WordnetEnglishWordsBoolExp;
};


/** mutation root */
export type MutationRootUpdateWordnetEnglishWordsByPkArgs = {
  _inc?: InputMaybe<WordnetEnglishWordsIncInput>;
  _set?: InputMaybe<WordnetEnglishWordsSetInput>;
  pk_columns: WordnetEnglishWordsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateWordnetEnglishWordsManyArgs = {
  updates: Array<WordnetEnglishWordsUpdates>;
};


/** mutation root */
export type MutationRootUpdateWordnetSynsetsArgs = {
  _inc?: InputMaybe<WordnetSynsetsIncInput>;
  _set?: InputMaybe<WordnetSynsetsSetInput>;
  where: WordnetSynsetsBoolExp;
};


/** mutation root */
export type MutationRootUpdateWordnetSynsetsByPkArgs = {
  _inc?: InputMaybe<WordnetSynsetsIncInput>;
  _set?: InputMaybe<WordnetSynsetsSetInput>;
  pk_columns: WordnetSynsetsPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateWordnetSynsetsManyArgs = {
  updates: Array<WordnetSynsetsUpdates>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  _eq?: InputMaybe<Scalars['numeric']['input']>;
  _gt?: InputMaybe<Scalars['numeric']['input']>;
  _gte?: InputMaybe<Scalars['numeric']['input']>;
  _in?: InputMaybe<Array<Scalars['numeric']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['numeric']['input']>;
  _lte?: InputMaybe<Scalars['numeric']['input']>;
  _neq?: InputMaybe<Scalars['numeric']['input']>;
  _nin?: InputMaybe<Array<Scalars['numeric']['input']>>;
};

/** columns and relationships of "open_answer_responses" */
export type OpenAnswerResponses = {
  __typename?: 'open_answer_responses';
  activitySetResponseId: Scalars['Int']['output'];
  answer: Scalars['String']['output'];
  correction?: Maybe<Scalars['String']['output']>;
  createdBy: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  isCorrect?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  openAnswer: OpenAnswers;
  openAnswerId: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "open_answer_responses" */
export type OpenAnswerResponsesAggregate = {
  __typename?: 'open_answer_responses_aggregate';
  aggregate?: Maybe<OpenAnswerResponsesAggregateFields>;
  nodes: Array<OpenAnswerResponses>;
};

export type OpenAnswerResponsesAggregateBoolExp = {
  bool_and?: InputMaybe<OpenAnswerResponsesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<OpenAnswerResponsesAggregateBoolExpBoolOr>;
  count?: InputMaybe<OpenAnswerResponsesAggregateBoolExpCount>;
};

export type OpenAnswerResponsesAggregateBoolExpBoolAnd = {
  arguments: OpenAnswerResponsesSelectColumnOpenAnswerResponsesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<OpenAnswerResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type OpenAnswerResponsesAggregateBoolExpBoolOr = {
  arguments: OpenAnswerResponsesSelectColumnOpenAnswerResponsesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<OpenAnswerResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type OpenAnswerResponsesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<OpenAnswerResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<OpenAnswerResponsesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "open_answer_responses" */
export type OpenAnswerResponsesAggregateFields = {
  __typename?: 'open_answer_responses_aggregate_fields';
  avg?: Maybe<OpenAnswerResponsesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<OpenAnswerResponsesMaxFields>;
  min?: Maybe<OpenAnswerResponsesMinFields>;
  stddev?: Maybe<OpenAnswerResponsesStddevFields>;
  stddev_pop?: Maybe<OpenAnswerResponsesStddevPopFields>;
  stddev_samp?: Maybe<OpenAnswerResponsesStddevSampFields>;
  sum?: Maybe<OpenAnswerResponsesSumFields>;
  var_pop?: Maybe<OpenAnswerResponsesVarPopFields>;
  var_samp?: Maybe<OpenAnswerResponsesVarSampFields>;
  variance?: Maybe<OpenAnswerResponsesVarianceFields>;
};


/** aggregate fields of "open_answer_responses" */
export type OpenAnswerResponsesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<OpenAnswerResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "open_answer_responses" */
export type OpenAnswerResponsesAggregateOrderBy = {
  avg?: InputMaybe<OpenAnswerResponsesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<OpenAnswerResponsesMaxOrderBy>;
  min?: InputMaybe<OpenAnswerResponsesMinOrderBy>;
  stddev?: InputMaybe<OpenAnswerResponsesStddevOrderBy>;
  stddev_pop?: InputMaybe<OpenAnswerResponsesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<OpenAnswerResponsesStddevSampOrderBy>;
  sum?: InputMaybe<OpenAnswerResponsesSumOrderBy>;
  var_pop?: InputMaybe<OpenAnswerResponsesVarPopOrderBy>;
  var_samp?: InputMaybe<OpenAnswerResponsesVarSampOrderBy>;
  variance?: InputMaybe<OpenAnswerResponsesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "open_answer_responses" */
export type OpenAnswerResponsesArrRelInsertInput = {
  data: Array<OpenAnswerResponsesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<OpenAnswerResponsesOnConflict>;
};

/** aggregate avg on columns */
export type OpenAnswerResponsesAvgFields = {
  __typename?: 'open_answer_responses_avg_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  openAnswerId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesAvgOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "open_answer_responses". All fields are combined with a logical 'AND'. */
export type OpenAnswerResponsesBoolExp = {
  _and?: InputMaybe<Array<OpenAnswerResponsesBoolExp>>;
  _not?: InputMaybe<OpenAnswerResponsesBoolExp>;
  _or?: InputMaybe<Array<OpenAnswerResponsesBoolExp>>;
  activitySetResponseId?: InputMaybe<IntComparisonExp>;
  answer?: InputMaybe<StringComparisonExp>;
  correction?: InputMaybe<StringComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isCorrect?: InputMaybe<BooleanComparisonExp>;
  openAnswer?: InputMaybe<OpenAnswersBoolExp>;
  openAnswerId?: InputMaybe<IntComparisonExp>;
  updated_at?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "open_answer_responses" */
export enum OpenAnswerResponsesConstraint {
  /** unique or primary key constraint on columns "id" */
  OpenAnswerResponsesPkey = 'open_answer_responses_pkey'
}

/** input type for incrementing numeric columns in table "open_answer_responses" */
export type OpenAnswerResponsesIncInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  openAnswerId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "open_answer_responses" */
export type OpenAnswerResponsesInsertInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  correction?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  openAnswer?: InputMaybe<OpenAnswersObjRelInsertInput>;
  openAnswerId?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type OpenAnswerResponsesMaxFields = {
  __typename?: 'open_answer_responses_max_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  correction?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  openAnswerId?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesMaxOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  correction?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type OpenAnswerResponsesMinFields = {
  __typename?: 'open_answer_responses_min_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  correction?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  openAnswerId?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesMinOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  correction?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "open_answer_responses" */
export type OpenAnswerResponsesMutationResponse = {
  __typename?: 'open_answer_responses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<OpenAnswerResponses>;
};

/** on_conflict condition type for table "open_answer_responses" */
export type OpenAnswerResponsesOnConflict = {
  constraint: OpenAnswerResponsesConstraint;
  update_columns?: Array<OpenAnswerResponsesUpdateColumn>;
  where?: InputMaybe<OpenAnswerResponsesBoolExp>;
};

/** Ordering options when selecting data from "open_answer_responses". */
export type OpenAnswerResponsesOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  correction?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCorrect?: InputMaybe<OrderBy>;
  openAnswer?: InputMaybe<OpenAnswersOrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: open_answer_responses */
export type OpenAnswerResponsesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "open_answer_responses" */
export enum OpenAnswerResponsesSelectColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  Correction = 'correction',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  OpenAnswerId = 'openAnswerId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "open_answer_responses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "open_answer_responses" */
export enum OpenAnswerResponsesSelectColumnOpenAnswerResponsesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** select "open_answer_responses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "open_answer_responses" */
export enum OpenAnswerResponsesSelectColumnOpenAnswerResponsesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** input type for updating data in table "open_answer_responses" */
export type OpenAnswerResponsesSetInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  correction?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  openAnswerId?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type OpenAnswerResponsesStddevFields = {
  __typename?: 'open_answer_responses_stddev_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  openAnswerId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesStddevOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type OpenAnswerResponsesStddevPopFields = {
  __typename?: 'open_answer_responses_stddev_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  openAnswerId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesStddevPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type OpenAnswerResponsesStddevSampFields = {
  __typename?: 'open_answer_responses_stddev_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  openAnswerId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesStddevSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "open_answer_responses" */
export type OpenAnswerResponsesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: OpenAnswerResponsesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type OpenAnswerResponsesStreamCursorValueInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  correction?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  openAnswerId?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type OpenAnswerResponsesSumFields = {
  __typename?: 'open_answer_responses_sum_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  openAnswerId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesSumOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
};

/** update columns of table "open_answer_responses" */
export enum OpenAnswerResponsesUpdateColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  Correction = 'correction',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  OpenAnswerId = 'openAnswerId',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type OpenAnswerResponsesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<OpenAnswerResponsesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<OpenAnswerResponsesSetInput>;
  /** filter the rows which have to be updated */
  where: OpenAnswerResponsesBoolExp;
};

/** aggregate var_pop on columns */
export type OpenAnswerResponsesVarPopFields = {
  __typename?: 'open_answer_responses_var_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  openAnswerId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesVarPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type OpenAnswerResponsesVarSampFields = {
  __typename?: 'open_answer_responses_var_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  openAnswerId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesVarSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type OpenAnswerResponsesVarianceFields = {
  __typename?: 'open_answer_responses_variance_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  openAnswerId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "open_answer_responses" */
export type OpenAnswerResponsesVarianceOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openAnswerId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "open_answers" */
export type OpenAnswers = {
  __typename?: 'open_answers';
  activitySetId: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  created_by: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isSpellcheckEnabled: Scalars['Boolean']['output'];
  order: Scalars['Int']['output'];
  prompt: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  wordLimit: Scalars['Int']['output'];
};

/** aggregated selection of "open_answers" */
export type OpenAnswersAggregate = {
  __typename?: 'open_answers_aggregate';
  aggregate?: Maybe<OpenAnswersAggregateFields>;
  nodes: Array<OpenAnswers>;
};

export type OpenAnswersAggregateBoolExp = {
  bool_and?: InputMaybe<OpenAnswersAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<OpenAnswersAggregateBoolExpBoolOr>;
  count?: InputMaybe<OpenAnswersAggregateBoolExpCount>;
};

export type OpenAnswersAggregateBoolExpBoolAnd = {
  arguments: OpenAnswersSelectColumnOpenAnswersAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<OpenAnswersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type OpenAnswersAggregateBoolExpBoolOr = {
  arguments: OpenAnswersSelectColumnOpenAnswersAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<OpenAnswersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type OpenAnswersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<OpenAnswersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<OpenAnswersBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "open_answers" */
export type OpenAnswersAggregateFields = {
  __typename?: 'open_answers_aggregate_fields';
  avg?: Maybe<OpenAnswersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<OpenAnswersMaxFields>;
  min?: Maybe<OpenAnswersMinFields>;
  stddev?: Maybe<OpenAnswersStddevFields>;
  stddev_pop?: Maybe<OpenAnswersStddevPopFields>;
  stddev_samp?: Maybe<OpenAnswersStddevSampFields>;
  sum?: Maybe<OpenAnswersSumFields>;
  var_pop?: Maybe<OpenAnswersVarPopFields>;
  var_samp?: Maybe<OpenAnswersVarSampFields>;
  variance?: Maybe<OpenAnswersVarianceFields>;
};


/** aggregate fields of "open_answers" */
export type OpenAnswersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<OpenAnswersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "open_answers" */
export type OpenAnswersAggregateOrderBy = {
  avg?: InputMaybe<OpenAnswersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<OpenAnswersMaxOrderBy>;
  min?: InputMaybe<OpenAnswersMinOrderBy>;
  stddev?: InputMaybe<OpenAnswersStddevOrderBy>;
  stddev_pop?: InputMaybe<OpenAnswersStddevPopOrderBy>;
  stddev_samp?: InputMaybe<OpenAnswersStddevSampOrderBy>;
  sum?: InputMaybe<OpenAnswersSumOrderBy>;
  var_pop?: InputMaybe<OpenAnswersVarPopOrderBy>;
  var_samp?: InputMaybe<OpenAnswersVarSampOrderBy>;
  variance?: InputMaybe<OpenAnswersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "open_answers" */
export type OpenAnswersArrRelInsertInput = {
  data: Array<OpenAnswersInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<OpenAnswersOnConflict>;
};

/** aggregate avg on columns */
export type OpenAnswersAvgFields = {
  __typename?: 'open_answers_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  wordLimit?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "open_answers" */
export type OpenAnswersAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "open_answers". All fields are combined with a logical 'AND'. */
export type OpenAnswersBoolExp = {
  _and?: InputMaybe<Array<OpenAnswersBoolExp>>;
  _not?: InputMaybe<OpenAnswersBoolExp>;
  _or?: InputMaybe<Array<OpenAnswersBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  created_by?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isSpellcheckEnabled?: InputMaybe<BooleanComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  prompt?: InputMaybe<StringComparisonExp>;
  updated_at?: InputMaybe<TimestamptzComparisonExp>;
  wordLimit?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "open_answers" */
export enum OpenAnswersConstraint {
  /** unique or primary key constraint on columns "id" */
  OpenAnswersPkey = 'open_answers_pkey'
}

/** input type for incrementing numeric columns in table "open_answers" */
export type OpenAnswersIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  wordLimit?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "open_answers" */
export type OpenAnswersInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSpellcheckEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  wordLimit?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type OpenAnswersMaxFields = {
  __typename?: 'open_answers_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  prompt?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  wordLimit?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "open_answers" */
export type OpenAnswersMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type OpenAnswersMinFields = {
  __typename?: 'open_answers_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  prompt?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  wordLimit?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "open_answers" */
export type OpenAnswersMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "open_answers" */
export type OpenAnswersMutationResponse = {
  __typename?: 'open_answers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<OpenAnswers>;
};

/** input type for inserting object relation for remote table "open_answers" */
export type OpenAnswersObjRelInsertInput = {
  data: OpenAnswersInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<OpenAnswersOnConflict>;
};

/** on_conflict condition type for table "open_answers" */
export type OpenAnswersOnConflict = {
  constraint: OpenAnswersConstraint;
  update_columns?: Array<OpenAnswersUpdateColumn>;
  where?: InputMaybe<OpenAnswersBoolExp>;
};

/** Ordering options when selecting data from "open_answers". */
export type OpenAnswersOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isSpellcheckEnabled?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: open_answers */
export type OpenAnswersPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "open_answers" */
export enum OpenAnswersSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  IsSpellcheckEnabled = 'isSpellcheckEnabled',
  /** column name */
  Order = 'order',
  /** column name */
  Prompt = 'prompt',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WordLimit = 'wordLimit'
}

/** select "open_answers_aggregate_bool_exp_bool_and_arguments_columns" columns of table "open_answers" */
export enum OpenAnswersSelectColumnOpenAnswersAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsSpellcheckEnabled = 'isSpellcheckEnabled'
}

/** select "open_answers_aggregate_bool_exp_bool_or_arguments_columns" columns of table "open_answers" */
export enum OpenAnswersSelectColumnOpenAnswersAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsSpellcheckEnabled = 'isSpellcheckEnabled'
}

/** input type for updating data in table "open_answers" */
export type OpenAnswersSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSpellcheckEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  wordLimit?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type OpenAnswersStddevFields = {
  __typename?: 'open_answers_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  wordLimit?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "open_answers" */
export type OpenAnswersStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type OpenAnswersStddevPopFields = {
  __typename?: 'open_answers_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  wordLimit?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "open_answers" */
export type OpenAnswersStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type OpenAnswersStddevSampFields = {
  __typename?: 'open_answers_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  wordLimit?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "open_answers" */
export type OpenAnswersStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "open_answers" */
export type OpenAnswersStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: OpenAnswersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type OpenAnswersStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSpellcheckEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  wordLimit?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type OpenAnswersSumFields = {
  __typename?: 'open_answers_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  wordLimit?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "open_answers" */
export type OpenAnswersSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** update columns of table "open_answers" */
export enum OpenAnswersUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  IsSpellcheckEnabled = 'isSpellcheckEnabled',
  /** column name */
  Order = 'order',
  /** column name */
  Prompt = 'prompt',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WordLimit = 'wordLimit'
}

export type OpenAnswersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<OpenAnswersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<OpenAnswersSetInput>;
  /** filter the rows which have to be updated */
  where: OpenAnswersBoolExp;
};

/** aggregate var_pop on columns */
export type OpenAnswersVarPopFields = {
  __typename?: 'open_answers_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  wordLimit?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "open_answers" */
export type OpenAnswersVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type OpenAnswersVarSampFields = {
  __typename?: 'open_answers_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  wordLimit?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "open_answers" */
export type OpenAnswersVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type OpenAnswersVarianceFields = {
  __typename?: 'open_answers_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  wordLimit?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "open_answers" */
export type OpenAnswersVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  wordLimit?: InputMaybe<OrderBy>;
};

/** column ordering options */
export enum OrderBy {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "parts_of_speech" */
export type PartsOfSpeech = {
  __typename?: 'parts_of_speech';
  value: Scalars['String']['output'];
};

/** aggregated selection of "parts_of_speech" */
export type PartsOfSpeechAggregate = {
  __typename?: 'parts_of_speech_aggregate';
  aggregate?: Maybe<PartsOfSpeechAggregateFields>;
  nodes: Array<PartsOfSpeech>;
};

/** aggregate fields of "parts_of_speech" */
export type PartsOfSpeechAggregateFields = {
  __typename?: 'parts_of_speech_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<PartsOfSpeechMaxFields>;
  min?: Maybe<PartsOfSpeechMinFields>;
};


/** aggregate fields of "parts_of_speech" */
export type PartsOfSpeechAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PartsOfSpeechSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "parts_of_speech". All fields are combined with a logical 'AND'. */
export type PartsOfSpeechBoolExp = {
  _and?: InputMaybe<Array<PartsOfSpeechBoolExp>>;
  _not?: InputMaybe<PartsOfSpeechBoolExp>;
  _or?: InputMaybe<Array<PartsOfSpeechBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "parts_of_speech" */
export enum PartsOfSpeechConstraint {
  /** unique or primary key constraint on columns "value" */
  PartsOfSpeechPkey = 'parts_of_speech_pkey',
  /** unique or primary key constraint on columns "value" */
  PartsOfSpeechValueKey = 'parts_of_speech_value_key'
}

export enum PartsOfSpeechEnum {
  Adjective = 'ADJECTIVE',
  Adverb = 'ADVERB',
  Article = 'ARTICLE',
  Conjunction = 'CONJUNCTION',
  Interjection = 'INTERJECTION',
  Noun = 'NOUN',
  Other = 'OTHER',
  Particle = 'PARTICLE',
  Preposition = 'PREPOSITION',
  Pronoun = 'PRONOUN',
  Verb = 'VERB'
}

/** Boolean expression to compare columns of type "parts_of_speech_enum". All fields are combined with logical 'AND'. */
export type PartsOfSpeechEnumComparisonExp = {
  _eq?: InputMaybe<PartsOfSpeechEnum>;
  _in?: InputMaybe<Array<PartsOfSpeechEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<PartsOfSpeechEnum>;
  _nin?: InputMaybe<Array<PartsOfSpeechEnum>>;
};

/** input type for inserting data into table "parts_of_speech" */
export type PartsOfSpeechInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type PartsOfSpeechMaxFields = {
  __typename?: 'parts_of_speech_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type PartsOfSpeechMinFields = {
  __typename?: 'parts_of_speech_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "parts_of_speech" */
export type PartsOfSpeechMutationResponse = {
  __typename?: 'parts_of_speech_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PartsOfSpeech>;
};

/** on_conflict condition type for table "parts_of_speech" */
export type PartsOfSpeechOnConflict = {
  constraint: PartsOfSpeechConstraint;
  update_columns?: Array<PartsOfSpeechUpdateColumn>;
  where?: InputMaybe<PartsOfSpeechBoolExp>;
};

/** Ordering options when selecting data from "parts_of_speech". */
export type PartsOfSpeechOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parts_of_speech */
export type PartsOfSpeechPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "parts_of_speech" */
export enum PartsOfSpeechSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "parts_of_speech" */
export type PartsOfSpeechSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "parts_of_speech" */
export type PartsOfSpeechStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PartsOfSpeechStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PartsOfSpeechStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "parts_of_speech" */
export enum PartsOfSpeechUpdateColumn {
  /** column name */
  Value = 'value'
}

export type PartsOfSpeechUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PartsOfSpeechSetInput>;
  /** filter the rows which have to be updated */
  where: PartsOfSpeechBoolExp;
};

/** columns and relationships of "payments" */
export type Payments = {
  __typename?: 'payments';
  amount: Scalars['Int']['output'];
  classId?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  confirmationNumber: Scalars['String']['output'];
  courseId?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  method: Scalars['String']['output'];
  /** An object relationship */
  payee?: Maybe<Users>;
  payeeId?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  payor: Users;
  payorId: Scalars['Int']['output'];
  platformAmount: Scalars['float8']['output'];
  provider: Scalars['String']['output'];
  /** An object relationship */
  slot?: Maybe<Slots>;
  slotId?: Maybe<Scalars['Int']['output']>;
  status: Scalars['String']['output'];
};

/** aggregated selection of "payments" */
export type PaymentsAggregate = {
  __typename?: 'payments_aggregate';
  aggregate?: Maybe<PaymentsAggregateFields>;
  nodes: Array<Payments>;
};

/** aggregate fields of "payments" */
export type PaymentsAggregateFields = {
  __typename?: 'payments_aggregate_fields';
  avg?: Maybe<PaymentsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PaymentsMaxFields>;
  min?: Maybe<PaymentsMinFields>;
  stddev?: Maybe<PaymentsStddevFields>;
  stddev_pop?: Maybe<PaymentsStddevPopFields>;
  stddev_samp?: Maybe<PaymentsStddevSampFields>;
  sum?: Maybe<PaymentsSumFields>;
  var_pop?: Maybe<PaymentsVarPopFields>;
  var_samp?: Maybe<PaymentsVarSampFields>;
  variance?: Maybe<PaymentsVarianceFields>;
};


/** aggregate fields of "payments" */
export type PaymentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PaymentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PaymentsAvgFields = {
  __typename?: 'payments_avg_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payeeId?: Maybe<Scalars['Float']['output']>;
  payorId?: Maybe<Scalars['Float']['output']>;
  platformAmount?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payments". All fields are combined with a logical 'AND'. */
export type PaymentsBoolExp = {
  _and?: InputMaybe<Array<PaymentsBoolExp>>;
  _not?: InputMaybe<PaymentsBoolExp>;
  _or?: InputMaybe<Array<PaymentsBoolExp>>;
  amount?: InputMaybe<IntComparisonExp>;
  classId?: InputMaybe<IntComparisonExp>;
  classSessionId?: InputMaybe<IntComparisonExp>;
  confirmationNumber?: InputMaybe<StringComparisonExp>;
  courseId?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  method?: InputMaybe<StringComparisonExp>;
  payee?: InputMaybe<UsersBoolExp>;
  payeeId?: InputMaybe<IntComparisonExp>;
  payor?: InputMaybe<UsersBoolExp>;
  payorId?: InputMaybe<IntComparisonExp>;
  platformAmount?: InputMaybe<Float8ComparisonExp>;
  provider?: InputMaybe<StringComparisonExp>;
  slot?: InputMaybe<SlotsBoolExp>;
  slotId?: InputMaybe<IntComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "payments" */
export enum PaymentsConstraint {
  /** unique or primary key constraint on columns "confirmation_number" */
  PaymentsConfirmationNumberKey = 'payments_confirmation_number_key',
  /** unique or primary key constraint on columns "id" */
  PaymentsPkey = 'payments_pkey'
}

/** input type for incrementing numeric columns in table "payments" */
export type PaymentsIncInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  payeeId?: InputMaybe<Scalars['Int']['input']>;
  payorId?: InputMaybe<Scalars['Int']['input']>;
  platformAmount?: InputMaybe<Scalars['float8']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "payments" */
export type PaymentsInsertInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  confirmationNumber?: InputMaybe<Scalars['String']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  method?: InputMaybe<Scalars['String']['input']>;
  payee?: InputMaybe<UsersObjRelInsertInput>;
  payeeId?: InputMaybe<Scalars['Int']['input']>;
  payor?: InputMaybe<UsersObjRelInsertInput>;
  payorId?: InputMaybe<Scalars['Int']['input']>;
  platformAmount?: InputMaybe<Scalars['float8']['input']>;
  provider?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<SlotsObjRelInsertInput>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type PaymentsMaxFields = {
  __typename?: 'payments_max_fields';
  amount?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  confirmationNumber?: Maybe<Scalars['String']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  method?: Maybe<Scalars['String']['output']>;
  payeeId?: Maybe<Scalars['Int']['output']>;
  payorId?: Maybe<Scalars['Int']['output']>;
  platformAmount?: Maybe<Scalars['float8']['output']>;
  provider?: Maybe<Scalars['String']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type PaymentsMinFields = {
  __typename?: 'payments_min_fields';
  amount?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  confirmationNumber?: Maybe<Scalars['String']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  method?: Maybe<Scalars['String']['output']>;
  payeeId?: Maybe<Scalars['Int']['output']>;
  payorId?: Maybe<Scalars['Int']['output']>;
  platformAmount?: Maybe<Scalars['float8']['output']>;
  provider?: Maybe<Scalars['String']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "payments" */
export type PaymentsMutationResponse = {
  __typename?: 'payments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Payments>;
};

/** on_conflict condition type for table "payments" */
export type PaymentsOnConflict = {
  constraint: PaymentsConstraint;
  update_columns?: Array<PaymentsUpdateColumn>;
  where?: InputMaybe<PaymentsBoolExp>;
};

/** Ordering options when selecting data from "payments". */
export type PaymentsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  classId?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  confirmationNumber?: InputMaybe<OrderBy>;
  courseId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  method?: InputMaybe<OrderBy>;
  payee?: InputMaybe<UsersOrderBy>;
  payeeId?: InputMaybe<OrderBy>;
  payor?: InputMaybe<UsersOrderBy>;
  payorId?: InputMaybe<OrderBy>;
  platformAmount?: InputMaybe<OrderBy>;
  provider?: InputMaybe<OrderBy>;
  slot?: InputMaybe<SlotsOrderBy>;
  slotId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payments */
export type PaymentsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "payments" */
export enum PaymentsSelectColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  ClassId = 'classId',
  /** column name */
  ClassSessionId = 'classSessionId',
  /** column name */
  ConfirmationNumber = 'confirmationNumber',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  Id = 'id',
  /** column name */
  Method = 'method',
  /** column name */
  PayeeId = 'payeeId',
  /** column name */
  PayorId = 'payorId',
  /** column name */
  PlatformAmount = 'platformAmount',
  /** column name */
  Provider = 'provider',
  /** column name */
  SlotId = 'slotId',
  /** column name */
  Status = 'status'
}

/** input type for updating data in table "payments" */
export type PaymentsSetInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  confirmationNumber?: InputMaybe<Scalars['String']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  method?: InputMaybe<Scalars['String']['input']>;
  payeeId?: InputMaybe<Scalars['Int']['input']>;
  payorId?: InputMaybe<Scalars['Int']['input']>;
  platformAmount?: InputMaybe<Scalars['float8']['input']>;
  provider?: InputMaybe<Scalars['String']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type PaymentsStddevFields = {
  __typename?: 'payments_stddev_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payeeId?: Maybe<Scalars['Float']['output']>;
  payorId?: Maybe<Scalars['Float']['output']>;
  platformAmount?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type PaymentsStddevPopFields = {
  __typename?: 'payments_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payeeId?: Maybe<Scalars['Float']['output']>;
  payorId?: Maybe<Scalars['Float']['output']>;
  platformAmount?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type PaymentsStddevSampFields = {
  __typename?: 'payments_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payeeId?: Maybe<Scalars['Float']['output']>;
  payorId?: Maybe<Scalars['Float']['output']>;
  platformAmount?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payments" */
export type PaymentsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PaymentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PaymentsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  classId?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  confirmationNumber?: InputMaybe<Scalars['String']['input']>;
  courseId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  method?: InputMaybe<Scalars['String']['input']>;
  payeeId?: InputMaybe<Scalars['Int']['input']>;
  payorId?: InputMaybe<Scalars['Int']['input']>;
  platformAmount?: InputMaybe<Scalars['float8']['input']>;
  provider?: InputMaybe<Scalars['String']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type PaymentsSumFields = {
  __typename?: 'payments_sum_fields';
  amount?: Maybe<Scalars['Int']['output']>;
  classId?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  courseId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  payeeId?: Maybe<Scalars['Int']['output']>;
  payorId?: Maybe<Scalars['Int']['output']>;
  platformAmount?: Maybe<Scalars['float8']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "payments" */
export enum PaymentsUpdateColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  ClassId = 'classId',
  /** column name */
  ClassSessionId = 'classSessionId',
  /** column name */
  ConfirmationNumber = 'confirmationNumber',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  Id = 'id',
  /** column name */
  Method = 'method',
  /** column name */
  PayeeId = 'payeeId',
  /** column name */
  PayorId = 'payorId',
  /** column name */
  PlatformAmount = 'platformAmount',
  /** column name */
  Provider = 'provider',
  /** column name */
  SlotId = 'slotId',
  /** column name */
  Status = 'status'
}

export type PaymentsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PaymentsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PaymentsSetInput>;
  /** filter the rows which have to be updated */
  where: PaymentsBoolExp;
};

/** aggregate var_pop on columns */
export type PaymentsVarPopFields = {
  __typename?: 'payments_var_pop_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payeeId?: Maybe<Scalars['Float']['output']>;
  payorId?: Maybe<Scalars['Float']['output']>;
  platformAmount?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type PaymentsVarSampFields = {
  __typename?: 'payments_var_samp_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payeeId?: Maybe<Scalars['Float']['output']>;
  payorId?: Maybe<Scalars['Float']['output']>;
  platformAmount?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PaymentsVarianceFields = {
  __typename?: 'payments_variance_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  classId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  courseId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payeeId?: Maybe<Scalars['Float']['output']>;
  payorId?: Maybe<Scalars['Float']['output']>;
  platformAmount?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "phrase_responses" */
export type PhraseResponses = {
  __typename?: 'phrase_responses';
  activitySetResponseId: Scalars['Int']['output'];
  answer: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isCorrect: Scalars['Boolean']['output'];
  /** An object relationship */
  phrase: Phrases;
  phraseId: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "phrase_responses" */
export type PhraseResponsesAggregate = {
  __typename?: 'phrase_responses_aggregate';
  aggregate?: Maybe<PhraseResponsesAggregateFields>;
  nodes: Array<PhraseResponses>;
};

export type PhraseResponsesAggregateBoolExp = {
  bool_and?: InputMaybe<PhraseResponsesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<PhraseResponsesAggregateBoolExpBoolOr>;
  count?: InputMaybe<PhraseResponsesAggregateBoolExpCount>;
};

export type PhraseResponsesAggregateBoolExpBoolAnd = {
  arguments: PhraseResponsesSelectColumnPhraseResponsesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PhraseResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PhraseResponsesAggregateBoolExpBoolOr = {
  arguments: PhraseResponsesSelectColumnPhraseResponsesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PhraseResponsesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PhraseResponsesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PhraseResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PhraseResponsesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "phrase_responses" */
export type PhraseResponsesAggregateFields = {
  __typename?: 'phrase_responses_aggregate_fields';
  avg?: Maybe<PhraseResponsesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PhraseResponsesMaxFields>;
  min?: Maybe<PhraseResponsesMinFields>;
  stddev?: Maybe<PhraseResponsesStddevFields>;
  stddev_pop?: Maybe<PhraseResponsesStddevPopFields>;
  stddev_samp?: Maybe<PhraseResponsesStddevSampFields>;
  sum?: Maybe<PhraseResponsesSumFields>;
  var_pop?: Maybe<PhraseResponsesVarPopFields>;
  var_samp?: Maybe<PhraseResponsesVarSampFields>;
  variance?: Maybe<PhraseResponsesVarianceFields>;
};


/** aggregate fields of "phrase_responses" */
export type PhraseResponsesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PhraseResponsesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "phrase_responses" */
export type PhraseResponsesAggregateOrderBy = {
  avg?: InputMaybe<PhraseResponsesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PhraseResponsesMaxOrderBy>;
  min?: InputMaybe<PhraseResponsesMinOrderBy>;
  stddev?: InputMaybe<PhraseResponsesStddevOrderBy>;
  stddev_pop?: InputMaybe<PhraseResponsesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<PhraseResponsesStddevSampOrderBy>;
  sum?: InputMaybe<PhraseResponsesSumOrderBy>;
  var_pop?: InputMaybe<PhraseResponsesVarPopOrderBy>;
  var_samp?: InputMaybe<PhraseResponsesVarSampOrderBy>;
  variance?: InputMaybe<PhraseResponsesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "phrase_responses" */
export type PhraseResponsesArrRelInsertInput = {
  data: Array<PhraseResponsesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<PhraseResponsesOnConflict>;
};

/** aggregate avg on columns */
export type PhraseResponsesAvgFields = {
  __typename?: 'phrase_responses_avg_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  phraseId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "phrase_responses" */
export type PhraseResponsesAvgOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "phrase_responses". All fields are combined with a logical 'AND'. */
export type PhraseResponsesBoolExp = {
  _and?: InputMaybe<Array<PhraseResponsesBoolExp>>;
  _not?: InputMaybe<PhraseResponsesBoolExp>;
  _or?: InputMaybe<Array<PhraseResponsesBoolExp>>;
  activitySetResponseId?: InputMaybe<IntComparisonExp>;
  answer?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isCorrect?: InputMaybe<BooleanComparisonExp>;
  phrase?: InputMaybe<PhrasesBoolExp>;
  phraseId?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "phrase_responses" */
export enum PhraseResponsesConstraint {
  /** unique or primary key constraint on columns "id" */
  PhraseResponsesPkey = 'phrase_responses_pkey'
}

/** input type for incrementing numeric columns in table "phrase_responses" */
export type PhraseResponsesIncInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  phraseId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "phrase_responses" */
export type PhraseResponsesInsertInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  phrase?: InputMaybe<PhrasesObjRelInsertInput>;
  phraseId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type PhraseResponsesMaxFields = {
  __typename?: 'phrase_responses_max_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  phraseId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "phrase_responses" */
export type PhraseResponsesMaxOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PhraseResponsesMinFields = {
  __typename?: 'phrase_responses_min_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  answer?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  phraseId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "phrase_responses" */
export type PhraseResponsesMinOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "phrase_responses" */
export type PhraseResponsesMutationResponse = {
  __typename?: 'phrase_responses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PhraseResponses>;
};

/** on_conflict condition type for table "phrase_responses" */
export type PhraseResponsesOnConflict = {
  constraint: PhraseResponsesConstraint;
  update_columns?: Array<PhraseResponsesUpdateColumn>;
  where?: InputMaybe<PhraseResponsesBoolExp>;
};

/** Ordering options when selecting data from "phrase_responses". */
export type PhraseResponsesOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  answer?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCorrect?: InputMaybe<OrderBy>;
  phrase?: InputMaybe<PhrasesOrderBy>;
  phraseId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: phrase_responses */
export type PhraseResponsesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "phrase_responses" */
export enum PhraseResponsesSelectColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  PhraseId = 'phraseId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "phrase_responses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "phrase_responses" */
export enum PhraseResponsesSelectColumnPhraseResponsesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** select "phrase_responses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "phrase_responses" */
export enum PhraseResponsesSelectColumnPhraseResponsesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsCorrect = 'isCorrect'
}

/** input type for updating data in table "phrase_responses" */
export type PhraseResponsesSetInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  phraseId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type PhraseResponsesStddevFields = {
  __typename?: 'phrase_responses_stddev_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  phraseId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "phrase_responses" */
export type PhraseResponsesStddevOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type PhraseResponsesStddevPopFields = {
  __typename?: 'phrase_responses_stddev_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  phraseId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "phrase_responses" */
export type PhraseResponsesStddevPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type PhraseResponsesStddevSampFields = {
  __typename?: 'phrase_responses_stddev_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  phraseId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "phrase_responses" */
export type PhraseResponsesStddevSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "phrase_responses" */
export type PhraseResponsesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PhraseResponsesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PhraseResponsesStreamCursorValueInput = {
  activitySetResponseId?: InputMaybe<Scalars['Int']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCorrect?: InputMaybe<Scalars['Boolean']['input']>;
  phraseId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type PhraseResponsesSumFields = {
  __typename?: 'phrase_responses_sum_fields';
  activitySetResponseId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  phraseId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "phrase_responses" */
export type PhraseResponsesSumOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
};

/** update columns of table "phrase_responses" */
export enum PhraseResponsesUpdateColumn {
  /** column name */
  ActivitySetResponseId = 'activitySetResponseId',
  /** column name */
  Answer = 'answer',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  IsCorrect = 'isCorrect',
  /** column name */
  PhraseId = 'phraseId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type PhraseResponsesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PhraseResponsesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PhraseResponsesSetInput>;
  /** filter the rows which have to be updated */
  where: PhraseResponsesBoolExp;
};

/** aggregate var_pop on columns */
export type PhraseResponsesVarPopFields = {
  __typename?: 'phrase_responses_var_pop_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  phraseId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "phrase_responses" */
export type PhraseResponsesVarPopOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type PhraseResponsesVarSampFields = {
  __typename?: 'phrase_responses_var_samp_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  phraseId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "phrase_responses" */
export type PhraseResponsesVarSampOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PhraseResponsesVarianceFields = {
  __typename?: 'phrase_responses_variance_fields';
  activitySetResponseId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  phraseId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "phrase_responses" */
export type PhraseResponsesVarianceOrderBy = {
  activitySetResponseId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  phraseId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "phrases" */
export type Phrases = {
  __typename?: 'phrases';
  activitySetId: Scalars['Int']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isPronunciation?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  language?: Maybe<Languages>;
  order: Scalars['Int']['output'];
  phrase: Scalars['String']['output'];
  prompt?: Maybe<Scalars['String']['output']>;
  pronunciation?: Maybe<Scalars['String']['output']>;
  translation?: Maybe<Scalars['String']['output']>;
  translationLanguage?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "phrases" */
export type PhrasesAggregate = {
  __typename?: 'phrases_aggregate';
  aggregate?: Maybe<PhrasesAggregateFields>;
  nodes: Array<Phrases>;
};

export type PhrasesAggregateBoolExp = {
  bool_and?: InputMaybe<PhrasesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<PhrasesAggregateBoolExpBoolOr>;
  count?: InputMaybe<PhrasesAggregateBoolExpCount>;
};

export type PhrasesAggregateBoolExpBoolAnd = {
  arguments: PhrasesSelectColumnPhrasesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PhrasesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PhrasesAggregateBoolExpBoolOr = {
  arguments: PhrasesSelectColumnPhrasesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PhrasesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PhrasesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PhrasesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PhrasesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "phrases" */
export type PhrasesAggregateFields = {
  __typename?: 'phrases_aggregate_fields';
  avg?: Maybe<PhrasesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PhrasesMaxFields>;
  min?: Maybe<PhrasesMinFields>;
  stddev?: Maybe<PhrasesStddevFields>;
  stddev_pop?: Maybe<PhrasesStddevPopFields>;
  stddev_samp?: Maybe<PhrasesStddevSampFields>;
  sum?: Maybe<PhrasesSumFields>;
  var_pop?: Maybe<PhrasesVarPopFields>;
  var_samp?: Maybe<PhrasesVarSampFields>;
  variance?: Maybe<PhrasesVarianceFields>;
};


/** aggregate fields of "phrases" */
export type PhrasesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PhrasesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "phrases" */
export type PhrasesAggregateOrderBy = {
  avg?: InputMaybe<PhrasesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PhrasesMaxOrderBy>;
  min?: InputMaybe<PhrasesMinOrderBy>;
  stddev?: InputMaybe<PhrasesStddevOrderBy>;
  stddev_pop?: InputMaybe<PhrasesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<PhrasesStddevSampOrderBy>;
  sum?: InputMaybe<PhrasesSumOrderBy>;
  var_pop?: InputMaybe<PhrasesVarPopOrderBy>;
  var_samp?: InputMaybe<PhrasesVarSampOrderBy>;
  variance?: InputMaybe<PhrasesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "phrases" */
export type PhrasesArrRelInsertInput = {
  data: Array<PhrasesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<PhrasesOnConflict>;
};

/** aggregate avg on columns */
export type PhrasesAvgFields = {
  __typename?: 'phrases_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  translationLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "phrases" */
export type PhrasesAvgOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "phrases". All fields are combined with a logical 'AND'. */
export type PhrasesBoolExp = {
  _and?: InputMaybe<Array<PhrasesBoolExp>>;
  _not?: InputMaybe<PhrasesBoolExp>;
  _or?: InputMaybe<Array<PhrasesBoolExp>>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isPronunciation?: InputMaybe<BooleanComparisonExp>;
  language?: InputMaybe<LanguagesBoolExp>;
  order?: InputMaybe<IntComparisonExp>;
  phrase?: InputMaybe<StringComparisonExp>;
  prompt?: InputMaybe<StringComparisonExp>;
  pronunciation?: InputMaybe<StringComparisonExp>;
  translation?: InputMaybe<StringComparisonExp>;
  translationLanguage?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "phrases" */
export enum PhrasesConstraint {
  /** unique or primary key constraint on columns "id" */
  PhrasesPkey = 'phrases_pkey'
}

/** input type for incrementing numeric columns in table "phrases" */
export type PhrasesIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  translationLanguage?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "phrases" */
export type PhrasesInsertInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isPronunciation?: InputMaybe<Scalars['Boolean']['input']>;
  language?: InputMaybe<LanguagesObjRelInsertInput>;
  order?: InputMaybe<Scalars['Int']['input']>;
  phrase?: InputMaybe<Scalars['String']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  pronunciation?: InputMaybe<Scalars['String']['input']>;
  translation?: InputMaybe<Scalars['String']['input']>;
  translationLanguage?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type PhrasesMaxFields = {
  __typename?: 'phrases_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  phrase?: Maybe<Scalars['String']['output']>;
  prompt?: Maybe<Scalars['String']['output']>;
  pronunciation?: Maybe<Scalars['String']['output']>;
  translation?: Maybe<Scalars['String']['output']>;
  translationLanguage?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "phrases" */
export type PhrasesMaxOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  phrase?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  pronunciation?: InputMaybe<OrderBy>;
  translation?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PhrasesMinFields = {
  __typename?: 'phrases_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  phrase?: Maybe<Scalars['String']['output']>;
  prompt?: Maybe<Scalars['String']['output']>;
  pronunciation?: Maybe<Scalars['String']['output']>;
  translation?: Maybe<Scalars['String']['output']>;
  translationLanguage?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "phrases" */
export type PhrasesMinOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  phrase?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  pronunciation?: InputMaybe<OrderBy>;
  translation?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "phrases" */
export type PhrasesMutationResponse = {
  __typename?: 'phrases_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Phrases>;
};

/** input type for inserting object relation for remote table "phrases" */
export type PhrasesObjRelInsertInput = {
  data: PhrasesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<PhrasesOnConflict>;
};

/** on_conflict condition type for table "phrases" */
export type PhrasesOnConflict = {
  constraint: PhrasesConstraint;
  update_columns?: Array<PhrasesUpdateColumn>;
  where?: InputMaybe<PhrasesBoolExp>;
};

/** Ordering options when selecting data from "phrases". */
export type PhrasesOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isPronunciation?: InputMaybe<OrderBy>;
  language?: InputMaybe<LanguagesOrderBy>;
  order?: InputMaybe<OrderBy>;
  phrase?: InputMaybe<OrderBy>;
  prompt?: InputMaybe<OrderBy>;
  pronunciation?: InputMaybe<OrderBy>;
  translation?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: phrases */
export type PhrasesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "phrases" */
export enum PhrasesSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  IsPronunciation = 'isPronunciation',
  /** column name */
  Order = 'order',
  /** column name */
  Phrase = 'phrase',
  /** column name */
  Prompt = 'prompt',
  /** column name */
  Pronunciation = 'pronunciation',
  /** column name */
  Translation = 'translation',
  /** column name */
  TranslationLanguage = 'translationLanguage',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "phrases_aggregate_bool_exp_bool_and_arguments_columns" columns of table "phrases" */
export enum PhrasesSelectColumnPhrasesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsPronunciation = 'isPronunciation'
}

/** select "phrases_aggregate_bool_exp_bool_or_arguments_columns" columns of table "phrases" */
export enum PhrasesSelectColumnPhrasesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsPronunciation = 'isPronunciation'
}

/** input type for updating data in table "phrases" */
export type PhrasesSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isPronunciation?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  phrase?: InputMaybe<Scalars['String']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  pronunciation?: InputMaybe<Scalars['String']['input']>;
  translation?: InputMaybe<Scalars['String']['input']>;
  translationLanguage?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type PhrasesStddevFields = {
  __typename?: 'phrases_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  translationLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "phrases" */
export type PhrasesStddevOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type PhrasesStddevPopFields = {
  __typename?: 'phrases_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  translationLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "phrases" */
export type PhrasesStddevPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type PhrasesStddevSampFields = {
  __typename?: 'phrases_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  translationLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "phrases" */
export type PhrasesStddevSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "phrases" */
export type PhrasesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PhrasesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PhrasesStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isPronunciation?: InputMaybe<Scalars['Boolean']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  phrase?: InputMaybe<Scalars['String']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  pronunciation?: InputMaybe<Scalars['String']['input']>;
  translation?: InputMaybe<Scalars['String']['input']>;
  translationLanguage?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type PhrasesSumFields = {
  __typename?: 'phrases_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  translationLanguage?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "phrases" */
export type PhrasesSumOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
};

/** update columns of table "phrases" */
export enum PhrasesUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  IsPronunciation = 'isPronunciation',
  /** column name */
  Order = 'order',
  /** column name */
  Phrase = 'phrase',
  /** column name */
  Prompt = 'prompt',
  /** column name */
  Pronunciation = 'pronunciation',
  /** column name */
  Translation = 'translation',
  /** column name */
  TranslationLanguage = 'translationLanguage',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type PhrasesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PhrasesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PhrasesSetInput>;
  /** filter the rows which have to be updated */
  where: PhrasesBoolExp;
};

/** aggregate var_pop on columns */
export type PhrasesVarPopFields = {
  __typename?: 'phrases_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  translationLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "phrases" */
export type PhrasesVarPopOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type PhrasesVarSampFields = {
  __typename?: 'phrases_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  translationLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "phrases" */
export type PhrasesVarSampOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PhrasesVarianceFields = {
  __typename?: 'phrases_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  translationLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "phrases" */
export type PhrasesVarianceOrderBy = {
  activitySetId?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  translationLanguage?: InputMaybe<OrderBy>;
};

/** columns and relationships of "poem_lines" */
export type PoemLines = {
  __typename?: 'poem_lines';
  attribution?: Maybe<Scalars['String']['output']>;
  audio?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  languageId: Scalars['Int']['output'];
  lines: Scalars['jsonb']['output'];
  poemId: Scalars['Int']['output'];
  subjectId?: Maybe<Scalars['Int']['output']>;
  title: Scalars['String']['output'];
};


/** columns and relationships of "poem_lines" */
export type PoemLinesLinesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "poem_lines" */
export type PoemLinesAggregate = {
  __typename?: 'poem_lines_aggregate';
  aggregate?: Maybe<PoemLinesAggregateFields>;
  nodes: Array<PoemLines>;
};

export type PoemLinesAggregateBoolExp = {
  count?: InputMaybe<PoemLinesAggregateBoolExpCount>;
};

export type PoemLinesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PoemLinesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PoemLinesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "poem_lines" */
export type PoemLinesAggregateFields = {
  __typename?: 'poem_lines_aggregate_fields';
  avg?: Maybe<PoemLinesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PoemLinesMaxFields>;
  min?: Maybe<PoemLinesMinFields>;
  stddev?: Maybe<PoemLinesStddevFields>;
  stddev_pop?: Maybe<PoemLinesStddevPopFields>;
  stddev_samp?: Maybe<PoemLinesStddevSampFields>;
  sum?: Maybe<PoemLinesSumFields>;
  var_pop?: Maybe<PoemLinesVarPopFields>;
  var_samp?: Maybe<PoemLinesVarSampFields>;
  variance?: Maybe<PoemLinesVarianceFields>;
};


/** aggregate fields of "poem_lines" */
export type PoemLinesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PoemLinesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "poem_lines" */
export type PoemLinesAggregateOrderBy = {
  avg?: InputMaybe<PoemLinesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PoemLinesMaxOrderBy>;
  min?: InputMaybe<PoemLinesMinOrderBy>;
  stddev?: InputMaybe<PoemLinesStddevOrderBy>;
  stddev_pop?: InputMaybe<PoemLinesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<PoemLinesStddevSampOrderBy>;
  sum?: InputMaybe<PoemLinesSumOrderBy>;
  var_pop?: InputMaybe<PoemLinesVarPopOrderBy>;
  var_samp?: InputMaybe<PoemLinesVarSampOrderBy>;
  variance?: InputMaybe<PoemLinesVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type PoemLinesAppendInput = {
  lines?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "poem_lines" */
export type PoemLinesArrRelInsertInput = {
  data: Array<PoemLinesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<PoemLinesOnConflict>;
};

/** aggregate avg on columns */
export type PoemLinesAvgFields = {
  __typename?: 'poem_lines_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "poem_lines" */
export type PoemLinesAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "poem_lines". All fields are combined with a logical 'AND'. */
export type PoemLinesBoolExp = {
  _and?: InputMaybe<Array<PoemLinesBoolExp>>;
  _not?: InputMaybe<PoemLinesBoolExp>;
  _or?: InputMaybe<Array<PoemLinesBoolExp>>;
  attribution?: InputMaybe<StringComparisonExp>;
  audio?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  languageId?: InputMaybe<IntComparisonExp>;
  lines?: InputMaybe<JsonbComparisonExp>;
  poemId?: InputMaybe<IntComparisonExp>;
  subjectId?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "poem_lines" */
export enum PoemLinesConstraint {
  /** unique or primary key constraint on columns "language_id", "poem_id" */
  PoemLinesLanguageIdPoemIdKey = 'poem_lines_language_id_poem_id_key',
  /** unique or primary key constraint on columns "id" */
  PoemLinesPkey = 'poem_lines_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type PoemLinesDeleteAtPathInput = {
  lines?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type PoemLinesDeleteElemInput = {
  lines?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type PoemLinesDeleteKeyInput = {
  lines?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "poem_lines" */
export type PoemLinesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  poemId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "poem_lines" */
export type PoemLinesInsertInput = {
  attribution?: InputMaybe<Scalars['String']['input']>;
  audio?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  lines?: InputMaybe<Scalars['jsonb']['input']>;
  poemId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type PoemLinesMaxFields = {
  __typename?: 'poem_lines_max_fields';
  attribution?: Maybe<Scalars['String']['output']>;
  audio?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  poemId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "poem_lines" */
export type PoemLinesMaxOrderBy = {
  attribution?: InputMaybe<OrderBy>;
  audio?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PoemLinesMinFields = {
  __typename?: 'poem_lines_min_fields';
  attribution?: Maybe<Scalars['String']['output']>;
  audio?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  poemId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "poem_lines" */
export type PoemLinesMinOrderBy = {
  attribution?: InputMaybe<OrderBy>;
  audio?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "poem_lines" */
export type PoemLinesMutationResponse = {
  __typename?: 'poem_lines_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PoemLines>;
};

/** on_conflict condition type for table "poem_lines" */
export type PoemLinesOnConflict = {
  constraint: PoemLinesConstraint;
  update_columns?: Array<PoemLinesUpdateColumn>;
  where?: InputMaybe<PoemLinesBoolExp>;
};

/** Ordering options when selecting data from "poem_lines". */
export type PoemLinesOrderBy = {
  attribution?: InputMaybe<OrderBy>;
  audio?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  lines?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: poem_lines */
export type PoemLinesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type PoemLinesPrependInput = {
  lines?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "poem_lines" */
export enum PoemLinesSelectColumn {
  /** column name */
  Attribution = 'attribution',
  /** column name */
  Audio = 'audio',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  Lines = 'lines',
  /** column name */
  PoemId = 'poemId',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title'
}

/** input type for updating data in table "poem_lines" */
export type PoemLinesSetInput = {
  attribution?: InputMaybe<Scalars['String']['input']>;
  audio?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  lines?: InputMaybe<Scalars['jsonb']['input']>;
  poemId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type PoemLinesStddevFields = {
  __typename?: 'poem_lines_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "poem_lines" */
export type PoemLinesStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type PoemLinesStddevPopFields = {
  __typename?: 'poem_lines_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "poem_lines" */
export type PoemLinesStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type PoemLinesStddevSampFields = {
  __typename?: 'poem_lines_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "poem_lines" */
export type PoemLinesStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "poem_lines" */
export type PoemLinesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PoemLinesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PoemLinesStreamCursorValueInput = {
  attribution?: InputMaybe<Scalars['String']['input']>;
  audio?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  lines?: InputMaybe<Scalars['jsonb']['input']>;
  poemId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type PoemLinesSumFields = {
  __typename?: 'poem_lines_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  poemId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "poem_lines" */
export type PoemLinesSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
};

/** update columns of table "poem_lines" */
export enum PoemLinesUpdateColumn {
  /** column name */
  Attribution = 'attribution',
  /** column name */
  Audio = 'audio',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  Lines = 'lines',
  /** column name */
  PoemId = 'poemId',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title'
}

export type PoemLinesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<PoemLinesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<PoemLinesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<PoemLinesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<PoemLinesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PoemLinesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<PoemLinesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PoemLinesSetInput>;
  /** filter the rows which have to be updated */
  where: PoemLinesBoolExp;
};

/** aggregate var_pop on columns */
export type PoemLinesVarPopFields = {
  __typename?: 'poem_lines_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "poem_lines" */
export type PoemLinesVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type PoemLinesVarSampFields = {
  __typename?: 'poem_lines_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "poem_lines" */
export type PoemLinesVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PoemLinesVarianceFields = {
  __typename?: 'poem_lines_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  poemId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "poem_lines" */
export type PoemLinesVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemId?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
};

/** poems for games */
export type Poems = {
  __typename?: 'poems';
  audioUrl?: Maybe<Scalars['String']['output']>;
  author: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  isBible?: Maybe<Scalars['Boolean']['output']>;
  languageId: Scalars['Int']['output'];
  /** An array relationship */
  poemLines: Array<PoemLines>;
  /** An aggregate relationship */
  poemLines_aggregate: PoemLinesAggregate;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title: Scalars['String']['output'];
};


/** poems for games */
export type PoemsPoemLinesArgs = {
  distinct_on?: InputMaybe<Array<PoemLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemLinesOrderBy>>;
  where?: InputMaybe<PoemLinesBoolExp>;
};


/** poems for games */
export type PoemsPoemLinesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PoemLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemLinesOrderBy>>;
  where?: InputMaybe<PoemLinesBoolExp>;
};

export type PoemsAggregate = {
  __typename?: 'poems_aggregate';
  aggregate?: Maybe<PoemsAggregateFields>;
  nodes: Array<Poems>;
};

/** aggregate fields of "poems" */
export type PoemsAggregateFields = {
  __typename?: 'poems_aggregate_fields';
  avg?: Maybe<PoemsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PoemsMaxFields>;
  min?: Maybe<PoemsMinFields>;
  stddev?: Maybe<PoemsStddevFields>;
  stddev_pop?: Maybe<PoemsStddevPopFields>;
  stddev_samp?: Maybe<PoemsStddevSampFields>;
  sum?: Maybe<PoemsSumFields>;
  var_pop?: Maybe<PoemsVarPopFields>;
  var_samp?: Maybe<PoemsVarSampFields>;
  variance?: Maybe<PoemsVarianceFields>;
};


/** aggregate fields of "poems" */
export type PoemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PoemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PoemsAvgFields = {
  __typename?: 'poems_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "poems". All fields are combined with a logical 'AND'. */
export type PoemsBoolExp = {
  _and?: InputMaybe<Array<PoemsBoolExp>>;
  _not?: InputMaybe<PoemsBoolExp>;
  _or?: InputMaybe<Array<PoemsBoolExp>>;
  audioUrl?: InputMaybe<StringComparisonExp>;
  author?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isBible?: InputMaybe<BooleanComparisonExp>;
  languageId?: InputMaybe<IntComparisonExp>;
  poemLines?: InputMaybe<PoemLinesBoolExp>;
  poemLines_aggregate?: InputMaybe<PoemLinesAggregateBoolExp>;
  subjectId?: InputMaybe<IntComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "poems" */
export enum PoemsConstraint {
  /** unique or primary key constraint on columns "id" */
  PoemsPkey = 'poems_pkey'
}

/** input type for incrementing numeric columns in table "poems" */
export type PoemsIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "poems" */
export type PoemsInsertInput = {
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isBible?: InputMaybe<Scalars['Boolean']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  poemLines?: InputMaybe<PoemLinesArrRelInsertInput>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type PoemsMaxFields = {
  __typename?: 'poems_max_fields';
  audioUrl?: Maybe<Scalars['String']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type PoemsMinFields = {
  __typename?: 'poems_min_fields';
  audioUrl?: Maybe<Scalars['String']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "poems" */
export type PoemsMutationResponse = {
  __typename?: 'poems_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Poems>;
};

/** on_conflict condition type for table "poems" */
export type PoemsOnConflict = {
  constraint: PoemsConstraint;
  update_columns?: Array<PoemsUpdateColumn>;
  where?: InputMaybe<PoemsBoolExp>;
};

/** Ordering options when selecting data from "poems". */
export type PoemsOrderBy = {
  audioUrl?: InputMaybe<OrderBy>;
  author?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isBible?: InputMaybe<OrderBy>;
  languageId?: InputMaybe<OrderBy>;
  poemLines_aggregate?: InputMaybe<PoemLinesAggregateOrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: poems */
export type PoemsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "poems" */
export enum PoemsSelectColumn {
  /** column name */
  AudioUrl = 'audioUrl',
  /** column name */
  Author = 'author',
  /** column name */
  Id = 'id',
  /** column name */
  IsBible = 'isBible',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title'
}

/** input type for updating data in table "poems" */
export type PoemsSetInput = {
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isBible?: InputMaybe<Scalars['Boolean']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type PoemsStddevFields = {
  __typename?: 'poems_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type PoemsStddevPopFields = {
  __typename?: 'poems_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type PoemsStddevSampFields = {
  __typename?: 'poems_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "poems" */
export type PoemsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PoemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PoemsStreamCursorValueInput = {
  audioUrl?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isBible?: InputMaybe<Scalars['Boolean']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type PoemsSumFields = {
  __typename?: 'poems_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "poems" */
export enum PoemsUpdateColumn {
  /** column name */
  AudioUrl = 'audioUrl',
  /** column name */
  Author = 'author',
  /** column name */
  Id = 'id',
  /** column name */
  IsBible = 'isBible',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  Title = 'title'
}

export type PoemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PoemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PoemsSetInput>;
  /** filter the rows which have to be updated */
  where: PoemsBoolExp;
};

/** aggregate var_pop on columns */
export type PoemsVarPopFields = {
  __typename?: 'poems_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type PoemsVarSampFields = {
  __typename?: 'poems_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PoemsVarianceFields = {
  __typename?: 'poems_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "prepositions" */
export type Prepositions = {
  __typename?: 'prepositions';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  tags: Scalars['jsonb']['output'];
  url: Scalars['String']['output'];
};


/** columns and relationships of "prepositions" */
export type PrepositionsTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "prepositions" */
export type PrepositionsAggregate = {
  __typename?: 'prepositions_aggregate';
  aggregate?: Maybe<PrepositionsAggregateFields>;
  nodes: Array<Prepositions>;
};

/** aggregate fields of "prepositions" */
export type PrepositionsAggregateFields = {
  __typename?: 'prepositions_aggregate_fields';
  avg?: Maybe<PrepositionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PrepositionsMaxFields>;
  min?: Maybe<PrepositionsMinFields>;
  stddev?: Maybe<PrepositionsStddevFields>;
  stddev_pop?: Maybe<PrepositionsStddevPopFields>;
  stddev_samp?: Maybe<PrepositionsStddevSampFields>;
  sum?: Maybe<PrepositionsSumFields>;
  var_pop?: Maybe<PrepositionsVarPopFields>;
  var_samp?: Maybe<PrepositionsVarSampFields>;
  variance?: Maybe<PrepositionsVarianceFields>;
};


/** aggregate fields of "prepositions" */
export type PrepositionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PrepositionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type PrepositionsAppendInput = {
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type PrepositionsAvgFields = {
  __typename?: 'prepositions_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "prepositions". All fields are combined with a logical 'AND'. */
export type PrepositionsBoolExp = {
  _and?: InputMaybe<Array<PrepositionsBoolExp>>;
  _not?: InputMaybe<PrepositionsBoolExp>;
  _or?: InputMaybe<Array<PrepositionsBoolExp>>;
  id?: InputMaybe<IntComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  tags?: InputMaybe<JsonbComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "prepositions" */
export enum PrepositionsConstraint {
  /** unique or primary key constraint on columns "id" */
  PrepositionsPkey = 'prepositions_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type PrepositionsDeleteAtPathInput = {
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type PrepositionsDeleteElemInput = {
  tags?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type PrepositionsDeleteKeyInput = {
  tags?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "prepositions" */
export type PrepositionsIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "prepositions" */
export type PrepositionsInsertInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type PrepositionsMaxFields = {
  __typename?: 'prepositions_max_fields';
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type PrepositionsMinFields = {
  __typename?: 'prepositions_min_fields';
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "prepositions" */
export type PrepositionsMutationResponse = {
  __typename?: 'prepositions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Prepositions>;
};

/** on_conflict condition type for table "prepositions" */
export type PrepositionsOnConflict = {
  constraint: PrepositionsConstraint;
  update_columns?: Array<PrepositionsUpdateColumn>;
  where?: InputMaybe<PrepositionsBoolExp>;
};

/** Ordering options when selecting data from "prepositions". */
export type PrepositionsOrderBy = {
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  tags?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: prepositions */
export type PrepositionsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type PrepositionsPrependInput = {
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "prepositions" */
export enum PrepositionsSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Tags = 'tags',
  /** column name */
  Url = 'url'
}

/** input type for updating data in table "prepositions" */
export type PrepositionsSetInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type PrepositionsStddevFields = {
  __typename?: 'prepositions_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type PrepositionsStddevPopFields = {
  __typename?: 'prepositions_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type PrepositionsStddevSampFields = {
  __typename?: 'prepositions_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "prepositions" */
export type PrepositionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PrepositionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PrepositionsStreamCursorValueInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type PrepositionsSumFields = {
  __typename?: 'prepositions_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "prepositions" */
export enum PrepositionsUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Tags = 'tags',
  /** column name */
  Url = 'url'
}

export type PrepositionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<PrepositionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<PrepositionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<PrepositionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<PrepositionsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PrepositionsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<PrepositionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PrepositionsSetInput>;
  /** filter the rows which have to be updated */
  where: PrepositionsBoolExp;
};

/** aggregate var_pop on columns */
export type PrepositionsVarPopFields = {
  __typename?: 'prepositions_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type PrepositionsVarSampFields = {
  __typename?: 'prepositions_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PrepositionsVarianceFields = {
  __typename?: 'prepositions_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

export type QueryRoot = {
  __typename?: 'query_root';
  /** fetch data from the table: "activity_set_assignments" */
  activity_set_assignments: Array<ActivitySetAssignments>;
  /** fetch aggregated fields from the table: "activity_set_assignments" */
  activity_set_assignments_aggregate: ActivitySetAssignmentsAggregate;
  /** fetch data from the table: "activity_set_assignments" using primary key columns */
  activity_set_assignments_by_pk?: Maybe<ActivitySetAssignments>;
  /** fetch data from the table: "activity_set_reports" */
  activity_set_reports: Array<ActivitySetReports>;
  /** fetch aggregated fields from the table: "activity_set_reports" */
  activity_set_reports_aggregate: ActivitySetReportsAggregate;
  /** fetch data from the table: "activity_set_reports" using primary key columns */
  activity_set_reports_by_pk?: Maybe<ActivitySetReports>;
  /** fetch data from the table: "activity_set_responses" */
  activity_set_responses: Array<ActivitySetResponses>;
  /** fetch aggregated fields from the table: "activity_set_responses" */
  activity_set_responses_aggregate: ActivitySetResponsesAggregate;
  /** fetch data from the table: "activity_set_responses" using primary key columns */
  activity_set_responses_by_pk?: Maybe<ActivitySetResponses>;
  /** fetch data from the table: "activity_sets" */
  activity_sets: Array<ActivitySets>;
  /** fetch aggregated fields from the table: "activity_sets" */
  activity_sets_aggregate: ActivitySetsAggregate;
  /** fetch data from the table: "activity_sets" using primary key columns */
  activity_sets_by_pk?: Maybe<ActivitySets>;
  /** An array relationship */
  addresses: Array<Addresses>;
  /** An aggregate relationship */
  addresses_aggregate: AddressesAggregate;
  /** fetch data from the table: "addresses" using primary key columns */
  addresses_by_pk?: Maybe<Addresses>;
  /** fetch data from the table: "anagram_responses" */
  anagram_responses: Array<AnagramResponses>;
  /** fetch aggregated fields from the table: "anagram_responses" */
  anagram_responses_aggregate: AnagramResponsesAggregate;
  /** fetch data from the table: "anagram_responses" using primary key columns */
  anagram_responses_by_pk?: Maybe<AnagramResponses>;
  /** An array relationship */
  anagrams: Array<Anagrams>;
  /** An aggregate relationship */
  anagrams_aggregate: AnagramsAggregate;
  /** fetch data from the table: "anagrams" using primary key columns */
  anagrams_by_pk?: Maybe<Anagrams>;
  /** fetch data from the table: "annotations" */
  annotations: Array<Annotations>;
  /** fetch aggregated fields from the table: "annotations" */
  annotations_aggregate: AnnotationsAggregate;
  /** fetch data from the table: "annotations" using primary key columns */
  annotations_by_pk?: Maybe<Annotations>;
  /** fetch data from the table: "application_reviews" */
  application_reviews: Array<ApplicationReviews>;
  /** fetch aggregated fields from the table: "application_reviews" */
  application_reviews_aggregate: ApplicationReviewsAggregate;
  /** fetch data from the table: "application_reviews" using primary key columns */
  application_reviews_by_pk?: Maybe<ApplicationReviews>;
  /** fetch data from the table: "availability_times" */
  availability_times: Array<AvailabilityTimes>;
  /** fetch aggregated fields from the table: "availability_times" */
  availability_times_aggregate: AvailabilityTimesAggregate;
  /** fetch data from the table: "availability_times" using primary key columns */
  availability_times_by_pk?: Maybe<AvailabilityTimes>;
  /** fetch data from the table: "cefr_levels" */
  cefr_levels: Array<CefrLevels>;
  /** fetch aggregated fields from the table: "cefr_levels" */
  cefr_levels_aggregate: CefrLevelsAggregate;
  /** fetch data from the table: "cefr_levels" using primary key columns */
  cefr_levels_by_pk?: Maybe<CefrLevels>;
  /** fetch data from the table: "class_activity_sets" */
  class_activity_sets: Array<ClassActivitySets>;
  /** fetch aggregated fields from the table: "class_activity_sets" */
  class_activity_sets_aggregate: ClassActivitySetsAggregate;
  /** fetch data from the table: "class_activity_sets" using primary key columns */
  class_activity_sets_by_pk?: Maybe<ClassActivitySets>;
  /** fetch data from the table: "class_annotations" */
  class_annotations: Array<ClassAnnotations>;
  /** fetch aggregated fields from the table: "class_annotations" */
  class_annotations_aggregate: ClassAnnotationsAggregate;
  /** fetch data from the table: "class_annotations" using primary key columns */
  class_annotations_by_pk?: Maybe<ClassAnnotations>;
  /** fetch data from the table: "class_courses" */
  class_courses: Array<ClassCourses>;
  /** fetch aggregated fields from the table: "class_courses" */
  class_courses_aggregate: ClassCoursesAggregate;
  /** fetch data from the table: "class_courses" using primary key columns */
  class_courses_by_pk?: Maybe<ClassCourses>;
  /** fetch data from the table: "class_sessions" */
  class_sessions: Array<ClassSessions>;
  /** fetch aggregated fields from the table: "class_sessions" */
  class_sessions_aggregate: ClassSessionsAggregate;
  /** fetch data from the table: "class_sessions" using primary key columns */
  class_sessions_by_pk?: Maybe<ClassSessions>;
  /** fetch data from the table: "class_slot_bookings" */
  class_slot_bookings: Array<ClassSlotBookings>;
  /** fetch aggregated fields from the table: "class_slot_bookings" */
  class_slot_bookings_aggregate: ClassSlotBookingsAggregate;
  /** fetch data from the table: "class_slot_bookings" using primary key columns */
  class_slot_bookings_by_pk?: Maybe<ClassSlotBookings>;
  /** fetch data from the table: "classes" */
  classes: Array<Classes>;
  /** fetch aggregated fields from the table: "classes" */
  classes_aggregate: ClassesAggregate;
  /** fetch data from the table: "classes" using primary key columns */
  classes_by_pk?: Maybe<Classes>;
  /** An array relationship */
  course_activities: Array<CourseActivities>;
  /** An aggregate relationship */
  course_activities_aggregate: CourseActivitiesAggregate;
  /** fetch data from the table: "course_activities" using primary key columns */
  course_activities_by_pk?: Maybe<CourseActivities>;
  /** fetch data from the table: "course_reviews" */
  course_reviews: Array<CourseReviews>;
  /** fetch aggregated fields from the table: "course_reviews" */
  course_reviews_aggregate: CourseReviewsAggregate;
  /** fetch data from the table: "course_reviews" using primary key columns */
  course_reviews_by_pk?: Maybe<CourseReviews>;
  /** fetch data from the table: "course_summary" */
  course_summary: Array<CourseSummary>;
  /** fetch aggregated fields from the table: "course_summary" */
  course_summary_aggregate: CourseSummaryAggregate;
  /** fetch data from the table: "courses" */
  courses: Array<Courses>;
  /** fetch aggregated fields from the table: "courses" */
  courses_aggregate: CoursesAggregate;
  /** fetch data from the table: "courses" using primary key columns */
  courses_by_pk?: Maybe<Courses>;
  /** fetch data from the table: "daily_stats" */
  daily_stats: Array<DailyStats>;
  /** fetch aggregated fields from the table: "daily_stats" */
  daily_stats_aggregate: DailyStatsAggregate;
  /** fetch data from the table: "daily_stats" using primary key columns */
  daily_stats_by_pk?: Maybe<DailyStats>;
  /** fetch data from the table: "dictionaries" */
  dictionaries: Array<Dictionaries>;
  /** fetch aggregated fields from the table: "dictionaries" */
  dictionaries_aggregate: DictionariesAggregate;
  /** fetch data from the table: "dictionaries" using primary key columns */
  dictionaries_by_pk?: Maybe<Dictionaries>;
  /** fetch data from the table: "emojis" */
  emojis: Array<Emojis>;
  /** fetch aggregated fields from the table: "emojis" */
  emojis_aggregate: EmojisAggregate;
  /** fetch data from the table: "emojis" using primary key columns */
  emojis_by_pk?: Maybe<Emojis>;
  /** fetch data from the table: "employees" */
  employees: Array<Employees>;
  /** fetch aggregated fields from the table: "employees" */
  employees_aggregate: EmployeesAggregate;
  /** fetch data from the table: "employees" using primary key columns */
  employees_by_pk?: Maybe<Employees>;
  /** fetch data from the table: "example_joins" */
  example_joins: Array<ExampleJoins>;
  /** fetch aggregated fields from the table: "example_joins" */
  example_joins_aggregate: ExampleJoinsAggregate;
  /** fetch data from the table: "example_joins" using primary key columns */
  example_joins_by_pk?: Maybe<ExampleJoins>;
  /** fetch data from the table: "examples" */
  examples: Array<Examples>;
  /** fetch aggregated fields from the table: "examples" */
  examples_aggregate: ExamplesAggregate;
  /** fetch data from the table: "examples" using primary key columns */
  examples_by_pk?: Maybe<Examples>;
  /** fetch data from the table: "expired_refresh_tokens" */
  expired_refresh_tokens: Array<ExpiredRefreshTokens>;
  /** fetch aggregated fields from the table: "expired_refresh_tokens" */
  expired_refresh_tokens_aggregate: ExpiredRefreshTokensAggregate;
  /** fetch data from the table: "expired_refresh_tokens" using primary key columns */
  expired_refresh_tokens_by_pk?: Maybe<ExpiredRefreshTokens>;
  /** fetch data from the table: "fill_in_the_blank_options" */
  fill_in_the_blank_options: Array<FillInTheBlankOptions>;
  /** fetch aggregated fields from the table: "fill_in_the_blank_options" */
  fill_in_the_blank_options_aggregate: FillInTheBlankOptionsAggregate;
  /** fetch data from the table: "fill_in_the_blank_options" using primary key columns */
  fill_in_the_blank_options_by_pk?: Maybe<FillInTheBlankOptions>;
  /** fetch data from the table: "fill_in_the_blank_responses" */
  fill_in_the_blank_responses: Array<FillInTheBlankResponses>;
  /** fetch aggregated fields from the table: "fill_in_the_blank_responses" */
  fill_in_the_blank_responses_aggregate: FillInTheBlankResponsesAggregate;
  /** fetch data from the table: "fill_in_the_blank_responses" using primary key columns */
  fill_in_the_blank_responses_by_pk?: Maybe<FillInTheBlankResponses>;
  /** fetch data from the table: "fill_in_the_blanks" */
  fill_in_the_blanks: Array<FillInTheBlanks>;
  /** fetch aggregated fields from the table: "fill_in_the_blanks" */
  fill_in_the_blanks_aggregate: FillInTheBlanksAggregate;
  /** fetch data from the table: "fill_in_the_blanks" using primary key columns */
  fill_in_the_blanks_by_pk?: Maybe<FillInTheBlanks>;
  /** fetch data from the table: "game_dailies" */
  game_dailies: Array<GameDailies>;
  /** fetch aggregated fields from the table: "game_dailies" */
  game_dailies_aggregate: GameDailiesAggregate;
  /** fetch data from the table: "game_dailies" using primary key columns */
  game_dailies_by_pk?: Maybe<GameDailies>;
  /** fetch data from the table: "game_difficulty" */
  game_difficulty: Array<GameDifficulty>;
  /** fetch aggregated fields from the table: "game_difficulty" */
  game_difficulty_aggregate: GameDifficultyAggregate;
  /** fetch data from the table: "game_difficulty" using primary key columns */
  game_difficulty_by_pk?: Maybe<GameDifficulty>;
  /** fetch data from the table: "game_types" */
  game_types: Array<GameTypes>;
  /** fetch aggregated fields from the table: "game_types" */
  game_types_aggregate: GameTypesAggregate;
  /** fetch data from the table: "game_types" using primary key columns */
  game_types_by_pk?: Maybe<GameTypes>;
  /** fetch data from the table: "game_users" */
  game_users: Array<GameUsers>;
  /** fetch aggregated fields from the table: "game_users" */
  game_users_aggregate: GameUsersAggregate;
  /** fetch data from the table: "game_users" using primary key columns */
  game_users_by_pk?: Maybe<GameUsers>;
  /** fetch data from the table: "games" */
  games: Array<Games>;
  /** fetch aggregated fields from the table: "games" */
  games_aggregate: GamesAggregate;
  /** fetch data from the table: "games" using primary key columns */
  games_by_pk?: Maybe<Games>;
  /** execute function "get_random_poem" which returns "poems" */
  get_random_poem: Array<Poems>;
  /** execute function "get_random_poem" and query aggregates on result of table type "poems" */
  get_random_poem_aggregate: PoemsAggregate;
  /** execute function "get_user_words_count" which returns "user_words_count" */
  get_user_words_count: Array<UserWordsCount>;
  /** execute function "get_user_words_count" and query aggregates on result of table type "user_words_count" */
  get_user_words_count_aggregate: UserWordsCountAggregate;
  /** fetch data from the table: "goals" */
  goals: Array<Goals>;
  /** fetch aggregated fields from the table: "goals" */
  goals_aggregate: GoalsAggregate;
  /** fetch data from the table: "goals" using primary key columns */
  goals_by_pk?: Maybe<Goals>;
  /** fetch data from the table: "images" */
  images: Array<Images>;
  /** fetch aggregated fields from the table: "images" */
  images_aggregate: ImagesAggregate;
  /** fetch data from the table: "images" using primary key columns */
  images_by_pk?: Maybe<Images>;
  /** fetch data from the table: "interests" */
  interests: Array<Interests>;
  /** fetch aggregated fields from the table: "interests" */
  interests_aggregate: InterestsAggregate;
  /** fetch data from the table: "interests" using primary key columns */
  interests_by_pk?: Maybe<Interests>;
  /** fetch data from the table: "languages" */
  languages: Array<Languages>;
  /** fetch aggregated fields from the table: "languages" */
  languages_aggregate: LanguagesAggregate;
  /** fetch data from the table: "languages" using primary key columns */
  languages_by_pk?: Maybe<Languages>;
  /** fetch data from the table: "listenings" */
  listenings: Array<Listenings>;
  /** fetch aggregated fields from the table: "listenings" */
  listenings_aggregate: ListeningsAggregate;
  /** fetch data from the table: "listenings" using primary key columns */
  listenings_by_pk?: Maybe<Listenings>;
  /** fetch data from the table: "live_class_activities" */
  live_class_activities: Array<LiveClassActivities>;
  /** fetch aggregated fields from the table: "live_class_activities" */
  live_class_activities_aggregate: LiveClassActivitiesAggregate;
  /** fetch data from the table: "live_class_activities" using primary key columns */
  live_class_activities_by_pk?: Maybe<LiveClassActivities>;
  /** fetch data from the table: "live_messages" */
  live_messages: Array<LiveMessages>;
  /** fetch aggregated fields from the table: "live_messages" */
  live_messages_aggregate: LiveMessagesAggregate;
  /** fetch data from the table: "live_messages" using primary key columns */
  live_messages_by_pk?: Maybe<LiveMessages>;
  /** fetch data from the table: "matching_options" */
  matching_options: Array<MatchingOptions>;
  /** fetch aggregated fields from the table: "matching_options" */
  matching_options_aggregate: MatchingOptionsAggregate;
  /** fetch data from the table: "matching_options" using primary key columns */
  matching_options_by_pk?: Maybe<MatchingOptions>;
  /** fetch data from the table: "matching_responses" */
  matching_responses: Array<MatchingResponses>;
  /** fetch aggregated fields from the table: "matching_responses" */
  matching_responses_aggregate: MatchingResponsesAggregate;
  /** fetch data from the table: "matching_responses" using primary key columns */
  matching_responses_by_pk?: Maybe<MatchingResponses>;
  /** An array relationship */
  matchings: Array<Matchings>;
  /** An aggregate relationship */
  matchings_aggregate: MatchingsAggregate;
  /** fetch data from the table: "matchings" using primary key columns */
  matchings_by_pk?: Maybe<Matchings>;
  /** An array relationship */
  messages: Array<Messages>;
  /** An aggregate relationship */
  messages_aggregate: MessagesAggregate;
  /** fetch data from the table: "messages" using primary key columns */
  messages_by_pk?: Maybe<Messages>;
  /** fetch data from the table: "multiple_choice_options" */
  multiple_choice_options: Array<MultipleChoiceOptions>;
  /** fetch aggregated fields from the table: "multiple_choice_options" */
  multiple_choice_options_aggregate: MultipleChoiceOptionsAggregate;
  /** fetch data from the table: "multiple_choice_options" using primary key columns */
  multiple_choice_options_by_pk?: Maybe<MultipleChoiceOptions>;
  /** fetch data from the table: "multiple_choice_responses" */
  multiple_choice_responses: Array<MultipleChoiceResponses>;
  /** fetch aggregated fields from the table: "multiple_choice_responses" */
  multiple_choice_responses_aggregate: MultipleChoiceResponsesAggregate;
  /** fetch data from the table: "multiple_choice_responses" using primary key columns */
  multiple_choice_responses_by_pk?: Maybe<MultipleChoiceResponses>;
  /** fetch data from the table: "multiple_choices" */
  multiple_choices: Array<MultipleChoices>;
  /** fetch aggregated fields from the table: "multiple_choices" */
  multiple_choices_aggregate: MultipleChoicesAggregate;
  /** fetch data from the table: "multiple_choices" using primary key columns */
  multiple_choices_by_pk?: Maybe<MultipleChoices>;
  /** fetch data from the table: "open_answer_responses" */
  open_answer_responses: Array<OpenAnswerResponses>;
  /** fetch aggregated fields from the table: "open_answer_responses" */
  open_answer_responses_aggregate: OpenAnswerResponsesAggregate;
  /** fetch data from the table: "open_answer_responses" using primary key columns */
  open_answer_responses_by_pk?: Maybe<OpenAnswerResponses>;
  /** fetch data from the table: "open_answers" */
  open_answers: Array<OpenAnswers>;
  /** fetch aggregated fields from the table: "open_answers" */
  open_answers_aggregate: OpenAnswersAggregate;
  /** fetch data from the table: "open_answers" using primary key columns */
  open_answers_by_pk?: Maybe<OpenAnswers>;
  /** fetch data from the table: "parts_of_speech" */
  parts_of_speech: Array<PartsOfSpeech>;
  /** fetch aggregated fields from the table: "parts_of_speech" */
  parts_of_speech_aggregate: PartsOfSpeechAggregate;
  /** fetch data from the table: "parts_of_speech" using primary key columns */
  parts_of_speech_by_pk?: Maybe<PartsOfSpeech>;
  /** fetch data from the table: "payments" */
  payments: Array<Payments>;
  /** fetch aggregated fields from the table: "payments" */
  payments_aggregate: PaymentsAggregate;
  /** fetch data from the table: "payments" using primary key columns */
  payments_by_pk?: Maybe<Payments>;
  /** fetch data from the table: "phrase_responses" */
  phrase_responses: Array<PhraseResponses>;
  /** fetch aggregated fields from the table: "phrase_responses" */
  phrase_responses_aggregate: PhraseResponsesAggregate;
  /** fetch data from the table: "phrase_responses" using primary key columns */
  phrase_responses_by_pk?: Maybe<PhraseResponses>;
  /** An array relationship */
  phrases: Array<Phrases>;
  /** An aggregate relationship */
  phrases_aggregate: PhrasesAggregate;
  /** fetch data from the table: "phrases" using primary key columns */
  phrases_by_pk?: Maybe<Phrases>;
  /** fetch data from the table: "poem_lines" */
  poem_lines: Array<PoemLines>;
  /** fetch aggregated fields from the table: "poem_lines" */
  poem_lines_aggregate: PoemLinesAggregate;
  /** fetch data from the table: "poem_lines" using primary key columns */
  poem_lines_by_pk?: Maybe<PoemLines>;
  /** fetch data from the table: "poems" */
  poems: Array<Poems>;
  /** fetch aggregated fields from the table: "poems" */
  poems_aggregate: PoemsAggregate;
  /** fetch data from the table: "poems" using primary key columns */
  poems_by_pk?: Maybe<Poems>;
  /** fetch data from the table: "prepositions" */
  prepositions: Array<Prepositions>;
  /** fetch aggregated fields from the table: "prepositions" */
  prepositions_aggregate: PrepositionsAggregate;
  /** fetch data from the table: "prepositions" using primary key columns */
  prepositions_by_pk?: Maybe<Prepositions>;
  /** fetch data from the table: "readings" */
  readings: Array<Readings>;
  /** fetch aggregated fields from the table: "readings" */
  readings_aggregate: ReadingsAggregate;
  /** fetch data from the table: "readings" using primary key columns */
  readings_by_pk?: Maybe<Readings>;
  /** execute function "search_users" which returns "users" */
  search_users: Array<Users>;
  /** execute function "search_users" and query aggregates on result of table type "users" */
  search_users_aggregate: UsersAggregate;
  /** fetch data from the table: "session_statuses" */
  session_statuses: Array<SessionStatuses>;
  /** fetch aggregated fields from the table: "session_statuses" */
  session_statuses_aggregate: SessionStatusesAggregate;
  /** fetch data from the table: "session_statuses" using primary key columns */
  session_statuses_by_pk?: Maybe<SessionStatuses>;
  /** An array relationship */
  sessions: Array<Sessions>;
  /** An aggregate relationship */
  sessions_aggregate: SessionsAggregate;
  /** fetch data from the table: "sessions" using primary key columns */
  sessions_by_pk?: Maybe<Sessions>;
  /** An array relationship */
  slots: Array<Slots>;
  /** An aggregate relationship */
  slots_aggregate: SlotsAggregate;
  /** fetch data from the table: "slots" using primary key columns */
  slots_by_pk?: Maybe<Slots>;
  /** fetch data from the table: "stats" */
  stats: Array<Stats>;
  /** fetch aggregated fields from the table: "stats" */
  stats_aggregate: StatsAggregate;
  /** fetch data from the table: "stats" using primary key columns */
  stats_by_pk?: Maybe<Stats>;
  /** fetch data from the table: "student_class_sessions" */
  student_class_sessions: Array<StudentClassSessions>;
  /** fetch aggregated fields from the table: "student_class_sessions" */
  student_class_sessions_aggregate: StudentClassSessionsAggregate;
  /** fetch data from the table: "student_class_sessions" using primary key columns */
  student_class_sessions_by_pk?: Maybe<StudentClassSessions>;
  /** fetch data from the table: "student_classes" */
  student_classes: Array<StudentClasses>;
  /** fetch aggregated fields from the table: "student_classes" */
  student_classes_aggregate: StudentClassesAggregate;
  /** fetch data from the table: "student_classes" using primary key columns */
  student_classes_by_pk?: Maybe<StudentClasses>;
  /** fetch data from the table: "student_favorite_teachers" */
  student_favorite_teachers: Array<StudentFavoriteTeachers>;
  /** fetch aggregated fields from the table: "student_favorite_teachers" */
  student_favorite_teachers_aggregate: StudentFavoriteTeachersAggregate;
  /** fetch data from the table: "student_favorite_teachers" using primary key columns */
  student_favorite_teachers_by_pk?: Maybe<StudentFavoriteTeachers>;
  /** fetch data from the table: "student_live_class_activities" */
  student_live_class_activities: Array<StudentLiveClassActivities>;
  /** fetch aggregated fields from the table: "student_live_class_activities" */
  student_live_class_activities_aggregate: StudentLiveClassActivitiesAggregate;
  /** fetch data from the table: "student_live_class_activities" using primary key columns */
  student_live_class_activities_by_pk?: Maybe<StudentLiveClassActivities>;
  /** fetch data from the table: "subjects" */
  subjects: Array<Subjects>;
  /** fetch aggregated fields from the table: "subjects" */
  subjects_aggregate: SubjectsAggregate;
  /** fetch data from the table: "subjects" using primary key columns */
  subjects_by_pk?: Maybe<Subjects>;
  /** fetch data from the table: "subscriptions" */
  subscriptions: Array<Subscriptions>;
  /** fetch aggregated fields from the table: "subscriptions" */
  subscriptions_aggregate: SubscriptionsAggregate;
  /** fetch data from the table: "subscriptions" using primary key columns */
  subscriptions_by_pk?: Maybe<Subscriptions>;
  /** fetch data from the table: "synonyms" */
  synonyms: Array<Synonyms>;
  /** fetch aggregated fields from the table: "synonyms" */
  synonyms_aggregate: SynonymsAggregate;
  /** fetch data from the table: "synonyms" using primary key columns */
  synonyms_by_pk?: Maybe<Synonyms>;
  /** fetch data from the table: "teacher_credentials" */
  teacher_credentials: Array<TeacherCredentials>;
  /** fetch aggregated fields from the table: "teacher_credentials" */
  teacher_credentials_aggregate: TeacherCredentialsAggregate;
  /** fetch data from the table: "teacher_credentials" using primary key columns */
  teacher_credentials_by_pk?: Maybe<TeacherCredentials>;
  /** fetch data from the table: "teacher_education" */
  teacher_education: Array<TeacherEducation>;
  /** fetch aggregated fields from the table: "teacher_education" */
  teacher_education_aggregate: TeacherEducationAggregate;
  /** fetch data from the table: "teacher_education" using primary key columns */
  teacher_education_by_pk?: Maybe<TeacherEducation>;
  /** fetch data from the table: "teacher_interests" */
  teacher_interests: Array<TeacherInterests>;
  /** fetch aggregated fields from the table: "teacher_interests" */
  teacher_interests_aggregate: TeacherInterestsAggregate;
  /** fetch data from the table: "teacher_interests" using primary key columns */
  teacher_interests_by_pk?: Maybe<TeacherInterests>;
  /** fetch data from the table: "teacher_languages" */
  teacher_languages: Array<TeacherLanguages>;
  /** fetch aggregated fields from the table: "teacher_languages" */
  teacher_languages_aggregate: TeacherLanguagesAggregate;
  /** fetch data from the table: "teacher_languages" using primary key columns */
  teacher_languages_by_pk?: Maybe<TeacherLanguages>;
  /** fetch data from the table: "teacher_subjects" */
  teacher_subjects: Array<TeacherSubjects>;
  /** fetch aggregated fields from the table: "teacher_subjects" */
  teacher_subjects_aggregate: TeacherSubjectsAggregate;
  /** fetch data from the table: "teacher_subjects" using primary key columns */
  teacher_subjects_by_pk?: Maybe<TeacherSubjects>;
  /** fetch data from the table: "teachers" */
  teachers: Array<Teachers>;
  /** fetch aggregated fields from the table: "teachers" */
  teachers_aggregate: TeachersAggregate;
  /** fetch data from the table: "teachers" using primary key columns */
  teachers_by_pk?: Maybe<Teachers>;
  /** fetch data from the table: "user_courses" */
  user_courses: Array<UserCourses>;
  /** fetch aggregated fields from the table: "user_courses" */
  user_courses_aggregate: UserCoursesAggregate;
  /** fetch data from the table: "user_courses" using primary key columns */
  user_courses_by_pk?: Maybe<UserCourses>;
  /** fetch data from the table: "user_devices" */
  user_devices: Array<UserDevices>;
  /** fetch aggregated fields from the table: "user_devices" */
  user_devices_aggregate: UserDevicesAggregate;
  /** fetch data from the table: "user_devices" using primary key columns */
  user_devices_by_pk?: Maybe<UserDevices>;
  /** fetch data from the table: "user_dictionaries" */
  user_dictionaries: Array<UserDictionaries>;
  /** fetch aggregated fields from the table: "user_dictionaries" */
  user_dictionaries_aggregate: UserDictionariesAggregate;
  /** fetch data from the table: "user_dictionaries" using primary key columns */
  user_dictionaries_by_pk?: Maybe<UserDictionaries>;
  /** fetch data from the table: "user_messages" */
  user_messages: Array<UserMessages>;
  /** fetch aggregated fields from the table: "user_messages" */
  user_messages_aggregate: UserMessagesAggregate;
  /** fetch data from the table: "user_messages" using primary key columns */
  user_messages_by_pk?: Maybe<UserMessages>;
  /** fetch data from the table: "user_words" */
  user_words: Array<UserWords>;
  /** fetch aggregated fields from the table: "user_words" */
  user_words_aggregate: UserWordsAggregate;
  /** fetch data from the table: "user_words" using primary key columns */
  user_words_by_pk?: Maybe<UserWords>;
  /** fetch data from the table: "user_words_count" */
  user_words_count: Array<UserWordsCount>;
  /** fetch aggregated fields from the table: "user_words_count" */
  user_words_count_aggregate: UserWordsCountAggregate;
  /** fetch data from the table: "user_words_count" using primary key columns */
  user_words_count_by_pk?: Maybe<UserWordsCount>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: UsersAggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table: "vocabulary_sets" */
  vocabulary_sets: Array<VocabularySets>;
  /** fetch aggregated fields from the table: "vocabulary_sets" */
  vocabulary_sets_aggregate: VocabularySetsAggregate;
  /** fetch data from the table: "vocabulary_sets" using primary key columns */
  vocabulary_sets_by_pk?: Maybe<VocabularySets>;
  /** fetch data from the table: "vocabulary_words" */
  vocabulary_words: Array<VocabularyWords>;
  /** fetch aggregated fields from the table: "vocabulary_words" */
  vocabulary_words_aggregate: VocabularyWordsAggregate;
  /** fetch data from the table: "vocabulary_words" using primary key columns */
  vocabulary_words_by_pk?: Maybe<VocabularyWords>;
  /** fetch data from the table: "wordnet.english_words" */
  wordnet_english_words: Array<WordnetEnglishWords>;
  /** fetch aggregated fields from the table: "wordnet.english_words" */
  wordnet_english_words_aggregate: WordnetEnglishWordsAggregate;
  /** fetch data from the table: "wordnet.english_words" using primary key columns */
  wordnet_english_words_by_pk?: Maybe<WordnetEnglishWords>;
  /** execute function "wordnet.search_wordnet_english" which returns "wordnet.english_words" */
  wordnet_search_wordnet_english: Array<WordnetEnglishWords>;
  /** execute function "wordnet.search_wordnet_english" and query aggregates on result of table type "wordnet.english_words" */
  wordnet_search_wordnet_english_aggregate: WordnetEnglishWordsAggregate;
  /** fetch data from the table: "wordnet.synsets" */
  wordnet_synsets: Array<WordnetSynsets>;
  /** fetch aggregated fields from the table: "wordnet.synsets" */
  wordnet_synsets_aggregate: WordnetSynsetsAggregate;
  /** fetch data from the table: "wordnet.synsets" using primary key columns */
  wordnet_synsets_by_pk?: Maybe<WordnetSynsets>;
};


export type QueryRootActivitySetAssignmentsArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetAssignmentsOrderBy>>;
  where?: InputMaybe<ActivitySetAssignmentsBoolExp>;
};


export type QueryRootActivitySetAssignmentsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetAssignmentsOrderBy>>;
  where?: InputMaybe<ActivitySetAssignmentsBoolExp>;
};


export type QueryRootActivitySetAssignmentsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootActivitySetReportsArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetReportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetReportsOrderBy>>;
  where?: InputMaybe<ActivitySetReportsBoolExp>;
};


export type QueryRootActivitySetReportsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetReportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetReportsOrderBy>>;
  where?: InputMaybe<ActivitySetReportsBoolExp>;
};


export type QueryRootActivitySetReportsByPkArgs = {
  activitySetId: Scalars['Int']['input'];
  createdBy: Scalars['Int']['input'];
};


export type QueryRootActivitySetResponsesArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetResponsesOrderBy>>;
  where?: InputMaybe<ActivitySetResponsesBoolExp>;
};


export type QueryRootActivitySetResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetResponsesOrderBy>>;
  where?: InputMaybe<ActivitySetResponsesBoolExp>;
};


export type QueryRootActivitySetResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootActivitySetsArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetsOrderBy>>;
  where?: InputMaybe<ActivitySetsBoolExp>;
};


export type QueryRootActivitySetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetsOrderBy>>;
  where?: InputMaybe<ActivitySetsBoolExp>;
};


export type QueryRootActivitySetsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootAddressesArgs = {
  distinct_on?: InputMaybe<Array<AddressesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AddressesOrderBy>>;
  where?: InputMaybe<AddressesBoolExp>;
};


export type QueryRootAddressesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AddressesOrderBy>>;
  where?: InputMaybe<AddressesBoolExp>;
};


export type QueryRootAddressesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootAnagramResponsesArgs = {
  distinct_on?: InputMaybe<Array<AnagramResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramResponsesOrderBy>>;
  where?: InputMaybe<AnagramResponsesBoolExp>;
};


export type QueryRootAnagramResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnagramResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramResponsesOrderBy>>;
  where?: InputMaybe<AnagramResponsesBoolExp>;
};


export type QueryRootAnagramResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootAnagramsArgs = {
  distinct_on?: InputMaybe<Array<AnagramsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramsOrderBy>>;
  where?: InputMaybe<AnagramsBoolExp>;
};


export type QueryRootAnagramsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnagramsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramsOrderBy>>;
  where?: InputMaybe<AnagramsBoolExp>;
};


export type QueryRootAnagramsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootAnnotationsArgs = {
  distinct_on?: InputMaybe<Array<AnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnnotationsOrderBy>>;
  where?: InputMaybe<AnnotationsBoolExp>;
};


export type QueryRootAnnotationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnnotationsOrderBy>>;
  where?: InputMaybe<AnnotationsBoolExp>;
};


export type QueryRootAnnotationsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootApplicationReviewsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationReviewsOrderBy>>;
  where?: InputMaybe<ApplicationReviewsBoolExp>;
};


export type QueryRootApplicationReviewsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationReviewsOrderBy>>;
  where?: InputMaybe<ApplicationReviewsBoolExp>;
};


export type QueryRootApplicationReviewsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootAvailabilityTimesArgs = {
  distinct_on?: InputMaybe<Array<AvailabilityTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AvailabilityTimesOrderBy>>;
  where?: InputMaybe<AvailabilityTimesBoolExp>;
};


export type QueryRootAvailabilityTimesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AvailabilityTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AvailabilityTimesOrderBy>>;
  where?: InputMaybe<AvailabilityTimesBoolExp>;
};


export type QueryRootAvailabilityTimesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootCefrLevelsArgs = {
  distinct_on?: InputMaybe<Array<CefrLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CefrLevelsOrderBy>>;
  where?: InputMaybe<CefrLevelsBoolExp>;
};


export type QueryRootCefrLevelsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CefrLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CefrLevelsOrderBy>>;
  where?: InputMaybe<CefrLevelsBoolExp>;
};


export type QueryRootCefrLevelsByPkArgs = {
  value: Scalars['String']['input'];
};


export type QueryRootClassActivitySetsArgs = {
  distinct_on?: InputMaybe<Array<ClassActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassActivitySetsOrderBy>>;
  where?: InputMaybe<ClassActivitySetsBoolExp>;
};


export type QueryRootClassActivitySetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassActivitySetsOrderBy>>;
  where?: InputMaybe<ClassActivitySetsBoolExp>;
};


export type QueryRootClassActivitySetsByPkArgs = {
  activitySetId: Scalars['Int']['input'];
  classId: Scalars['Int']['input'];
};


export type QueryRootClassAnnotationsArgs = {
  distinct_on?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassAnnotationsOrderBy>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};


export type QueryRootClassAnnotationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassAnnotationsOrderBy>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};


export type QueryRootClassAnnotationsByPkArgs = {
  annotationId: Scalars['Int']['input'];
  classId: Scalars['Int']['input'];
};


export type QueryRootClassCoursesArgs = {
  distinct_on?: InputMaybe<Array<ClassCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassCoursesOrderBy>>;
  where?: InputMaybe<ClassCoursesBoolExp>;
};


export type QueryRootClassCoursesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassCoursesOrderBy>>;
  where?: InputMaybe<ClassCoursesBoolExp>;
};


export type QueryRootClassCoursesByPkArgs = {
  classId: Scalars['Int']['input'];
  courseId: Scalars['Int']['input'];
};


export type QueryRootClassSessionsArgs = {
  distinct_on?: InputMaybe<Array<ClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSessionsOrderBy>>;
  where?: InputMaybe<ClassSessionsBoolExp>;
};


export type QueryRootClassSessionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSessionsOrderBy>>;
  where?: InputMaybe<ClassSessionsBoolExp>;
};


export type QueryRootClassSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootClassSlotBookingsArgs = {
  distinct_on?: InputMaybe<Array<ClassSlotBookingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSlotBookingsOrderBy>>;
  where?: InputMaybe<ClassSlotBookingsBoolExp>;
};


export type QueryRootClassSlotBookingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassSlotBookingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSlotBookingsOrderBy>>;
  where?: InputMaybe<ClassSlotBookingsBoolExp>;
};


export type QueryRootClassSlotBookingsByPkArgs = {
  slotId: Scalars['Int']['input'];
  studentId: Scalars['Int']['input'];
};


export type QueryRootClassesArgs = {
  distinct_on?: InputMaybe<Array<ClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassesOrderBy>>;
  where?: InputMaybe<ClassesBoolExp>;
};


export type QueryRootClassesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassesOrderBy>>;
  where?: InputMaybe<ClassesBoolExp>;
};


export type QueryRootClassesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootCourseActivitiesArgs = {
  distinct_on?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseActivitiesOrderBy>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


export type QueryRootCourseActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseActivitiesOrderBy>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


export type QueryRootCourseActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootCourseReviewsArgs = {
  distinct_on?: InputMaybe<Array<CourseReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseReviewsOrderBy>>;
  where?: InputMaybe<CourseReviewsBoolExp>;
};


export type QueryRootCourseReviewsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseReviewsOrderBy>>;
  where?: InputMaybe<CourseReviewsBoolExp>;
};


export type QueryRootCourseReviewsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootCourseSummaryArgs = {
  distinct_on?: InputMaybe<Array<CourseSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseSummaryOrderBy>>;
  where?: InputMaybe<CourseSummaryBoolExp>;
};


export type QueryRootCourseSummaryAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseSummaryOrderBy>>;
  where?: InputMaybe<CourseSummaryBoolExp>;
};


export type QueryRootCoursesArgs = {
  distinct_on?: InputMaybe<Array<CoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CoursesOrderBy>>;
  where?: InputMaybe<CoursesBoolExp>;
};


export type QueryRootCoursesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CoursesOrderBy>>;
  where?: InputMaybe<CoursesBoolExp>;
};


export type QueryRootCoursesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootDailyStatsArgs = {
  distinct_on?: InputMaybe<Array<DailyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DailyStatsOrderBy>>;
  where?: InputMaybe<DailyStatsBoolExp>;
};


export type QueryRootDailyStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<DailyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DailyStatsOrderBy>>;
  where?: InputMaybe<DailyStatsBoolExp>;
};


export type QueryRootDailyStatsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootDictionariesArgs = {
  distinct_on?: InputMaybe<Array<DictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DictionariesOrderBy>>;
  where?: InputMaybe<DictionariesBoolExp>;
};


export type QueryRootDictionariesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DictionariesOrderBy>>;
  where?: InputMaybe<DictionariesBoolExp>;
};


export type QueryRootDictionariesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootEmojisArgs = {
  distinct_on?: InputMaybe<Array<EmojisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EmojisOrderBy>>;
  where?: InputMaybe<EmojisBoolExp>;
};


export type QueryRootEmojisAggregateArgs = {
  distinct_on?: InputMaybe<Array<EmojisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EmojisOrderBy>>;
  where?: InputMaybe<EmojisBoolExp>;
};


export type QueryRootEmojisByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootEmployeesArgs = {
  distinct_on?: InputMaybe<Array<EmployeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EmployeesOrderBy>>;
  where?: InputMaybe<EmployeesBoolExp>;
};


export type QueryRootEmployeesAggregateArgs = {
  distinct_on?: InputMaybe<Array<EmployeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EmployeesOrderBy>>;
  where?: InputMaybe<EmployeesBoolExp>;
};


export type QueryRootEmployeesByPkArgs = {
  userId: Scalars['Int']['input'];
};


export type QueryRootExampleJoinsArgs = {
  distinct_on?: InputMaybe<Array<ExampleJoinsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExampleJoinsOrderBy>>;
  where?: InputMaybe<ExampleJoinsBoolExp>;
};


export type QueryRootExampleJoinsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ExampleJoinsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExampleJoinsOrderBy>>;
  where?: InputMaybe<ExampleJoinsBoolExp>;
};


export type QueryRootExampleJoinsByPkArgs = {
  from_id: Scalars['Int']['input'];
  to_id: Scalars['Int']['input'];
};


export type QueryRootExamplesArgs = {
  distinct_on?: InputMaybe<Array<ExamplesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExamplesOrderBy>>;
  where?: InputMaybe<ExamplesBoolExp>;
};


export type QueryRootExamplesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ExamplesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExamplesOrderBy>>;
  where?: InputMaybe<ExamplesBoolExp>;
};


export type QueryRootExamplesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootExpiredRefreshTokensArgs = {
  distinct_on?: InputMaybe<Array<ExpiredRefreshTokensSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExpiredRefreshTokensOrderBy>>;
  where?: InputMaybe<ExpiredRefreshTokensBoolExp>;
};


export type QueryRootExpiredRefreshTokensAggregateArgs = {
  distinct_on?: InputMaybe<Array<ExpiredRefreshTokensSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExpiredRefreshTokensOrderBy>>;
  where?: InputMaybe<ExpiredRefreshTokensBoolExp>;
};


export type QueryRootExpiredRefreshTokensByPkArgs = {
  token: Scalars['String']['input'];
};


export type QueryRootFillInTheBlankOptionsArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankOptionsOrderBy>>;
  where?: InputMaybe<FillInTheBlankOptionsBoolExp>;
};


export type QueryRootFillInTheBlankOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankOptionsOrderBy>>;
  where?: InputMaybe<FillInTheBlankOptionsBoolExp>;
};


export type QueryRootFillInTheBlankOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootFillInTheBlankResponsesArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankResponsesOrderBy>>;
  where?: InputMaybe<FillInTheBlankResponsesBoolExp>;
};


export type QueryRootFillInTheBlankResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankResponsesOrderBy>>;
  where?: InputMaybe<FillInTheBlankResponsesBoolExp>;
};


export type QueryRootFillInTheBlankResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootFillInTheBlanksArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlanksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlanksOrderBy>>;
  where?: InputMaybe<FillInTheBlanksBoolExp>;
};


export type QueryRootFillInTheBlanksAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlanksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlanksOrderBy>>;
  where?: InputMaybe<FillInTheBlanksBoolExp>;
};


export type QueryRootFillInTheBlanksByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootGameDailiesArgs = {
  distinct_on?: InputMaybe<Array<GameDailiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameDailiesOrderBy>>;
  where?: InputMaybe<GameDailiesBoolExp>;
};


export type QueryRootGameDailiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameDailiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameDailiesOrderBy>>;
  where?: InputMaybe<GameDailiesBoolExp>;
};


export type QueryRootGameDailiesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootGameDifficultyArgs = {
  distinct_on?: InputMaybe<Array<GameDifficultySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameDifficultyOrderBy>>;
  where?: InputMaybe<GameDifficultyBoolExp>;
};


export type QueryRootGameDifficultyAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameDifficultySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameDifficultyOrderBy>>;
  where?: InputMaybe<GameDifficultyBoolExp>;
};


export type QueryRootGameDifficultyByPkArgs = {
  value: Scalars['String']['input'];
};


export type QueryRootGameTypesArgs = {
  distinct_on?: InputMaybe<Array<GameTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameTypesOrderBy>>;
  where?: InputMaybe<GameTypesBoolExp>;
};


export type QueryRootGameTypesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameTypesOrderBy>>;
  where?: InputMaybe<GameTypesBoolExp>;
};


export type QueryRootGameTypesByPkArgs = {
  value: Scalars['String']['input'];
};


export type QueryRootGameUsersArgs = {
  distinct_on?: InputMaybe<Array<GameUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameUsersOrderBy>>;
  where?: InputMaybe<GameUsersBoolExp>;
};


export type QueryRootGameUsersAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameUsersOrderBy>>;
  where?: InputMaybe<GameUsersBoolExp>;
};


export type QueryRootGameUsersByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootGamesArgs = {
  distinct_on?: InputMaybe<Array<GamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GamesOrderBy>>;
  where?: InputMaybe<GamesBoolExp>;
};


export type QueryRootGamesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GamesOrderBy>>;
  where?: InputMaybe<GamesBoolExp>;
};


export type QueryRootGamesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootGetRandomPoemArgs = {
  args?: InputMaybe<GetRandomPoemArgs>;
  distinct_on?: InputMaybe<Array<PoemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemsOrderBy>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type QueryRootGetRandomPoemAggregateArgs = {
  args?: InputMaybe<GetRandomPoemArgs>;
  distinct_on?: InputMaybe<Array<PoemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemsOrderBy>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type QueryRootGetUserWordsCountArgs = {
  args: GetUserWordsCountArgs;
  distinct_on?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsCountOrderBy>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type QueryRootGetUserWordsCountAggregateArgs = {
  args: GetUserWordsCountArgs;
  distinct_on?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsCountOrderBy>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type QueryRootGoalsArgs = {
  distinct_on?: InputMaybe<Array<GoalsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GoalsOrderBy>>;
  where?: InputMaybe<GoalsBoolExp>;
};


export type QueryRootGoalsAggregateArgs = {
  distinct_on?: InputMaybe<Array<GoalsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GoalsOrderBy>>;
  where?: InputMaybe<GoalsBoolExp>;
};


export type QueryRootGoalsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootImagesArgs = {
  distinct_on?: InputMaybe<Array<ImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ImagesOrderBy>>;
  where?: InputMaybe<ImagesBoolExp>;
};


export type QueryRootImagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ImagesOrderBy>>;
  where?: InputMaybe<ImagesBoolExp>;
};


export type QueryRootImagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootInterestsArgs = {
  distinct_on?: InputMaybe<Array<InterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterestsOrderBy>>;
  where?: InputMaybe<InterestsBoolExp>;
};


export type QueryRootInterestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<InterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterestsOrderBy>>;
  where?: InputMaybe<InterestsBoolExp>;
};


export type QueryRootInterestsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootLanguagesArgs = {
  distinct_on?: InputMaybe<Array<LanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LanguagesOrderBy>>;
  where?: InputMaybe<LanguagesBoolExp>;
};


export type QueryRootLanguagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<LanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LanguagesOrderBy>>;
  where?: InputMaybe<LanguagesBoolExp>;
};


export type QueryRootLanguagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootListeningsArgs = {
  distinct_on?: InputMaybe<Array<ListeningsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ListeningsOrderBy>>;
  where?: InputMaybe<ListeningsBoolExp>;
};


export type QueryRootListeningsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ListeningsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ListeningsOrderBy>>;
  where?: InputMaybe<ListeningsBoolExp>;
};


export type QueryRootListeningsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootLiveClassActivitiesArgs = {
  distinct_on?: InputMaybe<Array<LiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveClassActivitiesOrderBy>>;
  where?: InputMaybe<LiveClassActivitiesBoolExp>;
};


export type QueryRootLiveClassActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<LiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveClassActivitiesOrderBy>>;
  where?: InputMaybe<LiveClassActivitiesBoolExp>;
};


export type QueryRootLiveClassActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootLiveMessagesArgs = {
  distinct_on?: InputMaybe<Array<LiveMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveMessagesOrderBy>>;
  where?: InputMaybe<LiveMessagesBoolExp>;
};


export type QueryRootLiveMessagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<LiveMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveMessagesOrderBy>>;
  where?: InputMaybe<LiveMessagesBoolExp>;
};


export type QueryRootLiveMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootMatchingOptionsArgs = {
  distinct_on?: InputMaybe<Array<MatchingOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingOptionsOrderBy>>;
  where?: InputMaybe<MatchingOptionsBoolExp>;
};


export type QueryRootMatchingOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingOptionsOrderBy>>;
  where?: InputMaybe<MatchingOptionsBoolExp>;
};


export type QueryRootMatchingOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootMatchingResponsesArgs = {
  distinct_on?: InputMaybe<Array<MatchingResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingResponsesOrderBy>>;
  where?: InputMaybe<MatchingResponsesBoolExp>;
};


export type QueryRootMatchingResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingResponsesOrderBy>>;
  where?: InputMaybe<MatchingResponsesBoolExp>;
};


export type QueryRootMatchingResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootMatchingsArgs = {
  distinct_on?: InputMaybe<Array<MatchingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingsOrderBy>>;
  where?: InputMaybe<MatchingsBoolExp>;
};


export type QueryRootMatchingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingsOrderBy>>;
  where?: InputMaybe<MatchingsBoolExp>;
};


export type QueryRootMatchingsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootMessagesArgs = {
  distinct_on?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type QueryRootMessagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type QueryRootMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootMultipleChoiceOptionsArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceOptionsOrderBy>>;
  where?: InputMaybe<MultipleChoiceOptionsBoolExp>;
};


export type QueryRootMultipleChoiceOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceOptionsOrderBy>>;
  where?: InputMaybe<MultipleChoiceOptionsBoolExp>;
};


export type QueryRootMultipleChoiceOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootMultipleChoiceResponsesArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceResponsesOrderBy>>;
  where?: InputMaybe<MultipleChoiceResponsesBoolExp>;
};


export type QueryRootMultipleChoiceResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceResponsesOrderBy>>;
  where?: InputMaybe<MultipleChoiceResponsesBoolExp>;
};


export type QueryRootMultipleChoiceResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootMultipleChoicesArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoicesOrderBy>>;
  where?: InputMaybe<MultipleChoicesBoolExp>;
};


export type QueryRootMultipleChoicesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoicesOrderBy>>;
  where?: InputMaybe<MultipleChoicesBoolExp>;
};


export type QueryRootMultipleChoicesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootOpenAnswerResponsesArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswerResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswerResponsesOrderBy>>;
  where?: InputMaybe<OpenAnswerResponsesBoolExp>;
};


export type QueryRootOpenAnswerResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswerResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswerResponsesOrderBy>>;
  where?: InputMaybe<OpenAnswerResponsesBoolExp>;
};


export type QueryRootOpenAnswerResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootOpenAnswersArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswersOrderBy>>;
  where?: InputMaybe<OpenAnswersBoolExp>;
};


export type QueryRootOpenAnswersAggregateArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswersOrderBy>>;
  where?: InputMaybe<OpenAnswersBoolExp>;
};


export type QueryRootOpenAnswersByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootPartsOfSpeechArgs = {
  distinct_on?: InputMaybe<Array<PartsOfSpeechSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PartsOfSpeechOrderBy>>;
  where?: InputMaybe<PartsOfSpeechBoolExp>;
};


export type QueryRootPartsOfSpeechAggregateArgs = {
  distinct_on?: InputMaybe<Array<PartsOfSpeechSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PartsOfSpeechOrderBy>>;
  where?: InputMaybe<PartsOfSpeechBoolExp>;
};


export type QueryRootPartsOfSpeechByPkArgs = {
  value: Scalars['String']['input'];
};


export type QueryRootPaymentsArgs = {
  distinct_on?: InputMaybe<Array<PaymentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PaymentsOrderBy>>;
  where?: InputMaybe<PaymentsBoolExp>;
};


export type QueryRootPaymentsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PaymentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PaymentsOrderBy>>;
  where?: InputMaybe<PaymentsBoolExp>;
};


export type QueryRootPaymentsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootPhraseResponsesArgs = {
  distinct_on?: InputMaybe<Array<PhraseResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhraseResponsesOrderBy>>;
  where?: InputMaybe<PhraseResponsesBoolExp>;
};


export type QueryRootPhraseResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PhraseResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhraseResponsesOrderBy>>;
  where?: InputMaybe<PhraseResponsesBoolExp>;
};


export type QueryRootPhraseResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootPhrasesArgs = {
  distinct_on?: InputMaybe<Array<PhrasesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhrasesOrderBy>>;
  where?: InputMaybe<PhrasesBoolExp>;
};


export type QueryRootPhrasesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PhrasesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhrasesOrderBy>>;
  where?: InputMaybe<PhrasesBoolExp>;
};


export type QueryRootPhrasesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootPoemLinesArgs = {
  distinct_on?: InputMaybe<Array<PoemLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemLinesOrderBy>>;
  where?: InputMaybe<PoemLinesBoolExp>;
};


export type QueryRootPoemLinesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PoemLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemLinesOrderBy>>;
  where?: InputMaybe<PoemLinesBoolExp>;
};


export type QueryRootPoemLinesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootPoemsArgs = {
  distinct_on?: InputMaybe<Array<PoemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemsOrderBy>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type QueryRootPoemsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PoemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemsOrderBy>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type QueryRootPoemsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootPrepositionsArgs = {
  distinct_on?: InputMaybe<Array<PrepositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PrepositionsOrderBy>>;
  where?: InputMaybe<PrepositionsBoolExp>;
};


export type QueryRootPrepositionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PrepositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PrepositionsOrderBy>>;
  where?: InputMaybe<PrepositionsBoolExp>;
};


export type QueryRootPrepositionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootReadingsArgs = {
  distinct_on?: InputMaybe<Array<ReadingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ReadingsOrderBy>>;
  where?: InputMaybe<ReadingsBoolExp>;
};


export type QueryRootReadingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ReadingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ReadingsOrderBy>>;
  where?: InputMaybe<ReadingsBoolExp>;
};


export type QueryRootReadingsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootSearchUsersArgs = {
  args: SearchUsersArgs;
  distinct_on?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type QueryRootSearchUsersAggregateArgs = {
  args: SearchUsersArgs;
  distinct_on?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type QueryRootSessionStatusesArgs = {
  distinct_on?: InputMaybe<Array<SessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionStatusesOrderBy>>;
  where?: InputMaybe<SessionStatusesBoolExp>;
};


export type QueryRootSessionStatusesAggregateArgs = {
  distinct_on?: InputMaybe<Array<SessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionStatusesOrderBy>>;
  where?: InputMaybe<SessionStatusesBoolExp>;
};


export type QueryRootSessionStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


export type QueryRootSessionsArgs = {
  distinct_on?: InputMaybe<Array<SessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionsOrderBy>>;
  where?: InputMaybe<SessionsBoolExp>;
};


export type QueryRootSessionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionsOrderBy>>;
  where?: InputMaybe<SessionsBoolExp>;
};


export type QueryRootSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootSlotsArgs = {
  distinct_on?: InputMaybe<Array<SlotsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SlotsOrderBy>>;
  where?: InputMaybe<SlotsBoolExp>;
};


export type QueryRootSlotsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SlotsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SlotsOrderBy>>;
  where?: InputMaybe<SlotsBoolExp>;
};


export type QueryRootSlotsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootStatsArgs = {
  distinct_on?: InputMaybe<Array<StatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StatsOrderBy>>;
  where?: InputMaybe<StatsBoolExp>;
};


export type QueryRootStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StatsOrderBy>>;
  where?: InputMaybe<StatsBoolExp>;
};


export type QueryRootStatsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootStudentClassSessionsArgs = {
  distinct_on?: InputMaybe<Array<StudentClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassSessionsOrderBy>>;
  where?: InputMaybe<StudentClassSessionsBoolExp>;
};


export type QueryRootStudentClassSessionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassSessionsOrderBy>>;
  where?: InputMaybe<StudentClassSessionsBoolExp>;
};


export type QueryRootStudentClassSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootStudentClassesArgs = {
  distinct_on?: InputMaybe<Array<StudentClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassesOrderBy>>;
  where?: InputMaybe<StudentClassesBoolExp>;
};


export type QueryRootStudentClassesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassesOrderBy>>;
  where?: InputMaybe<StudentClassesBoolExp>;
};


export type QueryRootStudentClassesByPkArgs = {
  classId: Scalars['Int']['input'];
  studentId: Scalars['Int']['input'];
};


export type QueryRootStudentFavoriteTeachersArgs = {
  distinct_on?: InputMaybe<Array<StudentFavoriteTeachersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentFavoriteTeachersOrderBy>>;
  where?: InputMaybe<StudentFavoriteTeachersBoolExp>;
};


export type QueryRootStudentFavoriteTeachersAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentFavoriteTeachersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentFavoriteTeachersOrderBy>>;
  where?: InputMaybe<StudentFavoriteTeachersBoolExp>;
};


export type QueryRootStudentFavoriteTeachersByPkArgs = {
  studentId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


export type QueryRootStudentLiveClassActivitiesArgs = {
  distinct_on?: InputMaybe<Array<StudentLiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentLiveClassActivitiesOrderBy>>;
  where?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
};


export type QueryRootStudentLiveClassActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentLiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentLiveClassActivitiesOrderBy>>;
  where?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
};


export type QueryRootStudentLiveClassActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootSubjectsArgs = {
  distinct_on?: InputMaybe<Array<SubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SubjectsOrderBy>>;
  where?: InputMaybe<SubjectsBoolExp>;
};


export type QueryRootSubjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SubjectsOrderBy>>;
  where?: InputMaybe<SubjectsBoolExp>;
};


export type QueryRootSubjectsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootSubscriptionsArgs = {
  distinct_on?: InputMaybe<Array<SubscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SubscriptionsOrderBy>>;
  where?: InputMaybe<SubscriptionsBoolExp>;
};


export type QueryRootSubscriptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SubscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SubscriptionsOrderBy>>;
  where?: InputMaybe<SubscriptionsBoolExp>;
};


export type QueryRootSubscriptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootSynonymsArgs = {
  distinct_on?: InputMaybe<Array<SynonymsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SynonymsOrderBy>>;
  where?: InputMaybe<SynonymsBoolExp>;
};


export type QueryRootSynonymsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SynonymsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SynonymsOrderBy>>;
  where?: InputMaybe<SynonymsBoolExp>;
};


export type QueryRootSynonymsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootTeacherCredentialsArgs = {
  distinct_on?: InputMaybe<Array<TeacherCredentialsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherCredentialsOrderBy>>;
  where?: InputMaybe<TeacherCredentialsBoolExp>;
};


export type QueryRootTeacherCredentialsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherCredentialsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherCredentialsOrderBy>>;
  where?: InputMaybe<TeacherCredentialsBoolExp>;
};


export type QueryRootTeacherCredentialsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootTeacherEducationArgs = {
  distinct_on?: InputMaybe<Array<TeacherEducationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherEducationOrderBy>>;
  where?: InputMaybe<TeacherEducationBoolExp>;
};


export type QueryRootTeacherEducationAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherEducationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherEducationOrderBy>>;
  where?: InputMaybe<TeacherEducationBoolExp>;
};


export type QueryRootTeacherEducationByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootTeacherInterestsArgs = {
  distinct_on?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherInterestsOrderBy>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};


export type QueryRootTeacherInterestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherInterestsOrderBy>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};


export type QueryRootTeacherInterestsByPkArgs = {
  interestId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


export type QueryRootTeacherLanguagesArgs = {
  distinct_on?: InputMaybe<Array<TeacherLanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherLanguagesOrderBy>>;
  where?: InputMaybe<TeacherLanguagesBoolExp>;
};


export type QueryRootTeacherLanguagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherLanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherLanguagesOrderBy>>;
  where?: InputMaybe<TeacherLanguagesBoolExp>;
};


export type QueryRootTeacherLanguagesByPkArgs = {
  languageId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


export type QueryRootTeacherSubjectsArgs = {
  distinct_on?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherSubjectsOrderBy>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};


export type QueryRootTeacherSubjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherSubjectsOrderBy>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};


export type QueryRootTeacherSubjectsByPkArgs = {
  subjectId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


export type QueryRootTeachersArgs = {
  distinct_on?: InputMaybe<Array<TeachersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeachersOrderBy>>;
  where?: InputMaybe<TeachersBoolExp>;
};


export type QueryRootTeachersAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeachersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeachersOrderBy>>;
  where?: InputMaybe<TeachersBoolExp>;
};


export type QueryRootTeachersByPkArgs = {
  userId: Scalars['Int']['input'];
};


export type QueryRootUserCoursesArgs = {
  distinct_on?: InputMaybe<Array<UserCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserCoursesOrderBy>>;
  where?: InputMaybe<UserCoursesBoolExp>;
};


export type QueryRootUserCoursesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserCoursesOrderBy>>;
  where?: InputMaybe<UserCoursesBoolExp>;
};


export type QueryRootUserCoursesByPkArgs = {
  courseId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


export type QueryRootUserDevicesArgs = {
  distinct_on?: InputMaybe<Array<UserDevicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDevicesOrderBy>>;
  where?: InputMaybe<UserDevicesBoolExp>;
};


export type QueryRootUserDevicesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserDevicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDevicesOrderBy>>;
  where?: InputMaybe<UserDevicesBoolExp>;
};


export type QueryRootUserDevicesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootUserDictionariesArgs = {
  distinct_on?: InputMaybe<Array<UserDictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDictionariesOrderBy>>;
  where?: InputMaybe<UserDictionariesBoolExp>;
};


export type QueryRootUserDictionariesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserDictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDictionariesOrderBy>>;
  where?: InputMaybe<UserDictionariesBoolExp>;
};


export type QueryRootUserDictionariesByPkArgs = {
  dictionaryId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


export type QueryRootUserMessagesArgs = {
  distinct_on?: InputMaybe<Array<UserMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserMessagesOrderBy>>;
  where?: InputMaybe<UserMessagesBoolExp>;
};


export type QueryRootUserMessagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserMessagesOrderBy>>;
  where?: InputMaybe<UserMessagesBoolExp>;
};


export type QueryRootUserMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootUserWordsArgs = {
  distinct_on?: InputMaybe<Array<UserWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsOrderBy>>;
  where?: InputMaybe<UserWordsBoolExp>;
};


export type QueryRootUserWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsOrderBy>>;
  where?: InputMaybe<UserWordsBoolExp>;
};


export type QueryRootUserWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootUserWordsCountArgs = {
  distinct_on?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsCountOrderBy>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type QueryRootUserWordsCountAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsCountOrderBy>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type QueryRootUserWordsCountByPkArgs = {
  date: Scalars['date']['input'];
};


export type QueryRootUsersArgs = {
  distinct_on?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type QueryRootUsersAggregateArgs = {
  distinct_on?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type QueryRootUsersByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootVocabularySetsArgs = {
  distinct_on?: InputMaybe<Array<VocabularySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularySetsOrderBy>>;
  where?: InputMaybe<VocabularySetsBoolExp>;
};


export type QueryRootVocabularySetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<VocabularySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularySetsOrderBy>>;
  where?: InputMaybe<VocabularySetsBoolExp>;
};


export type QueryRootVocabularySetsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootVocabularyWordsArgs = {
  distinct_on?: InputMaybe<Array<VocabularyWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularyWordsOrderBy>>;
  where?: InputMaybe<VocabularyWordsBoolExp>;
};


export type QueryRootVocabularyWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<VocabularyWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularyWordsOrderBy>>;
  where?: InputMaybe<VocabularyWordsBoolExp>;
};


export type QueryRootVocabularyWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootWordnetEnglishWordsArgs = {
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type QueryRootWordnetEnglishWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type QueryRootWordnetEnglishWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type QueryRootWordnetSearchWordnetEnglishArgs = {
  args: WordnetSearchWordnetEnglishArgs;
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type QueryRootWordnetSearchWordnetEnglishAggregateArgs = {
  args: WordnetSearchWordnetEnglishArgs;
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type QueryRootWordnetSynsetsArgs = {
  distinct_on?: InputMaybe<Array<WordnetSynsetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetSynsetsOrderBy>>;
  where?: InputMaybe<WordnetSynsetsBoolExp>;
};


export type QueryRootWordnetSynsetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<WordnetSynsetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetSynsetsOrderBy>>;
  where?: InputMaybe<WordnetSynsetsBoolExp>;
};


export type QueryRootWordnetSynsetsByPkArgs = {
  id: Scalars['Int']['input'];
};

/** now used for writings too */
export type Readings = {
  __typename?: 'readings';
  contentKey?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  hasTranslation?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['Int']['output'];
  translationKey?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "readings" */
export type ReadingsAggregate = {
  __typename?: 'readings_aggregate';
  aggregate?: Maybe<ReadingsAggregateFields>;
  nodes: Array<Readings>;
};

/** aggregate fields of "readings" */
export type ReadingsAggregateFields = {
  __typename?: 'readings_aggregate_fields';
  avg?: Maybe<ReadingsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ReadingsMaxFields>;
  min?: Maybe<ReadingsMinFields>;
  stddev?: Maybe<ReadingsStddevFields>;
  stddev_pop?: Maybe<ReadingsStddevPopFields>;
  stddev_samp?: Maybe<ReadingsStddevSampFields>;
  sum?: Maybe<ReadingsSumFields>;
  var_pop?: Maybe<ReadingsVarPopFields>;
  var_samp?: Maybe<ReadingsVarSampFields>;
  variance?: Maybe<ReadingsVarianceFields>;
};


/** aggregate fields of "readings" */
export type ReadingsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ReadingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ReadingsAvgFields = {
  __typename?: 'readings_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "readings". All fields are combined with a logical 'AND'. */
export type ReadingsBoolExp = {
  _and?: InputMaybe<Array<ReadingsBoolExp>>;
  _not?: InputMaybe<ReadingsBoolExp>;
  _or?: InputMaybe<Array<ReadingsBoolExp>>;
  contentKey?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  hasTranslation?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  translationKey?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "readings" */
export enum ReadingsConstraint {
  /** unique or primary key constraint on columns "id" */
  ReadingsPkey = 'readings_pkey'
}

/** input type for incrementing numeric columns in table "readings" */
export type ReadingsIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "readings" */
export type ReadingsInsertInput = {
  contentKey?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  hasTranslation?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  translationKey?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ReadingsMaxFields = {
  __typename?: 'readings_max_fields';
  contentKey?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  translationKey?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type ReadingsMinFields = {
  __typename?: 'readings_min_fields';
  contentKey?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  translationKey?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "readings" */
export type ReadingsMutationResponse = {
  __typename?: 'readings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Readings>;
};

/** input type for inserting object relation for remote table "readings" */
export type ReadingsObjRelInsertInput = {
  data: ReadingsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ReadingsOnConflict>;
};

/** on_conflict condition type for table "readings" */
export type ReadingsOnConflict = {
  constraint: ReadingsConstraint;
  update_columns?: Array<ReadingsUpdateColumn>;
  where?: InputMaybe<ReadingsBoolExp>;
};

/** Ordering options when selecting data from "readings". */
export type ReadingsOrderBy = {
  contentKey?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  hasTranslation?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  translationKey?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: readings */
export type ReadingsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "readings" */
export enum ReadingsSelectColumn {
  /** column name */
  ContentKey = 'contentKey',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  HasTranslation = 'hasTranslation',
  /** column name */
  Id = 'id',
  /** column name */
  TranslationKey = 'translationKey',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "readings" */
export type ReadingsSetInput = {
  contentKey?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  hasTranslation?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  translationKey?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type ReadingsStddevFields = {
  __typename?: 'readings_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ReadingsStddevPopFields = {
  __typename?: 'readings_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ReadingsStddevSampFields = {
  __typename?: 'readings_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "readings" */
export type ReadingsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ReadingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ReadingsStreamCursorValueInput = {
  contentKey?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  hasTranslation?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  translationKey?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type ReadingsSumFields = {
  __typename?: 'readings_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "readings" */
export enum ReadingsUpdateColumn {
  /** column name */
  ContentKey = 'contentKey',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  HasTranslation = 'hasTranslation',
  /** column name */
  Id = 'id',
  /** column name */
  TranslationKey = 'translationKey',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ReadingsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ReadingsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ReadingsSetInput>;
  /** filter the rows which have to be updated */
  where: ReadingsBoolExp;
};

/** aggregate var_pop on columns */
export type ReadingsVarPopFields = {
  __typename?: 'readings_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ReadingsVarSampFields = {
  __typename?: 'readings_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ReadingsVarianceFields = {
  __typename?: 'readings_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

export type SearchUsersArgs = {
  search?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "session_statuses" */
export type SessionStatuses = {
  __typename?: 'session_statuses';
  value: Scalars['String']['output'];
};

/** aggregated selection of "session_statuses" */
export type SessionStatusesAggregate = {
  __typename?: 'session_statuses_aggregate';
  aggregate?: Maybe<SessionStatusesAggregateFields>;
  nodes: Array<SessionStatuses>;
};

/** aggregate fields of "session_statuses" */
export type SessionStatusesAggregateFields = {
  __typename?: 'session_statuses_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SessionStatusesMaxFields>;
  min?: Maybe<SessionStatusesMinFields>;
};


/** aggregate fields of "session_statuses" */
export type SessionStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SessionStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "session_statuses". All fields are combined with a logical 'AND'. */
export type SessionStatusesBoolExp = {
  _and?: InputMaybe<Array<SessionStatusesBoolExp>>;
  _not?: InputMaybe<SessionStatusesBoolExp>;
  _or?: InputMaybe<Array<SessionStatusesBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "session_statuses" */
export enum SessionStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  SessionStatusPkey = 'session_status_pkey'
}

export enum SessionStatusesEnum {
  Booked = 'BOOKED',
  Canceled = 'CANCELED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Started = 'STARTED',
  Waiting = 'WAITING'
}

/** Boolean expression to compare columns of type "session_statuses_enum". All fields are combined with logical 'AND'. */
export type SessionStatusesEnumComparisonExp = {
  _eq?: InputMaybe<SessionStatusesEnum>;
  _in?: InputMaybe<Array<SessionStatusesEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<SessionStatusesEnum>;
  _nin?: InputMaybe<Array<SessionStatusesEnum>>;
};

/** input type for inserting data into table "session_statuses" */
export type SessionStatusesInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type SessionStatusesMaxFields = {
  __typename?: 'session_statuses_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type SessionStatusesMinFields = {
  __typename?: 'session_statuses_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "session_statuses" */
export type SessionStatusesMutationResponse = {
  __typename?: 'session_statuses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SessionStatuses>;
};

/** on_conflict condition type for table "session_statuses" */
export type SessionStatusesOnConflict = {
  constraint: SessionStatusesConstraint;
  update_columns?: Array<SessionStatusesUpdateColumn>;
  where?: InputMaybe<SessionStatusesBoolExp>;
};

/** Ordering options when selecting data from "session_statuses". */
export type SessionStatusesOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: session_statuses */
export type SessionStatusesPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "session_statuses" */
export enum SessionStatusesSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "session_statuses" */
export type SessionStatusesSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "session_statuses" */
export type SessionStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SessionStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SessionStatusesStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "session_statuses" */
export enum SessionStatusesUpdateColumn {
  /** column name */
  Value = 'value'
}

export type SessionStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SessionStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: SessionStatusesBoolExp;
};

/** These are one-on-one sessions with a student and teacher */
export type Sessions = {
  __typename?: 'sessions';
  callCompleted?: Maybe<Scalars['timestamptz']['output']>;
  callInitiated?: Maybe<Scalars['timestamptz']['output']>;
  callRating?: Maybe<Scalars['Int']['output']>;
  callSigned?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  expectedStartTime: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  slotId: Scalars['Int']['output'];
  status: SessionStatusesEnum;
  /** An object relationship */
  student: Users;
  studentAnsweredAt?: Maybe<Scalars['timestamptz']['output']>;
  studentCancelledAt?: Maybe<Scalars['timestamptz']['output']>;
  studentId: Scalars['Int']['output'];
  studentSDP?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  teacher: Users;
  teacherId: Scalars['Int']['output'];
  teacherRating?: Maybe<Scalars['Int']['output']>;
  teacherReview?: Maybe<Scalars['String']['output']>;
  teacherSDP?: Maybe<Scalars['jsonb']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  uuid: Scalars['String']['output'];
};


/** These are one-on-one sessions with a student and teacher */
export type SessionsStudentSdpArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** These are one-on-one sessions with a student and teacher */
export type SessionsTeacherSdpArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "sessions" */
export type SessionsAggregate = {
  __typename?: 'sessions_aggregate';
  aggregate?: Maybe<SessionsAggregateFields>;
  nodes: Array<Sessions>;
};

export type SessionsAggregateBoolExp = {
  count?: InputMaybe<SessionsAggregateBoolExpCount>;
};

export type SessionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<SessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SessionsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "sessions" */
export type SessionsAggregateFields = {
  __typename?: 'sessions_aggregate_fields';
  avg?: Maybe<SessionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<SessionsMaxFields>;
  min?: Maybe<SessionsMinFields>;
  stddev?: Maybe<SessionsStddevFields>;
  stddev_pop?: Maybe<SessionsStddevPopFields>;
  stddev_samp?: Maybe<SessionsStddevSampFields>;
  sum?: Maybe<SessionsSumFields>;
  var_pop?: Maybe<SessionsVarPopFields>;
  var_samp?: Maybe<SessionsVarSampFields>;
  variance?: Maybe<SessionsVarianceFields>;
};


/** aggregate fields of "sessions" */
export type SessionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "sessions" */
export type SessionsAggregateOrderBy = {
  avg?: InputMaybe<SessionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<SessionsMaxOrderBy>;
  min?: InputMaybe<SessionsMinOrderBy>;
  stddev?: InputMaybe<SessionsStddevOrderBy>;
  stddev_pop?: InputMaybe<SessionsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<SessionsStddevSampOrderBy>;
  sum?: InputMaybe<SessionsSumOrderBy>;
  var_pop?: InputMaybe<SessionsVarPopOrderBy>;
  var_samp?: InputMaybe<SessionsVarSampOrderBy>;
  variance?: InputMaybe<SessionsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SessionsAppendInput = {
  studentSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherSDP?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "sessions" */
export type SessionsArrRelInsertInput = {
  data: Array<SessionsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<SessionsOnConflict>;
};

/** aggregate avg on columns */
export type SessionsAvgFields = {
  __typename?: 'sessions_avg_fields';
  callRating?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  teacherRating?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "sessions" */
export type SessionsAvgOrderBy = {
  callRating?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "sessions". All fields are combined with a logical 'AND'. */
export type SessionsBoolExp = {
  _and?: InputMaybe<Array<SessionsBoolExp>>;
  _not?: InputMaybe<SessionsBoolExp>;
  _or?: InputMaybe<Array<SessionsBoolExp>>;
  callCompleted?: InputMaybe<TimestamptzComparisonExp>;
  callInitiated?: InputMaybe<TimestamptzComparisonExp>;
  callRating?: InputMaybe<IntComparisonExp>;
  callSigned?: InputMaybe<TimestamptzComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  expectedStartTime?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  slotId?: InputMaybe<IntComparisonExp>;
  status?: InputMaybe<SessionStatusesEnumComparisonExp>;
  student?: InputMaybe<UsersBoolExp>;
  studentAnsweredAt?: InputMaybe<TimestamptzComparisonExp>;
  studentCancelledAt?: InputMaybe<TimestamptzComparisonExp>;
  studentId?: InputMaybe<IntComparisonExp>;
  studentSDP?: InputMaybe<JsonbComparisonExp>;
  teacher?: InputMaybe<UsersBoolExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
  teacherRating?: InputMaybe<IntComparisonExp>;
  teacherReview?: InputMaybe<StringComparisonExp>;
  teacherSDP?: InputMaybe<JsonbComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  uuid?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "sessions" */
export enum SessionsConstraint {
  /** unique or primary key constraint on columns "id" */
  SessionsPkey = 'sessions_pkey',
  /** unique or primary key constraint on columns "teacher_id", "student_id", "slot_id" */
  SessionsTeacherIdStudentIdSlotIdKey = 'sessions_teacher_id_student_id_slot_id_key',
  /** unique or primary key constraint on columns "uuid" */
  SessionsUuidKey = 'sessions_uuid_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SessionsDeleteAtPathInput = {
  studentSDP?: InputMaybe<Array<Scalars['String']['input']>>;
  teacherSDP?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SessionsDeleteElemInput = {
  studentSDP?: InputMaybe<Scalars['Int']['input']>;
  teacherSDP?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SessionsDeleteKeyInput = {
  studentSDP?: InputMaybe<Scalars['String']['input']>;
  teacherSDP?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "sessions" */
export type SessionsIncInput = {
  callRating?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  teacherRating?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "sessions" */
export type SessionsInsertInput = {
  callCompleted?: InputMaybe<Scalars['timestamptz']['input']>;
  callInitiated?: InputMaybe<Scalars['timestamptz']['input']>;
  callRating?: InputMaybe<Scalars['Int']['input']>;
  callSigned?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  expectedStartTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<SessionStatusesEnum>;
  student?: InputMaybe<UsersObjRelInsertInput>;
  studentAnsweredAt?: InputMaybe<Scalars['timestamptz']['input']>;
  studentCancelledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  studentSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacher?: InputMaybe<UsersObjRelInsertInput>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  teacherRating?: InputMaybe<Scalars['Int']['input']>;
  teacherReview?: InputMaybe<Scalars['String']['input']>;
  teacherSDP?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type SessionsMaxFields = {
  __typename?: 'sessions_max_fields';
  callCompleted?: Maybe<Scalars['timestamptz']['output']>;
  callInitiated?: Maybe<Scalars['timestamptz']['output']>;
  callRating?: Maybe<Scalars['Int']['output']>;
  callSigned?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  expectedStartTime?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
  studentAnsweredAt?: Maybe<Scalars['timestamptz']['output']>;
  studentCancelledAt?: Maybe<Scalars['timestamptz']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  teacherRating?: Maybe<Scalars['Int']['output']>;
  teacherReview?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "sessions" */
export type SessionsMaxOrderBy = {
  callCompleted?: InputMaybe<OrderBy>;
  callInitiated?: InputMaybe<OrderBy>;
  callRating?: InputMaybe<OrderBy>;
  callSigned?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expectedStartTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentAnsweredAt?: InputMaybe<OrderBy>;
  studentCancelledAt?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
  teacherReview?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  uuid?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type SessionsMinFields = {
  __typename?: 'sessions_min_fields';
  callCompleted?: Maybe<Scalars['timestamptz']['output']>;
  callInitiated?: Maybe<Scalars['timestamptz']['output']>;
  callRating?: Maybe<Scalars['Int']['output']>;
  callSigned?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  expectedStartTime?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
  studentAnsweredAt?: Maybe<Scalars['timestamptz']['output']>;
  studentCancelledAt?: Maybe<Scalars['timestamptz']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  teacherRating?: Maybe<Scalars['Int']['output']>;
  teacherReview?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "sessions" */
export type SessionsMinOrderBy = {
  callCompleted?: InputMaybe<OrderBy>;
  callInitiated?: InputMaybe<OrderBy>;
  callRating?: InputMaybe<OrderBy>;
  callSigned?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expectedStartTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentAnsweredAt?: InputMaybe<OrderBy>;
  studentCancelledAt?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
  teacherReview?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  uuid?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "sessions" */
export type SessionsMutationResponse = {
  __typename?: 'sessions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Sessions>;
};

/** on_conflict condition type for table "sessions" */
export type SessionsOnConflict = {
  constraint: SessionsConstraint;
  update_columns?: Array<SessionsUpdateColumn>;
  where?: InputMaybe<SessionsBoolExp>;
};

/** Ordering options when selecting data from "sessions". */
export type SessionsOrderBy = {
  callCompleted?: InputMaybe<OrderBy>;
  callInitiated?: InputMaybe<OrderBy>;
  callRating?: InputMaybe<OrderBy>;
  callSigned?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  expectedStartTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  student?: InputMaybe<UsersOrderBy>;
  studentAnsweredAt?: InputMaybe<OrderBy>;
  studentCancelledAt?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  studentSDP?: InputMaybe<OrderBy>;
  teacher?: InputMaybe<UsersOrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
  teacherReview?: InputMaybe<OrderBy>;
  teacherSDP?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  uuid?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: sessions */
export type SessionsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SessionsPrependInput = {
  studentSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherSDP?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "sessions" */
export enum SessionsSelectColumn {
  /** column name */
  CallCompleted = 'callCompleted',
  /** column name */
  CallInitiated = 'callInitiated',
  /** column name */
  CallRating = 'callRating',
  /** column name */
  CallSigned = 'callSigned',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpectedStartTime = 'expectedStartTime',
  /** column name */
  Id = 'id',
  /** column name */
  SlotId = 'slotId',
  /** column name */
  Status = 'status',
  /** column name */
  StudentAnsweredAt = 'studentAnsweredAt',
  /** column name */
  StudentCancelledAt = 'studentCancelledAt',
  /** column name */
  StudentId = 'studentId',
  /** column name */
  StudentSdp = 'studentSDP',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  TeacherRating = 'teacherRating',
  /** column name */
  TeacherReview = 'teacherReview',
  /** column name */
  TeacherSdp = 'teacherSDP',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "sessions" */
export type SessionsSetInput = {
  callCompleted?: InputMaybe<Scalars['timestamptz']['input']>;
  callInitiated?: InputMaybe<Scalars['timestamptz']['input']>;
  callRating?: InputMaybe<Scalars['Int']['input']>;
  callSigned?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  expectedStartTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<SessionStatusesEnum>;
  studentAnsweredAt?: InputMaybe<Scalars['timestamptz']['input']>;
  studentCancelledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  studentSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  teacherRating?: InputMaybe<Scalars['Int']['input']>;
  teacherReview?: InputMaybe<Scalars['String']['input']>;
  teacherSDP?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type SessionsStddevFields = {
  __typename?: 'sessions_stddev_fields';
  callRating?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  teacherRating?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "sessions" */
export type SessionsStddevOrderBy = {
  callRating?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type SessionsStddevPopFields = {
  __typename?: 'sessions_stddev_pop_fields';
  callRating?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  teacherRating?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "sessions" */
export type SessionsStddevPopOrderBy = {
  callRating?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type SessionsStddevSampFields = {
  __typename?: 'sessions_stddev_samp_fields';
  callRating?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  teacherRating?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "sessions" */
export type SessionsStddevSampOrderBy = {
  callRating?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "sessions" */
export type SessionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SessionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SessionsStreamCursorValueInput = {
  callCompleted?: InputMaybe<Scalars['timestamptz']['input']>;
  callInitiated?: InputMaybe<Scalars['timestamptz']['input']>;
  callRating?: InputMaybe<Scalars['Int']['input']>;
  callSigned?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  expectedStartTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  slotId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<SessionStatusesEnum>;
  studentAnsweredAt?: InputMaybe<Scalars['timestamptz']['input']>;
  studentCancelledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  studentSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  teacherRating?: InputMaybe<Scalars['Int']['input']>;
  teacherReview?: InputMaybe<Scalars['String']['input']>;
  teacherSDP?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type SessionsSumFields = {
  __typename?: 'sessions_sum_fields';
  callRating?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  slotId?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  teacherRating?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "sessions" */
export type SessionsSumOrderBy = {
  callRating?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
};

/** update columns of table "sessions" */
export enum SessionsUpdateColumn {
  /** column name */
  CallCompleted = 'callCompleted',
  /** column name */
  CallInitiated = 'callInitiated',
  /** column name */
  CallRating = 'callRating',
  /** column name */
  CallSigned = 'callSigned',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpectedStartTime = 'expectedStartTime',
  /** column name */
  Id = 'id',
  /** column name */
  SlotId = 'slotId',
  /** column name */
  Status = 'status',
  /** column name */
  StudentAnsweredAt = 'studentAnsweredAt',
  /** column name */
  StudentCancelledAt = 'studentCancelledAt',
  /** column name */
  StudentId = 'studentId',
  /** column name */
  StudentSdp = 'studentSDP',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  TeacherRating = 'teacherRating',
  /** column name */
  TeacherReview = 'teacherReview',
  /** column name */
  TeacherSdp = 'teacherSDP',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Uuid = 'uuid'
}

export type SessionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SessionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<SessionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<SessionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<SessionsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SessionsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SessionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SessionsSetInput>;
  /** filter the rows which have to be updated */
  where: SessionsBoolExp;
};

/** aggregate var_pop on columns */
export type SessionsVarPopFields = {
  __typename?: 'sessions_var_pop_fields';
  callRating?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  teacherRating?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "sessions" */
export type SessionsVarPopOrderBy = {
  callRating?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type SessionsVarSampFields = {
  __typename?: 'sessions_var_samp_fields';
  callRating?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  teacherRating?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "sessions" */
export type SessionsVarSampOrderBy = {
  callRating?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type SessionsVarianceFields = {
  __typename?: 'sessions_variance_fields';
  callRating?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  slotId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  teacherRating?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "sessions" */
export type SessionsVarianceOrderBy = {
  callRating?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  slotId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  teacherRating?: InputMaybe<OrderBy>;
};

/** columns and relationships of "slots" */
export type Slots = {
  __typename?: 'slots';
  /** An object relationship */
  availabilityTime: AvailabilityTimes;
  availabilityTimeId: Scalars['Int']['output'];
  bookedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  classSlotBookings: Array<ClassSlotBookings>;
  /** An aggregate relationship */
  classSlotBookings_aggregate: ClassSlotBookingsAggregate;
  createdAt: Scalars['timestamptz']['output'];
  date: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  isClass?: Maybe<Scalars['Boolean']['output']>;
  isFree?: Maybe<Scalars['Boolean']['output']>;
  priceAtBooking?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  sessions: Array<Sessions>;
  /** An aggregate relationship */
  sessions_aggregate: SessionsAggregate;
  /** An object relationship */
  student?: Maybe<Users>;
  studentId?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  teacher: Teachers;
  teacherCancelledAt?: Maybe<Scalars['timestamptz']['output']>;
  teacherConfirmedAt?: Maybe<Scalars['timestamptz']['output']>;
  teacherId: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "slots" */
export type SlotsClassSlotBookingsArgs = {
  distinct_on?: InputMaybe<Array<ClassSlotBookingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSlotBookingsOrderBy>>;
  where?: InputMaybe<ClassSlotBookingsBoolExp>;
};


/** columns and relationships of "slots" */
export type SlotsClassSlotBookingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassSlotBookingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSlotBookingsOrderBy>>;
  where?: InputMaybe<ClassSlotBookingsBoolExp>;
};


/** columns and relationships of "slots" */
export type SlotsSessionsArgs = {
  distinct_on?: InputMaybe<Array<SessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionsOrderBy>>;
  where?: InputMaybe<SessionsBoolExp>;
};


/** columns and relationships of "slots" */
export type SlotsSessionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionsOrderBy>>;
  where?: InputMaybe<SessionsBoolExp>;
};

/** aggregated selection of "slots" */
export type SlotsAggregate = {
  __typename?: 'slots_aggregate';
  aggregate?: Maybe<SlotsAggregateFields>;
  nodes: Array<Slots>;
};

export type SlotsAggregateBoolExp = {
  bool_and?: InputMaybe<SlotsAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<SlotsAggregateBoolExpBoolOr>;
  count?: InputMaybe<SlotsAggregateBoolExpCount>;
};

export type SlotsAggregateBoolExpBoolAnd = {
  arguments: SlotsSelectColumnSlotsAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SlotsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type SlotsAggregateBoolExpBoolOr = {
  arguments: SlotsSelectColumnSlotsAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SlotsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type SlotsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<SlotsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SlotsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "slots" */
export type SlotsAggregateFields = {
  __typename?: 'slots_aggregate_fields';
  avg?: Maybe<SlotsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<SlotsMaxFields>;
  min?: Maybe<SlotsMinFields>;
  stddev?: Maybe<SlotsStddevFields>;
  stddev_pop?: Maybe<SlotsStddevPopFields>;
  stddev_samp?: Maybe<SlotsStddevSampFields>;
  sum?: Maybe<SlotsSumFields>;
  var_pop?: Maybe<SlotsVarPopFields>;
  var_samp?: Maybe<SlotsVarSampFields>;
  variance?: Maybe<SlotsVarianceFields>;
};


/** aggregate fields of "slots" */
export type SlotsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SlotsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "slots" */
export type SlotsAggregateOrderBy = {
  avg?: InputMaybe<SlotsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<SlotsMaxOrderBy>;
  min?: InputMaybe<SlotsMinOrderBy>;
  stddev?: InputMaybe<SlotsStddevOrderBy>;
  stddev_pop?: InputMaybe<SlotsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<SlotsStddevSampOrderBy>;
  sum?: InputMaybe<SlotsSumOrderBy>;
  var_pop?: InputMaybe<SlotsVarPopOrderBy>;
  var_samp?: InputMaybe<SlotsVarSampOrderBy>;
  variance?: InputMaybe<SlotsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "slots" */
export type SlotsArrRelInsertInput = {
  data: Array<SlotsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<SlotsOnConflict>;
};

/** aggregate avg on columns */
export type SlotsAvgFields = {
  __typename?: 'slots_avg_fields';
  availabilityTimeId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  priceAtBooking?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "slots" */
export type SlotsAvgOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "slots". All fields are combined with a logical 'AND'. */
export type SlotsBoolExp = {
  _and?: InputMaybe<Array<SlotsBoolExp>>;
  _not?: InputMaybe<SlotsBoolExp>;
  _or?: InputMaybe<Array<SlotsBoolExp>>;
  availabilityTime?: InputMaybe<AvailabilityTimesBoolExp>;
  availabilityTimeId?: InputMaybe<IntComparisonExp>;
  bookedAt?: InputMaybe<TimestamptzComparisonExp>;
  classSlotBookings?: InputMaybe<ClassSlotBookingsBoolExp>;
  classSlotBookings_aggregate?: InputMaybe<ClassSlotBookingsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  date?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isClass?: InputMaybe<BooleanComparisonExp>;
  isFree?: InputMaybe<BooleanComparisonExp>;
  priceAtBooking?: InputMaybe<IntComparisonExp>;
  sessions?: InputMaybe<SessionsBoolExp>;
  sessions_aggregate?: InputMaybe<SessionsAggregateBoolExp>;
  student?: InputMaybe<UsersBoolExp>;
  studentId?: InputMaybe<IntComparisonExp>;
  teacher?: InputMaybe<TeachersBoolExp>;
  teacherCancelledAt?: InputMaybe<TimestamptzComparisonExp>;
  teacherConfirmedAt?: InputMaybe<TimestamptzComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "slots" */
export enum SlotsConstraint {
  /** unique or primary key constraint on columns "id" */
  SlotsPkey = 'slots_pkey',
  /** unique or primary key constraint on columns "student_id", "date" */
  SlotsStudentIdDateKey = 'slots_student_id_date_key',
  /** unique or primary key constraint on columns "teacher_id", "date" */
  SlotsUserIdDateKey = 'slots_user_id_date_key'
}

/** input type for incrementing numeric columns in table "slots" */
export type SlotsIncInput = {
  availabilityTimeId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  priceAtBooking?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "slots" */
export type SlotsInsertInput = {
  availabilityTime?: InputMaybe<AvailabilityTimesObjRelInsertInput>;
  availabilityTimeId?: InputMaybe<Scalars['Int']['input']>;
  bookedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  classSlotBookings?: InputMaybe<ClassSlotBookingsArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isClass?: InputMaybe<Scalars['Boolean']['input']>;
  isFree?: InputMaybe<Scalars['Boolean']['input']>;
  priceAtBooking?: InputMaybe<Scalars['Int']['input']>;
  sessions?: InputMaybe<SessionsArrRelInsertInput>;
  student?: InputMaybe<UsersObjRelInsertInput>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacher?: InputMaybe<TeachersObjRelInsertInput>;
  teacherCancelledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  teacherConfirmedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type SlotsMaxFields = {
  __typename?: 'slots_max_fields';
  availabilityTimeId?: Maybe<Scalars['Int']['output']>;
  bookedAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  priceAtBooking?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherCancelledAt?: Maybe<Scalars['timestamptz']['output']>;
  teacherConfirmedAt?: Maybe<Scalars['timestamptz']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "slots" */
export type SlotsMaxOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  bookedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherCancelledAt?: InputMaybe<OrderBy>;
  teacherConfirmedAt?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type SlotsMinFields = {
  __typename?: 'slots_min_fields';
  availabilityTimeId?: Maybe<Scalars['Int']['output']>;
  bookedAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  priceAtBooking?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherCancelledAt?: Maybe<Scalars['timestamptz']['output']>;
  teacherConfirmedAt?: Maybe<Scalars['timestamptz']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "slots" */
export type SlotsMinOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  bookedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherCancelledAt?: InputMaybe<OrderBy>;
  teacherConfirmedAt?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "slots" */
export type SlotsMutationResponse = {
  __typename?: 'slots_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Slots>;
};

/** input type for inserting object relation for remote table "slots" */
export type SlotsObjRelInsertInput = {
  data: SlotsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<SlotsOnConflict>;
};

/** on_conflict condition type for table "slots" */
export type SlotsOnConflict = {
  constraint: SlotsConstraint;
  update_columns?: Array<SlotsUpdateColumn>;
  where?: InputMaybe<SlotsBoolExp>;
};

/** Ordering options when selecting data from "slots". */
export type SlotsOrderBy = {
  availabilityTime?: InputMaybe<AvailabilityTimesOrderBy>;
  availabilityTimeId?: InputMaybe<OrderBy>;
  bookedAt?: InputMaybe<OrderBy>;
  classSlotBookings_aggregate?: InputMaybe<ClassSlotBookingsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isClass?: InputMaybe<OrderBy>;
  isFree?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  sessions_aggregate?: InputMaybe<SessionsAggregateOrderBy>;
  student?: InputMaybe<UsersOrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacher?: InputMaybe<TeachersOrderBy>;
  teacherCancelledAt?: InputMaybe<OrderBy>;
  teacherConfirmedAt?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: slots */
export type SlotsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "slots" */
export enum SlotsSelectColumn {
  /** column name */
  AvailabilityTimeId = 'availabilityTimeId',
  /** column name */
  BookedAt = 'bookedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  IsClass = 'isClass',
  /** column name */
  IsFree = 'isFree',
  /** column name */
  PriceAtBooking = 'priceAtBooking',
  /** column name */
  StudentId = 'studentId',
  /** column name */
  TeacherCancelledAt = 'teacherCancelledAt',
  /** column name */
  TeacherConfirmedAt = 'teacherConfirmedAt',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "slots_aggregate_bool_exp_bool_and_arguments_columns" columns of table "slots" */
export enum SlotsSelectColumnSlotsAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsClass = 'isClass',
  /** column name */
  IsFree = 'isFree'
}

/** select "slots_aggregate_bool_exp_bool_or_arguments_columns" columns of table "slots" */
export enum SlotsSelectColumnSlotsAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsClass = 'isClass',
  /** column name */
  IsFree = 'isFree'
}

/** input type for updating data in table "slots" */
export type SlotsSetInput = {
  availabilityTimeId?: InputMaybe<Scalars['Int']['input']>;
  bookedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isClass?: InputMaybe<Scalars['Boolean']['input']>;
  isFree?: InputMaybe<Scalars['Boolean']['input']>;
  priceAtBooking?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacherCancelledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  teacherConfirmedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type SlotsStddevFields = {
  __typename?: 'slots_stddev_fields';
  availabilityTimeId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  priceAtBooking?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "slots" */
export type SlotsStddevOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type SlotsStddevPopFields = {
  __typename?: 'slots_stddev_pop_fields';
  availabilityTimeId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  priceAtBooking?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "slots" */
export type SlotsStddevPopOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type SlotsStddevSampFields = {
  __typename?: 'slots_stddev_samp_fields';
  availabilityTimeId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  priceAtBooking?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "slots" */
export type SlotsStddevSampOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "slots" */
export type SlotsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SlotsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SlotsStreamCursorValueInput = {
  availabilityTimeId?: InputMaybe<Scalars['Int']['input']>;
  bookedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isClass?: InputMaybe<Scalars['Boolean']['input']>;
  isFree?: InputMaybe<Scalars['Boolean']['input']>;
  priceAtBooking?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacherCancelledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  teacherConfirmedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type SlotsSumFields = {
  __typename?: 'slots_sum_fields';
  availabilityTimeId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  priceAtBooking?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "slots" */
export type SlotsSumOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** update columns of table "slots" */
export enum SlotsUpdateColumn {
  /** column name */
  AvailabilityTimeId = 'availabilityTimeId',
  /** column name */
  BookedAt = 'bookedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  IsClass = 'isClass',
  /** column name */
  IsFree = 'isFree',
  /** column name */
  PriceAtBooking = 'priceAtBooking',
  /** column name */
  StudentId = 'studentId',
  /** column name */
  TeacherCancelledAt = 'teacherCancelledAt',
  /** column name */
  TeacherConfirmedAt = 'teacherConfirmedAt',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type SlotsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SlotsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SlotsSetInput>;
  /** filter the rows which have to be updated */
  where: SlotsBoolExp;
};

/** aggregate var_pop on columns */
export type SlotsVarPopFields = {
  __typename?: 'slots_var_pop_fields';
  availabilityTimeId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  priceAtBooking?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "slots" */
export type SlotsVarPopOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type SlotsVarSampFields = {
  __typename?: 'slots_var_samp_fields';
  availabilityTimeId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  priceAtBooking?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "slots" */
export type SlotsVarSampOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type SlotsVarianceFields = {
  __typename?: 'slots_variance_fields';
  availabilityTimeId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  priceAtBooking?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "slots" */
export type SlotsVarianceOrderBy = {
  availabilityTimeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priceAtBooking?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "stats" */
export type Stats = {
  __typename?: 'stats';
  activityCompletionCount: Scalars['Int']['output'];
  activityCreationCount: Scalars['Int']['output'];
  activityResponsesCount: Scalars['Int']['output'];
  bookCompletionCount?: Maybe<Scalars['Int']['output']>;
  bookCreationCount: Scalars['Int']['output'];
  courseCompletionCount: Scalars['Int']['output'];
  courseCreationCount: Scalars['Int']['output'];
  dictionaryDownloads: Scalars['Int']['output'];
  end: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  start: Scalars['timestamptz']['output'];
  sttCount: Scalars['Int']['output'];
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount: Scalars['Int']['output'];
  ttsCount: Scalars['Int']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['Int']['output'];
  userWordsCount: Scalars['Int']['output'];
  wordCreationCount: Scalars['Int']['output'];
};

/** aggregated selection of "stats" */
export type StatsAggregate = {
  __typename?: 'stats_aggregate';
  aggregate?: Maybe<StatsAggregateFields>;
  nodes: Array<Stats>;
};

/** aggregate fields of "stats" */
export type StatsAggregateFields = {
  __typename?: 'stats_aggregate_fields';
  avg?: Maybe<StatsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<StatsMaxFields>;
  min?: Maybe<StatsMinFields>;
  stddev?: Maybe<StatsStddevFields>;
  stddev_pop?: Maybe<StatsStddevPopFields>;
  stddev_samp?: Maybe<StatsStddevSampFields>;
  sum?: Maybe<StatsSumFields>;
  var_pop?: Maybe<StatsVarPopFields>;
  var_samp?: Maybe<StatsVarSampFields>;
  variance?: Maybe<StatsVarianceFields>;
};


/** aggregate fields of "stats" */
export type StatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StatsAvgFields = {
  __typename?: 'stats_avg_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  sttCount?: Maybe<Scalars['Float']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Float']['output']>;
  ttsCount?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "stats". All fields are combined with a logical 'AND'. */
export type StatsBoolExp = {
  _and?: InputMaybe<Array<StatsBoolExp>>;
  _not?: InputMaybe<StatsBoolExp>;
  _or?: InputMaybe<Array<StatsBoolExp>>;
  activityCompletionCount?: InputMaybe<IntComparisonExp>;
  activityCreationCount?: InputMaybe<IntComparisonExp>;
  activityResponsesCount?: InputMaybe<IntComparisonExp>;
  bookCompletionCount?: InputMaybe<IntComparisonExp>;
  bookCreationCount?: InputMaybe<IntComparisonExp>;
  courseCompletionCount?: InputMaybe<IntComparisonExp>;
  courseCreationCount?: InputMaybe<IntComparisonExp>;
  dictionaryDownloads?: InputMaybe<IntComparisonExp>;
  end?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  start?: InputMaybe<TimestamptzComparisonExp>;
  sttCount?: InputMaybe<IntComparisonExp>;
  total?: InputMaybe<IntComparisonExp>;
  translationCount?: InputMaybe<IntComparisonExp>;
  ttsCount?: InputMaybe<IntComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<IntComparisonExp>;
  userWordsCount?: InputMaybe<IntComparisonExp>;
  wordCreationCount?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "stats" */
export enum StatsConstraint {
  /** unique or primary key constraint on columns "id" */
  StatsPkey = 'stats_pkey',
  /** unique or primary key constraint on columns "user_id", "start" */
  StatsUserIdStartKey = 'stats_user_id_start_key'
}

/** input type for incrementing numeric columns in table "stats" */
export type StatsIncInput = {
  activityCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  activityCreationCount?: InputMaybe<Scalars['Int']['input']>;
  activityResponsesCount?: InputMaybe<Scalars['Int']['input']>;
  bookCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  bookCreationCount?: InputMaybe<Scalars['Int']['input']>;
  courseCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  courseCreationCount?: InputMaybe<Scalars['Int']['input']>;
  dictionaryDownloads?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sttCount?: InputMaybe<Scalars['Int']['input']>;
  translationCount?: InputMaybe<Scalars['Int']['input']>;
  ttsCount?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userWordsCount?: InputMaybe<Scalars['Int']['input']>;
  wordCreationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "stats" */
export type StatsInsertInput = {
  activityCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  activityCreationCount?: InputMaybe<Scalars['Int']['input']>;
  activityResponsesCount?: InputMaybe<Scalars['Int']['input']>;
  bookCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  bookCreationCount?: InputMaybe<Scalars['Int']['input']>;
  courseCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  courseCreationCount?: InputMaybe<Scalars['Int']['input']>;
  dictionaryDownloads?: InputMaybe<Scalars['Int']['input']>;
  end?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['timestamptz']['input']>;
  sttCount?: InputMaybe<Scalars['Int']['input']>;
  translationCount?: InputMaybe<Scalars['Int']['input']>;
  ttsCount?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userWordsCount?: InputMaybe<Scalars['Int']['input']>;
  wordCreationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type StatsMaxFields = {
  __typename?: 'stats_max_fields';
  activityCompletionCount?: Maybe<Scalars['Int']['output']>;
  activityCreationCount?: Maybe<Scalars['Int']['output']>;
  activityResponsesCount?: Maybe<Scalars['Int']['output']>;
  bookCompletionCount?: Maybe<Scalars['Int']['output']>;
  bookCreationCount?: Maybe<Scalars['Int']['output']>;
  courseCompletionCount?: Maybe<Scalars['Int']['output']>;
  courseCreationCount?: Maybe<Scalars['Int']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Int']['output']>;
  end?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  start?: Maybe<Scalars['timestamptz']['output']>;
  sttCount?: Maybe<Scalars['Int']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Int']['output']>;
  ttsCount?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  userWordsCount?: Maybe<Scalars['Int']['output']>;
  wordCreationCount?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type StatsMinFields = {
  __typename?: 'stats_min_fields';
  activityCompletionCount?: Maybe<Scalars['Int']['output']>;
  activityCreationCount?: Maybe<Scalars['Int']['output']>;
  activityResponsesCount?: Maybe<Scalars['Int']['output']>;
  bookCompletionCount?: Maybe<Scalars['Int']['output']>;
  bookCreationCount?: Maybe<Scalars['Int']['output']>;
  courseCompletionCount?: Maybe<Scalars['Int']['output']>;
  courseCreationCount?: Maybe<Scalars['Int']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Int']['output']>;
  end?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  start?: Maybe<Scalars['timestamptz']['output']>;
  sttCount?: Maybe<Scalars['Int']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Int']['output']>;
  ttsCount?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  userWordsCount?: Maybe<Scalars['Int']['output']>;
  wordCreationCount?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "stats" */
export type StatsMutationResponse = {
  __typename?: 'stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Stats>;
};

/** on_conflict condition type for table "stats" */
export type StatsOnConflict = {
  constraint: StatsConstraint;
  update_columns?: Array<StatsUpdateColumn>;
  where?: InputMaybe<StatsBoolExp>;
};

/** Ordering options when selecting data from "stats". */
export type StatsOrderBy = {
  activityCompletionCount?: InputMaybe<OrderBy>;
  activityCreationCount?: InputMaybe<OrderBy>;
  activityResponsesCount?: InputMaybe<OrderBy>;
  bookCompletionCount?: InputMaybe<OrderBy>;
  bookCreationCount?: InputMaybe<OrderBy>;
  courseCompletionCount?: InputMaybe<OrderBy>;
  courseCreationCount?: InputMaybe<OrderBy>;
  dictionaryDownloads?: InputMaybe<OrderBy>;
  end?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  start?: InputMaybe<OrderBy>;
  sttCount?: InputMaybe<OrderBy>;
  total?: InputMaybe<OrderBy>;
  translationCount?: InputMaybe<OrderBy>;
  ttsCount?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  userWordsCount?: InputMaybe<OrderBy>;
  wordCreationCount?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stats */
export type StatsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "stats" */
export enum StatsSelectColumn {
  /** column name */
  ActivityCompletionCount = 'activityCompletionCount',
  /** column name */
  ActivityCreationCount = 'activityCreationCount',
  /** column name */
  ActivityResponsesCount = 'activityResponsesCount',
  /** column name */
  BookCompletionCount = 'bookCompletionCount',
  /** column name */
  BookCreationCount = 'bookCreationCount',
  /** column name */
  CourseCompletionCount = 'courseCompletionCount',
  /** column name */
  CourseCreationCount = 'courseCreationCount',
  /** column name */
  DictionaryDownloads = 'dictionaryDownloads',
  /** column name */
  End = 'end',
  /** column name */
  Id = 'id',
  /** column name */
  Start = 'start',
  /** column name */
  SttCount = 'sttCount',
  /** column name */
  TranslationCount = 'translationCount',
  /** column name */
  TtsCount = 'ttsCount',
  /** column name */
  UserId = 'userId',
  /** column name */
  UserWordsCount = 'userWordsCount',
  /** column name */
  WordCreationCount = 'wordCreationCount'
}

/** input type for updating data in table "stats" */
export type StatsSetInput = {
  activityCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  activityCreationCount?: InputMaybe<Scalars['Int']['input']>;
  activityResponsesCount?: InputMaybe<Scalars['Int']['input']>;
  bookCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  bookCreationCount?: InputMaybe<Scalars['Int']['input']>;
  courseCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  courseCreationCount?: InputMaybe<Scalars['Int']['input']>;
  dictionaryDownloads?: InputMaybe<Scalars['Int']['input']>;
  end?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['timestamptz']['input']>;
  sttCount?: InputMaybe<Scalars['Int']['input']>;
  translationCount?: InputMaybe<Scalars['Int']['input']>;
  ttsCount?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userWordsCount?: InputMaybe<Scalars['Int']['input']>;
  wordCreationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type StatsStddevFields = {
  __typename?: 'stats_stddev_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  sttCount?: Maybe<Scalars['Float']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Float']['output']>;
  ttsCount?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StatsStddevPopFields = {
  __typename?: 'stats_stddev_pop_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  sttCount?: Maybe<Scalars['Float']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Float']['output']>;
  ttsCount?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StatsStddevSampFields = {
  __typename?: 'stats_stddev_samp_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  sttCount?: Maybe<Scalars['Float']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Float']['output']>;
  ttsCount?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "stats" */
export type StatsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StatsStreamCursorValueInput = {
  activityCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  activityCreationCount?: InputMaybe<Scalars['Int']['input']>;
  activityResponsesCount?: InputMaybe<Scalars['Int']['input']>;
  bookCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  bookCreationCount?: InputMaybe<Scalars['Int']['input']>;
  courseCompletionCount?: InputMaybe<Scalars['Int']['input']>;
  courseCreationCount?: InputMaybe<Scalars['Int']['input']>;
  dictionaryDownloads?: InputMaybe<Scalars['Int']['input']>;
  end?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['timestamptz']['input']>;
  sttCount?: InputMaybe<Scalars['Int']['input']>;
  translationCount?: InputMaybe<Scalars['Int']['input']>;
  ttsCount?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userWordsCount?: InputMaybe<Scalars['Int']['input']>;
  wordCreationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type StatsSumFields = {
  __typename?: 'stats_sum_fields';
  activityCompletionCount?: Maybe<Scalars['Int']['output']>;
  activityCreationCount?: Maybe<Scalars['Int']['output']>;
  activityResponsesCount?: Maybe<Scalars['Int']['output']>;
  bookCompletionCount?: Maybe<Scalars['Int']['output']>;
  bookCreationCount?: Maybe<Scalars['Int']['output']>;
  courseCompletionCount?: Maybe<Scalars['Int']['output']>;
  courseCreationCount?: Maybe<Scalars['Int']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  sttCount?: Maybe<Scalars['Int']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Int']['output']>;
  ttsCount?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  userWordsCount?: Maybe<Scalars['Int']['output']>;
  wordCreationCount?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "stats" */
export enum StatsUpdateColumn {
  /** column name */
  ActivityCompletionCount = 'activityCompletionCount',
  /** column name */
  ActivityCreationCount = 'activityCreationCount',
  /** column name */
  ActivityResponsesCount = 'activityResponsesCount',
  /** column name */
  BookCompletionCount = 'bookCompletionCount',
  /** column name */
  BookCreationCount = 'bookCreationCount',
  /** column name */
  CourseCompletionCount = 'courseCompletionCount',
  /** column name */
  CourseCreationCount = 'courseCreationCount',
  /** column name */
  DictionaryDownloads = 'dictionaryDownloads',
  /** column name */
  End = 'end',
  /** column name */
  Id = 'id',
  /** column name */
  Start = 'start',
  /** column name */
  SttCount = 'sttCount',
  /** column name */
  TranslationCount = 'translationCount',
  /** column name */
  TtsCount = 'ttsCount',
  /** column name */
  UserId = 'userId',
  /** column name */
  UserWordsCount = 'userWordsCount',
  /** column name */
  WordCreationCount = 'wordCreationCount'
}

export type StatsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StatsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StatsSetInput>;
  /** filter the rows which have to be updated */
  where: StatsBoolExp;
};

/** aggregate var_pop on columns */
export type StatsVarPopFields = {
  __typename?: 'stats_var_pop_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  sttCount?: Maybe<Scalars['Float']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Float']['output']>;
  ttsCount?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StatsVarSampFields = {
  __typename?: 'stats_var_samp_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  sttCount?: Maybe<Scalars['Float']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Float']['output']>;
  ttsCount?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StatsVarianceFields = {
  __typename?: 'stats_variance_fields';
  activityCompletionCount?: Maybe<Scalars['Float']['output']>;
  activityCreationCount?: Maybe<Scalars['Float']['output']>;
  activityResponsesCount?: Maybe<Scalars['Float']['output']>;
  bookCompletionCount?: Maybe<Scalars['Float']['output']>;
  bookCreationCount?: Maybe<Scalars['Float']['output']>;
  courseCompletionCount?: Maybe<Scalars['Float']['output']>;
  courseCreationCount?: Maybe<Scalars['Float']['output']>;
  dictionaryDownloads?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  sttCount?: Maybe<Scalars['Float']['output']>;
  /** A computed field that returns the total stats */
  total?: Maybe<Scalars['Int']['output']>;
  translationCount?: Maybe<Scalars['Float']['output']>;
  ttsCount?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  userWordsCount?: Maybe<Scalars['Float']['output']>;
  wordCreationCount?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "student_class_sessions" */
export type StudentClassSessions = {
  __typename?: 'student_class_sessions';
  breakoutRoom?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  classSession: ClassSessions;
  classSessionId: Scalars['Int']['output'];
  hasRaisedHand?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['Int']['output'];
  isCameraOn?: Maybe<Scalars['Boolean']['output']>;
  isDisputed?: Maybe<Scalars['Boolean']['output']>;
  isMicOn?: Maybe<Scalars['Boolean']['output']>;
  isTrial?: Maybe<Scalars['Boolean']['output']>;
  joinedAt?: Maybe<Scalars['timestamptz']['output']>;
  leftAt?: Maybe<Scalars['timestamptz']['output']>;
  sdp?: Maybe<Scalars['jsonb']['output']>;
  signedBy?: Maybe<Scalars['Int']['output']>;
  studentId: Scalars['Int']['output'];
  studentPaid: Scalars['Boolean']['output'];
};


/** columns and relationships of "student_class_sessions" */
export type StudentClassSessionsSdpArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "student_class_sessions" */
export type StudentClassSessionsAggregate = {
  __typename?: 'student_class_sessions_aggregate';
  aggregate?: Maybe<StudentClassSessionsAggregateFields>;
  nodes: Array<StudentClassSessions>;
};

export type StudentClassSessionsAggregateBoolExp = {
  bool_and?: InputMaybe<StudentClassSessionsAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<StudentClassSessionsAggregateBoolExpBoolOr>;
  count?: InputMaybe<StudentClassSessionsAggregateBoolExpCount>;
};

export type StudentClassSessionsAggregateBoolExpBoolAnd = {
  arguments: StudentClassSessionsSelectColumnStudentClassSessionsAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<StudentClassSessionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type StudentClassSessionsAggregateBoolExpBoolOr = {
  arguments: StudentClassSessionsSelectColumnStudentClassSessionsAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<StudentClassSessionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type StudentClassSessionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StudentClassSessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<StudentClassSessionsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "student_class_sessions" */
export type StudentClassSessionsAggregateFields = {
  __typename?: 'student_class_sessions_aggregate_fields';
  avg?: Maybe<StudentClassSessionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<StudentClassSessionsMaxFields>;
  min?: Maybe<StudentClassSessionsMinFields>;
  stddev?: Maybe<StudentClassSessionsStddevFields>;
  stddev_pop?: Maybe<StudentClassSessionsStddevPopFields>;
  stddev_samp?: Maybe<StudentClassSessionsStddevSampFields>;
  sum?: Maybe<StudentClassSessionsSumFields>;
  var_pop?: Maybe<StudentClassSessionsVarPopFields>;
  var_samp?: Maybe<StudentClassSessionsVarSampFields>;
  variance?: Maybe<StudentClassSessionsVarianceFields>;
};


/** aggregate fields of "student_class_sessions" */
export type StudentClassSessionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StudentClassSessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "student_class_sessions" */
export type StudentClassSessionsAggregateOrderBy = {
  avg?: InputMaybe<StudentClassSessionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StudentClassSessionsMaxOrderBy>;
  min?: InputMaybe<StudentClassSessionsMinOrderBy>;
  stddev?: InputMaybe<StudentClassSessionsStddevOrderBy>;
  stddev_pop?: InputMaybe<StudentClassSessionsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StudentClassSessionsStddevSampOrderBy>;
  sum?: InputMaybe<StudentClassSessionsSumOrderBy>;
  var_pop?: InputMaybe<StudentClassSessionsVarPopOrderBy>;
  var_samp?: InputMaybe<StudentClassSessionsVarSampOrderBy>;
  variance?: InputMaybe<StudentClassSessionsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type StudentClassSessionsAppendInput = {
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "student_class_sessions" */
export type StudentClassSessionsArrRelInsertInput = {
  data: Array<StudentClassSessionsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StudentClassSessionsOnConflict>;
};

/** aggregate avg on columns */
export type StudentClassSessionsAvgFields = {
  __typename?: 'student_class_sessions_avg_fields';
  breakoutRoom?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  signedBy?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "student_class_sessions" */
export type StudentClassSessionsAvgOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "student_class_sessions". All fields are combined with a logical 'AND'. */
export type StudentClassSessionsBoolExp = {
  _and?: InputMaybe<Array<StudentClassSessionsBoolExp>>;
  _not?: InputMaybe<StudentClassSessionsBoolExp>;
  _or?: InputMaybe<Array<StudentClassSessionsBoolExp>>;
  breakoutRoom?: InputMaybe<IntComparisonExp>;
  classSession?: InputMaybe<ClassSessionsBoolExp>;
  classSessionId?: InputMaybe<IntComparisonExp>;
  hasRaisedHand?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isCameraOn?: InputMaybe<BooleanComparisonExp>;
  isDisputed?: InputMaybe<BooleanComparisonExp>;
  isMicOn?: InputMaybe<BooleanComparisonExp>;
  isTrial?: InputMaybe<BooleanComparisonExp>;
  joinedAt?: InputMaybe<TimestamptzComparisonExp>;
  leftAt?: InputMaybe<TimestamptzComparisonExp>;
  sdp?: InputMaybe<JsonbComparisonExp>;
  signedBy?: InputMaybe<IntComparisonExp>;
  studentId?: InputMaybe<IntComparisonExp>;
  studentPaid?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "student_class_sessions" */
export enum StudentClassSessionsConstraint {
  /** unique or primary key constraint on columns "id" */
  StudentClassSessionsPkey = 'student_class_sessions_pkey',
  /** unique or primary key constraint on columns "student_id", "class_session_id" */
  StudentClassSessionsStudentIdClassSessionIdKey = 'student_class_sessions_student_id_class_session_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type StudentClassSessionsDeleteAtPathInput = {
  sdp?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type StudentClassSessionsDeleteElemInput = {
  sdp?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type StudentClassSessionsDeleteKeyInput = {
  sdp?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "student_class_sessions" */
export type StudentClassSessionsIncInput = {
  breakoutRoom?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  signedBy?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "student_class_sessions" */
export type StudentClassSessionsInsertInput = {
  breakoutRoom?: InputMaybe<Scalars['Int']['input']>;
  classSession?: InputMaybe<ClassSessionsObjRelInsertInput>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  hasRaisedHand?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCameraOn?: InputMaybe<Scalars['Boolean']['input']>;
  isDisputed?: InputMaybe<Scalars['Boolean']['input']>;
  isMicOn?: InputMaybe<Scalars['Boolean']['input']>;
  isTrial?: InputMaybe<Scalars['Boolean']['input']>;
  joinedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  leftAt?: InputMaybe<Scalars['timestamptz']['input']>;
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
  signedBy?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  studentPaid?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate max on columns */
export type StudentClassSessionsMaxFields = {
  __typename?: 'student_class_sessions_max_fields';
  breakoutRoom?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  joinedAt?: Maybe<Scalars['timestamptz']['output']>;
  leftAt?: Maybe<Scalars['timestamptz']['output']>;
  signedBy?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "student_class_sessions" */
export type StudentClassSessionsMaxOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  joinedAt?: InputMaybe<OrderBy>;
  leftAt?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StudentClassSessionsMinFields = {
  __typename?: 'student_class_sessions_min_fields';
  breakoutRoom?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  joinedAt?: Maybe<Scalars['timestamptz']['output']>;
  leftAt?: Maybe<Scalars['timestamptz']['output']>;
  signedBy?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "student_class_sessions" */
export type StudentClassSessionsMinOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  joinedAt?: InputMaybe<OrderBy>;
  leftAt?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "student_class_sessions" */
export type StudentClassSessionsMutationResponse = {
  __typename?: 'student_class_sessions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<StudentClassSessions>;
};

/** on_conflict condition type for table "student_class_sessions" */
export type StudentClassSessionsOnConflict = {
  constraint: StudentClassSessionsConstraint;
  update_columns?: Array<StudentClassSessionsUpdateColumn>;
  where?: InputMaybe<StudentClassSessionsBoolExp>;
};

/** Ordering options when selecting data from "student_class_sessions". */
export type StudentClassSessionsOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSession?: InputMaybe<ClassSessionsOrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  hasRaisedHand?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCameraOn?: InputMaybe<OrderBy>;
  isDisputed?: InputMaybe<OrderBy>;
  isMicOn?: InputMaybe<OrderBy>;
  isTrial?: InputMaybe<OrderBy>;
  joinedAt?: InputMaybe<OrderBy>;
  leftAt?: InputMaybe<OrderBy>;
  sdp?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  studentPaid?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: student_class_sessions */
export type StudentClassSessionsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type StudentClassSessionsPrependInput = {
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "student_class_sessions" */
export enum StudentClassSessionsSelectColumn {
  /** column name */
  BreakoutRoom = 'breakoutRoom',
  /** column name */
  ClassSessionId = 'classSessionId',
  /** column name */
  HasRaisedHand = 'hasRaisedHand',
  /** column name */
  Id = 'id',
  /** column name */
  IsCameraOn = 'isCameraOn',
  /** column name */
  IsDisputed = 'isDisputed',
  /** column name */
  IsMicOn = 'isMicOn',
  /** column name */
  IsTrial = 'isTrial',
  /** column name */
  JoinedAt = 'joinedAt',
  /** column name */
  LeftAt = 'leftAt',
  /** column name */
  Sdp = 'sdp',
  /** column name */
  SignedBy = 'signedBy',
  /** column name */
  StudentId = 'studentId',
  /** column name */
  StudentPaid = 'studentPaid'
}

/** select "student_class_sessions_aggregate_bool_exp_bool_and_arguments_columns" columns of table "student_class_sessions" */
export enum StudentClassSessionsSelectColumnStudentClassSessionsAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  HasRaisedHand = 'hasRaisedHand',
  /** column name */
  IsCameraOn = 'isCameraOn',
  /** column name */
  IsDisputed = 'isDisputed',
  /** column name */
  IsMicOn = 'isMicOn',
  /** column name */
  IsTrial = 'isTrial',
  /** column name */
  StudentPaid = 'studentPaid'
}

/** select "student_class_sessions_aggregate_bool_exp_bool_or_arguments_columns" columns of table "student_class_sessions" */
export enum StudentClassSessionsSelectColumnStudentClassSessionsAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  HasRaisedHand = 'hasRaisedHand',
  /** column name */
  IsCameraOn = 'isCameraOn',
  /** column name */
  IsDisputed = 'isDisputed',
  /** column name */
  IsMicOn = 'isMicOn',
  /** column name */
  IsTrial = 'isTrial',
  /** column name */
  StudentPaid = 'studentPaid'
}

/** input type for updating data in table "student_class_sessions" */
export type StudentClassSessionsSetInput = {
  breakoutRoom?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  hasRaisedHand?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCameraOn?: InputMaybe<Scalars['Boolean']['input']>;
  isDisputed?: InputMaybe<Scalars['Boolean']['input']>;
  isMicOn?: InputMaybe<Scalars['Boolean']['input']>;
  isTrial?: InputMaybe<Scalars['Boolean']['input']>;
  joinedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  leftAt?: InputMaybe<Scalars['timestamptz']['input']>;
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
  signedBy?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  studentPaid?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate stddev on columns */
export type StudentClassSessionsStddevFields = {
  __typename?: 'student_class_sessions_stddev_fields';
  breakoutRoom?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  signedBy?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "student_class_sessions" */
export type StudentClassSessionsStddevOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StudentClassSessionsStddevPopFields = {
  __typename?: 'student_class_sessions_stddev_pop_fields';
  breakoutRoom?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  signedBy?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "student_class_sessions" */
export type StudentClassSessionsStddevPopOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StudentClassSessionsStddevSampFields = {
  __typename?: 'student_class_sessions_stddev_samp_fields';
  breakoutRoom?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  signedBy?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "student_class_sessions" */
export type StudentClassSessionsStddevSampOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "student_class_sessions" */
export type StudentClassSessionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StudentClassSessionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StudentClassSessionsStreamCursorValueInput = {
  breakoutRoom?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  hasRaisedHand?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCameraOn?: InputMaybe<Scalars['Boolean']['input']>;
  isDisputed?: InputMaybe<Scalars['Boolean']['input']>;
  isMicOn?: InputMaybe<Scalars['Boolean']['input']>;
  isTrial?: InputMaybe<Scalars['Boolean']['input']>;
  joinedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  leftAt?: InputMaybe<Scalars['timestamptz']['input']>;
  sdp?: InputMaybe<Scalars['jsonb']['input']>;
  signedBy?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  studentPaid?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate sum on columns */
export type StudentClassSessionsSumFields = {
  __typename?: 'student_class_sessions_sum_fields';
  breakoutRoom?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  signedBy?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "student_class_sessions" */
export type StudentClassSessionsSumOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** update columns of table "student_class_sessions" */
export enum StudentClassSessionsUpdateColumn {
  /** column name */
  BreakoutRoom = 'breakoutRoom',
  /** column name */
  ClassSessionId = 'classSessionId',
  /** column name */
  HasRaisedHand = 'hasRaisedHand',
  /** column name */
  Id = 'id',
  /** column name */
  IsCameraOn = 'isCameraOn',
  /** column name */
  IsDisputed = 'isDisputed',
  /** column name */
  IsMicOn = 'isMicOn',
  /** column name */
  IsTrial = 'isTrial',
  /** column name */
  JoinedAt = 'joinedAt',
  /** column name */
  LeftAt = 'leftAt',
  /** column name */
  Sdp = 'sdp',
  /** column name */
  SignedBy = 'signedBy',
  /** column name */
  StudentId = 'studentId',
  /** column name */
  StudentPaid = 'studentPaid'
}

export type StudentClassSessionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<StudentClassSessionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<StudentClassSessionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<StudentClassSessionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<StudentClassSessionsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StudentClassSessionsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<StudentClassSessionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StudentClassSessionsSetInput>;
  /** filter the rows which have to be updated */
  where: StudentClassSessionsBoolExp;
};

/** aggregate var_pop on columns */
export type StudentClassSessionsVarPopFields = {
  __typename?: 'student_class_sessions_var_pop_fields';
  breakoutRoom?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  signedBy?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "student_class_sessions" */
export type StudentClassSessionsVarPopOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StudentClassSessionsVarSampFields = {
  __typename?: 'student_class_sessions_var_samp_fields';
  breakoutRoom?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  signedBy?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "student_class_sessions" */
export type StudentClassSessionsVarSampOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StudentClassSessionsVarianceFields = {
  __typename?: 'student_class_sessions_variance_fields';
  breakoutRoom?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  signedBy?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "student_class_sessions" */
export type StudentClassSessionsVarianceOrderBy = {
  breakoutRoom?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  signedBy?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "student_classes" */
export type StudentClasses = {
  __typename?: 'student_classes';
  /** An object relationship */
  class: Classes;
  classId: Scalars['Int']['output'];
  studentId: Scalars['Int']['output'];
  /** An object relationship */
  user: Users;
};

/** aggregated selection of "student_classes" */
export type StudentClassesAggregate = {
  __typename?: 'student_classes_aggregate';
  aggregate?: Maybe<StudentClassesAggregateFields>;
  nodes: Array<StudentClasses>;
};

export type StudentClassesAggregateBoolExp = {
  count?: InputMaybe<StudentClassesAggregateBoolExpCount>;
};

export type StudentClassesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StudentClassesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<StudentClassesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "student_classes" */
export type StudentClassesAggregateFields = {
  __typename?: 'student_classes_aggregate_fields';
  avg?: Maybe<StudentClassesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<StudentClassesMaxFields>;
  min?: Maybe<StudentClassesMinFields>;
  stddev?: Maybe<StudentClassesStddevFields>;
  stddev_pop?: Maybe<StudentClassesStddevPopFields>;
  stddev_samp?: Maybe<StudentClassesStddevSampFields>;
  sum?: Maybe<StudentClassesSumFields>;
  var_pop?: Maybe<StudentClassesVarPopFields>;
  var_samp?: Maybe<StudentClassesVarSampFields>;
  variance?: Maybe<StudentClassesVarianceFields>;
};


/** aggregate fields of "student_classes" */
export type StudentClassesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StudentClassesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "student_classes" */
export type StudentClassesAggregateOrderBy = {
  avg?: InputMaybe<StudentClassesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StudentClassesMaxOrderBy>;
  min?: InputMaybe<StudentClassesMinOrderBy>;
  stddev?: InputMaybe<StudentClassesStddevOrderBy>;
  stddev_pop?: InputMaybe<StudentClassesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StudentClassesStddevSampOrderBy>;
  sum?: InputMaybe<StudentClassesSumOrderBy>;
  var_pop?: InputMaybe<StudentClassesVarPopOrderBy>;
  var_samp?: InputMaybe<StudentClassesVarSampOrderBy>;
  variance?: InputMaybe<StudentClassesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "student_classes" */
export type StudentClassesArrRelInsertInput = {
  data: Array<StudentClassesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StudentClassesOnConflict>;
};

/** aggregate avg on columns */
export type StudentClassesAvgFields = {
  __typename?: 'student_classes_avg_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "student_classes" */
export type StudentClassesAvgOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "student_classes". All fields are combined with a logical 'AND'. */
export type StudentClassesBoolExp = {
  _and?: InputMaybe<Array<StudentClassesBoolExp>>;
  _not?: InputMaybe<StudentClassesBoolExp>;
  _or?: InputMaybe<Array<StudentClassesBoolExp>>;
  class?: InputMaybe<ClassesBoolExp>;
  classId?: InputMaybe<IntComparisonExp>;
  studentId?: InputMaybe<IntComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "student_classes" */
export enum StudentClassesConstraint {
  /** unique or primary key constraint on columns "student_id", "class_id" */
  StudentClassesPkey = 'student_classes_pkey'
}

/** input type for incrementing numeric columns in table "student_classes" */
export type StudentClassesIncInput = {
  classId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "student_classes" */
export type StudentClassesInsertInput = {
  class?: InputMaybe<ClassesObjRelInsertInput>;
  classId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type StudentClassesMaxFields = {
  __typename?: 'student_classes_max_fields';
  classId?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "student_classes" */
export type StudentClassesMaxOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StudentClassesMinFields = {
  __typename?: 'student_classes_min_fields';
  classId?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "student_classes" */
export type StudentClassesMinOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "student_classes" */
export type StudentClassesMutationResponse = {
  __typename?: 'student_classes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<StudentClasses>;
};

/** on_conflict condition type for table "student_classes" */
export type StudentClassesOnConflict = {
  constraint: StudentClassesConstraint;
  update_columns?: Array<StudentClassesUpdateColumn>;
  where?: InputMaybe<StudentClassesBoolExp>;
};

/** Ordering options when selecting data from "student_classes". */
export type StudentClassesOrderBy = {
  class?: InputMaybe<ClassesOrderBy>;
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: student_classes */
export type StudentClassesPkColumnsInput = {
  classId: Scalars['Int']['input'];
  studentId: Scalars['Int']['input'];
};

/** select columns of table "student_classes" */
export enum StudentClassesSelectColumn {
  /** column name */
  ClassId = 'classId',
  /** column name */
  StudentId = 'studentId'
}

/** input type for updating data in table "student_classes" */
export type StudentClassesSetInput = {
  classId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type StudentClassesStddevFields = {
  __typename?: 'student_classes_stddev_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "student_classes" */
export type StudentClassesStddevOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StudentClassesStddevPopFields = {
  __typename?: 'student_classes_stddev_pop_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "student_classes" */
export type StudentClassesStddevPopOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StudentClassesStddevSampFields = {
  __typename?: 'student_classes_stddev_samp_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "student_classes" */
export type StudentClassesStddevSampOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "student_classes" */
export type StudentClassesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StudentClassesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StudentClassesStreamCursorValueInput = {
  classId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type StudentClassesSumFields = {
  __typename?: 'student_classes_sum_fields';
  classId?: Maybe<Scalars['Int']['output']>;
  studentId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "student_classes" */
export type StudentClassesSumOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** update columns of table "student_classes" */
export enum StudentClassesUpdateColumn {
  /** column name */
  ClassId = 'classId',
  /** column name */
  StudentId = 'studentId'
}

export type StudentClassesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StudentClassesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StudentClassesSetInput>;
  /** filter the rows which have to be updated */
  where: StudentClassesBoolExp;
};

/** aggregate var_pop on columns */
export type StudentClassesVarPopFields = {
  __typename?: 'student_classes_var_pop_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "student_classes" */
export type StudentClassesVarPopOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StudentClassesVarSampFields = {
  __typename?: 'student_classes_var_samp_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "student_classes" */
export type StudentClassesVarSampOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StudentClassesVarianceFields = {
  __typename?: 'student_classes_variance_fields';
  classId?: Maybe<Scalars['Float']['output']>;
  studentId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "student_classes" */
export type StudentClassesVarianceOrderBy = {
  classId?: InputMaybe<OrderBy>;
  studentId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "student_favorite_teachers" */
export type StudentFavoriteTeachers = {
  __typename?: 'student_favorite_teachers';
  studentId: Scalars['Int']['output'];
  teacherId: Scalars['Int']['output'];
};

/** aggregated selection of "student_favorite_teachers" */
export type StudentFavoriteTeachersAggregate = {
  __typename?: 'student_favorite_teachers_aggregate';
  aggregate?: Maybe<StudentFavoriteTeachersAggregateFields>;
  nodes: Array<StudentFavoriteTeachers>;
};

/** aggregate fields of "student_favorite_teachers" */
export type StudentFavoriteTeachersAggregateFields = {
  __typename?: 'student_favorite_teachers_aggregate_fields';
  avg?: Maybe<StudentFavoriteTeachersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<StudentFavoriteTeachersMaxFields>;
  min?: Maybe<StudentFavoriteTeachersMinFields>;
  stddev?: Maybe<StudentFavoriteTeachersStddevFields>;
  stddev_pop?: Maybe<StudentFavoriteTeachersStddevPopFields>;
  stddev_samp?: Maybe<StudentFavoriteTeachersStddevSampFields>;
  sum?: Maybe<StudentFavoriteTeachersSumFields>;
  var_pop?: Maybe<StudentFavoriteTeachersVarPopFields>;
  var_samp?: Maybe<StudentFavoriteTeachersVarSampFields>;
  variance?: Maybe<StudentFavoriteTeachersVarianceFields>;
};


/** aggregate fields of "student_favorite_teachers" */
export type StudentFavoriteTeachersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StudentFavoriteTeachersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StudentFavoriteTeachersAvgFields = {
  __typename?: 'student_favorite_teachers_avg_fields';
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "student_favorite_teachers". All fields are combined with a logical 'AND'. */
export type StudentFavoriteTeachersBoolExp = {
  _and?: InputMaybe<Array<StudentFavoriteTeachersBoolExp>>;
  _not?: InputMaybe<StudentFavoriteTeachersBoolExp>;
  _or?: InputMaybe<Array<StudentFavoriteTeachersBoolExp>>;
  studentId?: InputMaybe<IntComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "student_favorite_teachers" */
export enum StudentFavoriteTeachersConstraint {
  /** unique or primary key constraint on columns "teacher_id", "student_id" */
  StudentFavoriteTeachersPkey = 'student_favorite_teachers_pkey'
}

/** input type for incrementing numeric columns in table "student_favorite_teachers" */
export type StudentFavoriteTeachersIncInput = {
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "student_favorite_teachers" */
export type StudentFavoriteTeachersInsertInput = {
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type StudentFavoriteTeachersMaxFields = {
  __typename?: 'student_favorite_teachers_max_fields';
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type StudentFavoriteTeachersMinFields = {
  __typename?: 'student_favorite_teachers_min_fields';
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "student_favorite_teachers" */
export type StudentFavoriteTeachersMutationResponse = {
  __typename?: 'student_favorite_teachers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<StudentFavoriteTeachers>;
};

/** on_conflict condition type for table "student_favorite_teachers" */
export type StudentFavoriteTeachersOnConflict = {
  constraint: StudentFavoriteTeachersConstraint;
  update_columns?: Array<StudentFavoriteTeachersUpdateColumn>;
  where?: InputMaybe<StudentFavoriteTeachersBoolExp>;
};

/** Ordering options when selecting data from "student_favorite_teachers". */
export type StudentFavoriteTeachersOrderBy = {
  studentId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: student_favorite_teachers */
export type StudentFavoriteTeachersPkColumnsInput = {
  studentId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};

/** select columns of table "student_favorite_teachers" */
export enum StudentFavoriteTeachersSelectColumn {
  /** column name */
  StudentId = 'studentId',
  /** column name */
  TeacherId = 'teacherId'
}

/** input type for updating data in table "student_favorite_teachers" */
export type StudentFavoriteTeachersSetInput = {
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type StudentFavoriteTeachersStddevFields = {
  __typename?: 'student_favorite_teachers_stddev_fields';
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StudentFavoriteTeachersStddevPopFields = {
  __typename?: 'student_favorite_teachers_stddev_pop_fields';
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StudentFavoriteTeachersStddevSampFields = {
  __typename?: 'student_favorite_teachers_stddev_samp_fields';
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "student_favorite_teachers" */
export type StudentFavoriteTeachersStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StudentFavoriteTeachersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StudentFavoriteTeachersStreamCursorValueInput = {
  studentId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type StudentFavoriteTeachersSumFields = {
  __typename?: 'student_favorite_teachers_sum_fields';
  studentId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "student_favorite_teachers" */
export enum StudentFavoriteTeachersUpdateColumn {
  /** column name */
  StudentId = 'studentId',
  /** column name */
  TeacherId = 'teacherId'
}

export type StudentFavoriteTeachersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StudentFavoriteTeachersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StudentFavoriteTeachersSetInput>;
  /** filter the rows which have to be updated */
  where: StudentFavoriteTeachersBoolExp;
};

/** aggregate var_pop on columns */
export type StudentFavoriteTeachersVarPopFields = {
  __typename?: 'student_favorite_teachers_var_pop_fields';
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StudentFavoriteTeachersVarSampFields = {
  __typename?: 'student_favorite_teachers_var_samp_fields';
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StudentFavoriteTeachersVarianceFields = {
  __typename?: 'student_favorite_teachers_variance_fields';
  studentId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "student_live_class_activities" */
export type StudentLiveClassActivities = {
  __typename?: 'student_live_class_activities';
  createdAt: Scalars['timestamptz']['output'];
  data?: Maybe<Scalars['jsonb']['output']>;
  id: Scalars['Int']['output'];
  lastSeen?: Maybe<Scalars['timestamptz']['output']>;
  listeningAndTranscriptKey?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  liveClassActivity: LiveClassActivities;
  liveClassActivitySetId: Scalars['Int']['output'];
  recordingCorrection?: Maybe<Scalars['String']['output']>;
  studentAnswerSDP?: Maybe<Scalars['jsonb']['output']>;
  teacherOfferSDP?: Maybe<Scalars['jsonb']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['Int']['output'];
  whiteboardApproved?: Maybe<Scalars['Boolean']['output']>;
  whiteboardKey?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "student_live_class_activities" */
export type StudentLiveClassActivitiesDataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "student_live_class_activities" */
export type StudentLiveClassActivitiesStudentAnswerSdpArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "student_live_class_activities" */
export type StudentLiveClassActivitiesTeacherOfferSdpArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "student_live_class_activities" */
export type StudentLiveClassActivitiesAggregate = {
  __typename?: 'student_live_class_activities_aggregate';
  aggregate?: Maybe<StudentLiveClassActivitiesAggregateFields>;
  nodes: Array<StudentLiveClassActivities>;
};

export type StudentLiveClassActivitiesAggregateBoolExp = {
  bool_and?: InputMaybe<StudentLiveClassActivitiesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<StudentLiveClassActivitiesAggregateBoolExpBoolOr>;
  count?: InputMaybe<StudentLiveClassActivitiesAggregateBoolExpCount>;
};

export type StudentLiveClassActivitiesAggregateBoolExpBoolAnd = {
  arguments: StudentLiveClassActivitiesSelectColumnStudentLiveClassActivitiesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type StudentLiveClassActivitiesAggregateBoolExpBoolOr = {
  arguments: StudentLiveClassActivitiesSelectColumnStudentLiveClassActivitiesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type StudentLiveClassActivitiesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StudentLiveClassActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "student_live_class_activities" */
export type StudentLiveClassActivitiesAggregateFields = {
  __typename?: 'student_live_class_activities_aggregate_fields';
  avg?: Maybe<StudentLiveClassActivitiesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<StudentLiveClassActivitiesMaxFields>;
  min?: Maybe<StudentLiveClassActivitiesMinFields>;
  stddev?: Maybe<StudentLiveClassActivitiesStddevFields>;
  stddev_pop?: Maybe<StudentLiveClassActivitiesStddevPopFields>;
  stddev_samp?: Maybe<StudentLiveClassActivitiesStddevSampFields>;
  sum?: Maybe<StudentLiveClassActivitiesSumFields>;
  var_pop?: Maybe<StudentLiveClassActivitiesVarPopFields>;
  var_samp?: Maybe<StudentLiveClassActivitiesVarSampFields>;
  variance?: Maybe<StudentLiveClassActivitiesVarianceFields>;
};


/** aggregate fields of "student_live_class_activities" */
export type StudentLiveClassActivitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StudentLiveClassActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "student_live_class_activities" */
export type StudentLiveClassActivitiesAggregateOrderBy = {
  avg?: InputMaybe<StudentLiveClassActivitiesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StudentLiveClassActivitiesMaxOrderBy>;
  min?: InputMaybe<StudentLiveClassActivitiesMinOrderBy>;
  stddev?: InputMaybe<StudentLiveClassActivitiesStddevOrderBy>;
  stddev_pop?: InputMaybe<StudentLiveClassActivitiesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StudentLiveClassActivitiesStddevSampOrderBy>;
  sum?: InputMaybe<StudentLiveClassActivitiesSumOrderBy>;
  var_pop?: InputMaybe<StudentLiveClassActivitiesVarPopOrderBy>;
  var_samp?: InputMaybe<StudentLiveClassActivitiesVarSampOrderBy>;
  variance?: InputMaybe<StudentLiveClassActivitiesVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type StudentLiveClassActivitiesAppendInput = {
  data?: InputMaybe<Scalars['jsonb']['input']>;
  studentAnswerSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherOfferSDP?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "student_live_class_activities" */
export type StudentLiveClassActivitiesArrRelInsertInput = {
  data: Array<StudentLiveClassActivitiesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StudentLiveClassActivitiesOnConflict>;
};

/** aggregate avg on columns */
export type StudentLiveClassActivitiesAvgFields = {
  __typename?: 'student_live_class_activities_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "student_live_class_activities". All fields are combined with a logical 'AND'. */
export type StudentLiveClassActivitiesBoolExp = {
  _and?: InputMaybe<Array<StudentLiveClassActivitiesBoolExp>>;
  _not?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
  _or?: InputMaybe<Array<StudentLiveClassActivitiesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  data?: InputMaybe<JsonbComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  lastSeen?: InputMaybe<TimestamptzComparisonExp>;
  listeningAndTranscriptKey?: InputMaybe<StringComparisonExp>;
  liveClassActivity?: InputMaybe<LiveClassActivitiesBoolExp>;
  liveClassActivitySetId?: InputMaybe<IntComparisonExp>;
  recordingCorrection?: InputMaybe<StringComparisonExp>;
  studentAnswerSDP?: InputMaybe<JsonbComparisonExp>;
  teacherOfferSDP?: InputMaybe<JsonbComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<IntComparisonExp>;
  whiteboardApproved?: InputMaybe<BooleanComparisonExp>;
  whiteboardKey?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "student_live_class_activities" */
export enum StudentLiveClassActivitiesConstraint {
  /** unique or primary key constraint on columns "id" */
  StudentLiveClassActivitiesPkey = 'student_live_class_activities_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type StudentLiveClassActivitiesDeleteAtPathInput = {
  data?: InputMaybe<Array<Scalars['String']['input']>>;
  studentAnswerSDP?: InputMaybe<Array<Scalars['String']['input']>>;
  teacherOfferSDP?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type StudentLiveClassActivitiesDeleteElemInput = {
  data?: InputMaybe<Scalars['Int']['input']>;
  studentAnswerSDP?: InputMaybe<Scalars['Int']['input']>;
  teacherOfferSDP?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type StudentLiveClassActivitiesDeleteKeyInput = {
  data?: InputMaybe<Scalars['String']['input']>;
  studentAnswerSDP?: InputMaybe<Scalars['String']['input']>;
  teacherOfferSDP?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "student_live_class_activities" */
export type StudentLiveClassActivitiesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  liveClassActivitySetId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "student_live_class_activities" */
export type StudentLiveClassActivitiesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastSeen?: InputMaybe<Scalars['timestamptz']['input']>;
  listeningAndTranscriptKey?: InputMaybe<Scalars['String']['input']>;
  liveClassActivity?: InputMaybe<LiveClassActivitiesObjRelInsertInput>;
  liveClassActivitySetId?: InputMaybe<Scalars['Int']['input']>;
  recordingCorrection?: InputMaybe<Scalars['String']['input']>;
  studentAnswerSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherOfferSDP?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  whiteboardApproved?: InputMaybe<Scalars['Boolean']['input']>;
  whiteboardKey?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StudentLiveClassActivitiesMaxFields = {
  __typename?: 'student_live_class_activities_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  lastSeen?: Maybe<Scalars['timestamptz']['output']>;
  listeningAndTranscriptKey?: Maybe<Scalars['String']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Int']['output']>;
  recordingCorrection?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  whiteboardKey?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastSeen?: InputMaybe<OrderBy>;
  listeningAndTranscriptKey?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  recordingCorrection?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  whiteboardKey?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StudentLiveClassActivitiesMinFields = {
  __typename?: 'student_live_class_activities_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  lastSeen?: Maybe<Scalars['timestamptz']['output']>;
  listeningAndTranscriptKey?: Maybe<Scalars['String']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Int']['output']>;
  recordingCorrection?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  whiteboardKey?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastSeen?: InputMaybe<OrderBy>;
  listeningAndTranscriptKey?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  recordingCorrection?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  whiteboardKey?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "student_live_class_activities" */
export type StudentLiveClassActivitiesMutationResponse = {
  __typename?: 'student_live_class_activities_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<StudentLiveClassActivities>;
};

/** on_conflict condition type for table "student_live_class_activities" */
export type StudentLiveClassActivitiesOnConflict = {
  constraint: StudentLiveClassActivitiesConstraint;
  update_columns?: Array<StudentLiveClassActivitiesUpdateColumn>;
  where?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
};

/** Ordering options when selecting data from "student_live_class_activities". */
export type StudentLiveClassActivitiesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  data?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastSeen?: InputMaybe<OrderBy>;
  listeningAndTranscriptKey?: InputMaybe<OrderBy>;
  liveClassActivity?: InputMaybe<LiveClassActivitiesOrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  recordingCorrection?: InputMaybe<OrderBy>;
  studentAnswerSDP?: InputMaybe<OrderBy>;
  teacherOfferSDP?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  whiteboardApproved?: InputMaybe<OrderBy>;
  whiteboardKey?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: student_live_class_activities */
export type StudentLiveClassActivitiesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type StudentLiveClassActivitiesPrependInput = {
  data?: InputMaybe<Scalars['jsonb']['input']>;
  studentAnswerSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherOfferSDP?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "student_live_class_activities" */
export enum StudentLiveClassActivitiesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  ListeningAndTranscriptKey = 'listeningAndTranscriptKey',
  /** column name */
  LiveClassActivitySetId = 'liveClassActivitySetId',
  /** column name */
  RecordingCorrection = 'recordingCorrection',
  /** column name */
  StudentAnswerSdp = 'studentAnswerSDP',
  /** column name */
  TeacherOfferSdp = 'teacherOfferSDP',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  WhiteboardApproved = 'whiteboardApproved',
  /** column name */
  WhiteboardKey = 'whiteboardKey'
}

/** select "student_live_class_activities_aggregate_bool_exp_bool_and_arguments_columns" columns of table "student_live_class_activities" */
export enum StudentLiveClassActivitiesSelectColumnStudentLiveClassActivitiesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  WhiteboardApproved = 'whiteboardApproved'
}

/** select "student_live_class_activities_aggregate_bool_exp_bool_or_arguments_columns" columns of table "student_live_class_activities" */
export enum StudentLiveClassActivitiesSelectColumnStudentLiveClassActivitiesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  WhiteboardApproved = 'whiteboardApproved'
}

/** input type for updating data in table "student_live_class_activities" */
export type StudentLiveClassActivitiesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastSeen?: InputMaybe<Scalars['timestamptz']['input']>;
  listeningAndTranscriptKey?: InputMaybe<Scalars['String']['input']>;
  liveClassActivitySetId?: InputMaybe<Scalars['Int']['input']>;
  recordingCorrection?: InputMaybe<Scalars['String']['input']>;
  studentAnswerSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherOfferSDP?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  whiteboardApproved?: InputMaybe<Scalars['Boolean']['input']>;
  whiteboardKey?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StudentLiveClassActivitiesStddevFields = {
  __typename?: 'student_live_class_activities_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StudentLiveClassActivitiesStddevPopFields = {
  __typename?: 'student_live_class_activities_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StudentLiveClassActivitiesStddevSampFields = {
  __typename?: 'student_live_class_activities_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "student_live_class_activities" */
export type StudentLiveClassActivitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StudentLiveClassActivitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StudentLiveClassActivitiesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  data?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastSeen?: InputMaybe<Scalars['timestamptz']['input']>;
  listeningAndTranscriptKey?: InputMaybe<Scalars['String']['input']>;
  liveClassActivitySetId?: InputMaybe<Scalars['Int']['input']>;
  recordingCorrection?: InputMaybe<Scalars['String']['input']>;
  studentAnswerSDP?: InputMaybe<Scalars['jsonb']['input']>;
  teacherOfferSDP?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  whiteboardApproved?: InputMaybe<Scalars['Boolean']['input']>;
  whiteboardKey?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StudentLiveClassActivitiesSumFields = {
  __typename?: 'student_live_class_activities_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** update columns of table "student_live_class_activities" */
export enum StudentLiveClassActivitiesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  ListeningAndTranscriptKey = 'listeningAndTranscriptKey',
  /** column name */
  LiveClassActivitySetId = 'liveClassActivitySetId',
  /** column name */
  RecordingCorrection = 'recordingCorrection',
  /** column name */
  StudentAnswerSdp = 'studentAnswerSDP',
  /** column name */
  TeacherOfferSdp = 'teacherOfferSDP',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  WhiteboardApproved = 'whiteboardApproved',
  /** column name */
  WhiteboardKey = 'whiteboardKey'
}

export type StudentLiveClassActivitiesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<StudentLiveClassActivitiesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<StudentLiveClassActivitiesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<StudentLiveClassActivitiesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<StudentLiveClassActivitiesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StudentLiveClassActivitiesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<StudentLiveClassActivitiesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StudentLiveClassActivitiesSetInput>;
  /** filter the rows which have to be updated */
  where: StudentLiveClassActivitiesBoolExp;
};

/** aggregate var_pop on columns */
export type StudentLiveClassActivitiesVarPopFields = {
  __typename?: 'student_live_class_activities_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StudentLiveClassActivitiesVarSampFields = {
  __typename?: 'student_live_class_activities_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StudentLiveClassActivitiesVarianceFields = {
  __typename?: 'student_live_class_activities_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  liveClassActivitySetId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "student_live_class_activities" */
export type StudentLiveClassActivitiesVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  liveClassActivitySetId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "subjects" */
export type Subjects = {
  __typename?: 'subjects';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  image?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  language?: Maybe<Languages>;
  languageId?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  order?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  teacherSubjects: Array<TeacherSubjects>;
  /** An aggregate relationship */
  teacherSubjects_aggregate: TeacherSubjectsAggregate;
  updated_by?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "subjects" */
export type SubjectsTeacherSubjectsArgs = {
  distinct_on?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherSubjectsOrderBy>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};


/** columns and relationships of "subjects" */
export type SubjectsTeacherSubjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherSubjectsOrderBy>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};

/** aggregated selection of "subjects" */
export type SubjectsAggregate = {
  __typename?: 'subjects_aggregate';
  aggregate?: Maybe<SubjectsAggregateFields>;
  nodes: Array<Subjects>;
};

/** aggregate fields of "subjects" */
export type SubjectsAggregateFields = {
  __typename?: 'subjects_aggregate_fields';
  avg?: Maybe<SubjectsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<SubjectsMaxFields>;
  min?: Maybe<SubjectsMinFields>;
  stddev?: Maybe<SubjectsStddevFields>;
  stddev_pop?: Maybe<SubjectsStddevPopFields>;
  stddev_samp?: Maybe<SubjectsStddevSampFields>;
  sum?: Maybe<SubjectsSumFields>;
  var_pop?: Maybe<SubjectsVarPopFields>;
  var_samp?: Maybe<SubjectsVarSampFields>;
  variance?: Maybe<SubjectsVarianceFields>;
};


/** aggregate fields of "subjects" */
export type SubjectsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SubjectsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type SubjectsAvgFields = {
  __typename?: 'subjects_avg_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  updated_by?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "subjects". All fields are combined with a logical 'AND'. */
export type SubjectsBoolExp = {
  _and?: InputMaybe<Array<SubjectsBoolExp>>;
  _not?: InputMaybe<SubjectsBoolExp>;
  _or?: InputMaybe<Array<SubjectsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  created_by?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  image?: InputMaybe<StringComparisonExp>;
  language?: InputMaybe<LanguagesBoolExp>;
  languageId?: InputMaybe<IntComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  teacherSubjects?: InputMaybe<TeacherSubjectsBoolExp>;
  teacherSubjects_aggregate?: InputMaybe<TeacherSubjectsAggregateBoolExp>;
  updated_by?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "subjects" */
export enum SubjectsConstraint {
  /** unique or primary key constraint on columns "name" */
  SubjectsNameKey = 'subjects_name_key',
  /** unique or primary key constraint on columns "id" */
  SubjectsPkey = 'subjects_pkey'
}

/** input type for incrementing numeric columns in table "subjects" */
export type SubjectsIncInput = {
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  updated_by?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "subjects" */
export type SubjectsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  language?: InputMaybe<LanguagesObjRelInsertInput>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  teacherSubjects?: InputMaybe<TeacherSubjectsArrRelInsertInput>;
  updated_by?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type SubjectsMaxFields = {
  __typename?: 'subjects_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  image?: Maybe<Scalars['String']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  updated_by?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type SubjectsMinFields = {
  __typename?: 'subjects_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  image?: Maybe<Scalars['String']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  updated_by?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "subjects" */
export type SubjectsMutationResponse = {
  __typename?: 'subjects_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Subjects>;
};

/** input type for inserting object relation for remote table "subjects" */
export type SubjectsObjRelInsertInput = {
  data: SubjectsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<SubjectsOnConflict>;
};

/** on_conflict condition type for table "subjects" */
export type SubjectsOnConflict = {
  constraint: SubjectsConstraint;
  update_columns?: Array<SubjectsUpdateColumn>;
  where?: InputMaybe<SubjectsBoolExp>;
};

/** Ordering options when selecting data from "subjects". */
export type SubjectsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  image?: InputMaybe<OrderBy>;
  language?: InputMaybe<LanguagesOrderBy>;
  languageId?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  teacherSubjects_aggregate?: InputMaybe<TeacherSubjectsAggregateOrderBy>;
  updated_by?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: subjects */
export type SubjectsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "subjects" */
export enum SubjectsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Image = 'image',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "subjects" */
export type SubjectsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  updated_by?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type SubjectsStddevFields = {
  __typename?: 'subjects_stddev_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  updated_by?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type SubjectsStddevPopFields = {
  __typename?: 'subjects_stddev_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  updated_by?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type SubjectsStddevSampFields = {
  __typename?: 'subjects_stddev_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  updated_by?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "subjects" */
export type SubjectsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SubjectsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SubjectsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  updated_by?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type SubjectsSumFields = {
  __typename?: 'subjects_sum_fields';
  created_by?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  languageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  updated_by?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "subjects" */
export enum SubjectsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Image = 'image',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  Name = 'name',
  /** column name */
  Order = 'order',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type SubjectsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SubjectsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SubjectsSetInput>;
  /** filter the rows which have to be updated */
  where: SubjectsBoolExp;
};

/** aggregate var_pop on columns */
export type SubjectsVarPopFields = {
  __typename?: 'subjects_var_pop_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  updated_by?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type SubjectsVarSampFields = {
  __typename?: 'subjects_var_samp_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  updated_by?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type SubjectsVarianceFields = {
  __typename?: 'subjects_variance_fields';
  created_by?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  languageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  updated_by?: Maybe<Scalars['Float']['output']>;
};

export type SubscriptionRoot = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "activity_set_assignments" */
  activity_set_assignments: Array<ActivitySetAssignments>;
  /** fetch aggregated fields from the table: "activity_set_assignments" */
  activity_set_assignments_aggregate: ActivitySetAssignmentsAggregate;
  /** fetch data from the table: "activity_set_assignments" using primary key columns */
  activity_set_assignments_by_pk?: Maybe<ActivitySetAssignments>;
  /** fetch data from the table in a streaming manner: "activity_set_assignments" */
  activity_set_assignments_stream: Array<ActivitySetAssignments>;
  /** fetch data from the table: "activity_set_reports" */
  activity_set_reports: Array<ActivitySetReports>;
  /** fetch aggregated fields from the table: "activity_set_reports" */
  activity_set_reports_aggregate: ActivitySetReportsAggregate;
  /** fetch data from the table: "activity_set_reports" using primary key columns */
  activity_set_reports_by_pk?: Maybe<ActivitySetReports>;
  /** fetch data from the table in a streaming manner: "activity_set_reports" */
  activity_set_reports_stream: Array<ActivitySetReports>;
  /** fetch data from the table: "activity_set_responses" */
  activity_set_responses: Array<ActivitySetResponses>;
  /** fetch aggregated fields from the table: "activity_set_responses" */
  activity_set_responses_aggregate: ActivitySetResponsesAggregate;
  /** fetch data from the table: "activity_set_responses" using primary key columns */
  activity_set_responses_by_pk?: Maybe<ActivitySetResponses>;
  /** fetch data from the table in a streaming manner: "activity_set_responses" */
  activity_set_responses_stream: Array<ActivitySetResponses>;
  /** fetch data from the table: "activity_sets" */
  activity_sets: Array<ActivitySets>;
  /** fetch aggregated fields from the table: "activity_sets" */
  activity_sets_aggregate: ActivitySetsAggregate;
  /** fetch data from the table: "activity_sets" using primary key columns */
  activity_sets_by_pk?: Maybe<ActivitySets>;
  /** fetch data from the table in a streaming manner: "activity_sets" */
  activity_sets_stream: Array<ActivitySets>;
  /** An array relationship */
  addresses: Array<Addresses>;
  /** An aggregate relationship */
  addresses_aggregate: AddressesAggregate;
  /** fetch data from the table: "addresses" using primary key columns */
  addresses_by_pk?: Maybe<Addresses>;
  /** fetch data from the table in a streaming manner: "addresses" */
  addresses_stream: Array<Addresses>;
  /** fetch data from the table: "anagram_responses" */
  anagram_responses: Array<AnagramResponses>;
  /** fetch aggregated fields from the table: "anagram_responses" */
  anagram_responses_aggregate: AnagramResponsesAggregate;
  /** fetch data from the table: "anagram_responses" using primary key columns */
  anagram_responses_by_pk?: Maybe<AnagramResponses>;
  /** fetch data from the table in a streaming manner: "anagram_responses" */
  anagram_responses_stream: Array<AnagramResponses>;
  /** An array relationship */
  anagrams: Array<Anagrams>;
  /** An aggregate relationship */
  anagrams_aggregate: AnagramsAggregate;
  /** fetch data from the table: "anagrams" using primary key columns */
  anagrams_by_pk?: Maybe<Anagrams>;
  /** fetch data from the table in a streaming manner: "anagrams" */
  anagrams_stream: Array<Anagrams>;
  /** fetch data from the table: "annotations" */
  annotations: Array<Annotations>;
  /** fetch aggregated fields from the table: "annotations" */
  annotations_aggregate: AnnotationsAggregate;
  /** fetch data from the table: "annotations" using primary key columns */
  annotations_by_pk?: Maybe<Annotations>;
  /** fetch data from the table in a streaming manner: "annotations" */
  annotations_stream: Array<Annotations>;
  /** fetch data from the table: "application_reviews" */
  application_reviews: Array<ApplicationReviews>;
  /** fetch aggregated fields from the table: "application_reviews" */
  application_reviews_aggregate: ApplicationReviewsAggregate;
  /** fetch data from the table: "application_reviews" using primary key columns */
  application_reviews_by_pk?: Maybe<ApplicationReviews>;
  /** fetch data from the table in a streaming manner: "application_reviews" */
  application_reviews_stream: Array<ApplicationReviews>;
  /** fetch data from the table: "availability_times" */
  availability_times: Array<AvailabilityTimes>;
  /** fetch aggregated fields from the table: "availability_times" */
  availability_times_aggregate: AvailabilityTimesAggregate;
  /** fetch data from the table: "availability_times" using primary key columns */
  availability_times_by_pk?: Maybe<AvailabilityTimes>;
  /** fetch data from the table in a streaming manner: "availability_times" */
  availability_times_stream: Array<AvailabilityTimes>;
  /** fetch data from the table: "cefr_levels" */
  cefr_levels: Array<CefrLevels>;
  /** fetch aggregated fields from the table: "cefr_levels" */
  cefr_levels_aggregate: CefrLevelsAggregate;
  /** fetch data from the table: "cefr_levels" using primary key columns */
  cefr_levels_by_pk?: Maybe<CefrLevels>;
  /** fetch data from the table in a streaming manner: "cefr_levels" */
  cefr_levels_stream: Array<CefrLevels>;
  /** fetch data from the table: "class_activity_sets" */
  class_activity_sets: Array<ClassActivitySets>;
  /** fetch aggregated fields from the table: "class_activity_sets" */
  class_activity_sets_aggregate: ClassActivitySetsAggregate;
  /** fetch data from the table: "class_activity_sets" using primary key columns */
  class_activity_sets_by_pk?: Maybe<ClassActivitySets>;
  /** fetch data from the table in a streaming manner: "class_activity_sets" */
  class_activity_sets_stream: Array<ClassActivitySets>;
  /** fetch data from the table: "class_annotations" */
  class_annotations: Array<ClassAnnotations>;
  /** fetch aggregated fields from the table: "class_annotations" */
  class_annotations_aggregate: ClassAnnotationsAggregate;
  /** fetch data from the table: "class_annotations" using primary key columns */
  class_annotations_by_pk?: Maybe<ClassAnnotations>;
  /** fetch data from the table in a streaming manner: "class_annotations" */
  class_annotations_stream: Array<ClassAnnotations>;
  /** fetch data from the table: "class_courses" */
  class_courses: Array<ClassCourses>;
  /** fetch aggregated fields from the table: "class_courses" */
  class_courses_aggregate: ClassCoursesAggregate;
  /** fetch data from the table: "class_courses" using primary key columns */
  class_courses_by_pk?: Maybe<ClassCourses>;
  /** fetch data from the table in a streaming manner: "class_courses" */
  class_courses_stream: Array<ClassCourses>;
  /** fetch data from the table: "class_sessions" */
  class_sessions: Array<ClassSessions>;
  /** fetch aggregated fields from the table: "class_sessions" */
  class_sessions_aggregate: ClassSessionsAggregate;
  /** fetch data from the table: "class_sessions" using primary key columns */
  class_sessions_by_pk?: Maybe<ClassSessions>;
  /** fetch data from the table in a streaming manner: "class_sessions" */
  class_sessions_stream: Array<ClassSessions>;
  /** fetch data from the table: "class_slot_bookings" */
  class_slot_bookings: Array<ClassSlotBookings>;
  /** fetch aggregated fields from the table: "class_slot_bookings" */
  class_slot_bookings_aggregate: ClassSlotBookingsAggregate;
  /** fetch data from the table: "class_slot_bookings" using primary key columns */
  class_slot_bookings_by_pk?: Maybe<ClassSlotBookings>;
  /** fetch data from the table in a streaming manner: "class_slot_bookings" */
  class_slot_bookings_stream: Array<ClassSlotBookings>;
  /** fetch data from the table: "classes" */
  classes: Array<Classes>;
  /** fetch aggregated fields from the table: "classes" */
  classes_aggregate: ClassesAggregate;
  /** fetch data from the table: "classes" using primary key columns */
  classes_by_pk?: Maybe<Classes>;
  /** fetch data from the table in a streaming manner: "classes" */
  classes_stream: Array<Classes>;
  /** An array relationship */
  course_activities: Array<CourseActivities>;
  /** An aggregate relationship */
  course_activities_aggregate: CourseActivitiesAggregate;
  /** fetch data from the table: "course_activities" using primary key columns */
  course_activities_by_pk?: Maybe<CourseActivities>;
  /** fetch data from the table in a streaming manner: "course_activities" */
  course_activities_stream: Array<CourseActivities>;
  /** fetch data from the table: "course_reviews" */
  course_reviews: Array<CourseReviews>;
  /** fetch aggregated fields from the table: "course_reviews" */
  course_reviews_aggregate: CourseReviewsAggregate;
  /** fetch data from the table: "course_reviews" using primary key columns */
  course_reviews_by_pk?: Maybe<CourseReviews>;
  /** fetch data from the table in a streaming manner: "course_reviews" */
  course_reviews_stream: Array<CourseReviews>;
  /** fetch data from the table: "course_summary" */
  course_summary: Array<CourseSummary>;
  /** fetch aggregated fields from the table: "course_summary" */
  course_summary_aggregate: CourseSummaryAggregate;
  /** fetch data from the table in a streaming manner: "course_summary" */
  course_summary_stream: Array<CourseSummary>;
  /** fetch data from the table: "courses" */
  courses: Array<Courses>;
  /** fetch aggregated fields from the table: "courses" */
  courses_aggregate: CoursesAggregate;
  /** fetch data from the table: "courses" using primary key columns */
  courses_by_pk?: Maybe<Courses>;
  /** fetch data from the table in a streaming manner: "courses" */
  courses_stream: Array<Courses>;
  /** fetch data from the table: "daily_stats" */
  daily_stats: Array<DailyStats>;
  /** fetch aggregated fields from the table: "daily_stats" */
  daily_stats_aggregate: DailyStatsAggregate;
  /** fetch data from the table: "daily_stats" using primary key columns */
  daily_stats_by_pk?: Maybe<DailyStats>;
  /** fetch data from the table in a streaming manner: "daily_stats" */
  daily_stats_stream: Array<DailyStats>;
  /** fetch data from the table: "dictionaries" */
  dictionaries: Array<Dictionaries>;
  /** fetch aggregated fields from the table: "dictionaries" */
  dictionaries_aggregate: DictionariesAggregate;
  /** fetch data from the table: "dictionaries" using primary key columns */
  dictionaries_by_pk?: Maybe<Dictionaries>;
  /** fetch data from the table in a streaming manner: "dictionaries" */
  dictionaries_stream: Array<Dictionaries>;
  /** fetch data from the table: "emojis" */
  emojis: Array<Emojis>;
  /** fetch aggregated fields from the table: "emojis" */
  emojis_aggregate: EmojisAggregate;
  /** fetch data from the table: "emojis" using primary key columns */
  emojis_by_pk?: Maybe<Emojis>;
  /** fetch data from the table in a streaming manner: "emojis" */
  emojis_stream: Array<Emojis>;
  /** fetch data from the table: "employees" */
  employees: Array<Employees>;
  /** fetch aggregated fields from the table: "employees" */
  employees_aggregate: EmployeesAggregate;
  /** fetch data from the table: "employees" using primary key columns */
  employees_by_pk?: Maybe<Employees>;
  /** fetch data from the table in a streaming manner: "employees" */
  employees_stream: Array<Employees>;
  /** fetch data from the table: "example_joins" */
  example_joins: Array<ExampleJoins>;
  /** fetch aggregated fields from the table: "example_joins" */
  example_joins_aggregate: ExampleJoinsAggregate;
  /** fetch data from the table: "example_joins" using primary key columns */
  example_joins_by_pk?: Maybe<ExampleJoins>;
  /** fetch data from the table in a streaming manner: "example_joins" */
  example_joins_stream: Array<ExampleJoins>;
  /** fetch data from the table: "examples" */
  examples: Array<Examples>;
  /** fetch aggregated fields from the table: "examples" */
  examples_aggregate: ExamplesAggregate;
  /** fetch data from the table: "examples" using primary key columns */
  examples_by_pk?: Maybe<Examples>;
  /** fetch data from the table in a streaming manner: "examples" */
  examples_stream: Array<Examples>;
  /** fetch data from the table: "expired_refresh_tokens" */
  expired_refresh_tokens: Array<ExpiredRefreshTokens>;
  /** fetch aggregated fields from the table: "expired_refresh_tokens" */
  expired_refresh_tokens_aggregate: ExpiredRefreshTokensAggregate;
  /** fetch data from the table: "expired_refresh_tokens" using primary key columns */
  expired_refresh_tokens_by_pk?: Maybe<ExpiredRefreshTokens>;
  /** fetch data from the table in a streaming manner: "expired_refresh_tokens" */
  expired_refresh_tokens_stream: Array<ExpiredRefreshTokens>;
  /** fetch data from the table: "fill_in_the_blank_options" */
  fill_in_the_blank_options: Array<FillInTheBlankOptions>;
  /** fetch aggregated fields from the table: "fill_in_the_blank_options" */
  fill_in_the_blank_options_aggregate: FillInTheBlankOptionsAggregate;
  /** fetch data from the table: "fill_in_the_blank_options" using primary key columns */
  fill_in_the_blank_options_by_pk?: Maybe<FillInTheBlankOptions>;
  /** fetch data from the table in a streaming manner: "fill_in_the_blank_options" */
  fill_in_the_blank_options_stream: Array<FillInTheBlankOptions>;
  /** fetch data from the table: "fill_in_the_blank_responses" */
  fill_in_the_blank_responses: Array<FillInTheBlankResponses>;
  /** fetch aggregated fields from the table: "fill_in_the_blank_responses" */
  fill_in_the_blank_responses_aggregate: FillInTheBlankResponsesAggregate;
  /** fetch data from the table: "fill_in_the_blank_responses" using primary key columns */
  fill_in_the_blank_responses_by_pk?: Maybe<FillInTheBlankResponses>;
  /** fetch data from the table in a streaming manner: "fill_in_the_blank_responses" */
  fill_in_the_blank_responses_stream: Array<FillInTheBlankResponses>;
  /** fetch data from the table: "fill_in_the_blanks" */
  fill_in_the_blanks: Array<FillInTheBlanks>;
  /** fetch aggregated fields from the table: "fill_in_the_blanks" */
  fill_in_the_blanks_aggregate: FillInTheBlanksAggregate;
  /** fetch data from the table: "fill_in_the_blanks" using primary key columns */
  fill_in_the_blanks_by_pk?: Maybe<FillInTheBlanks>;
  /** fetch data from the table in a streaming manner: "fill_in_the_blanks" */
  fill_in_the_blanks_stream: Array<FillInTheBlanks>;
  /** fetch data from the table: "game_dailies" */
  game_dailies: Array<GameDailies>;
  /** fetch aggregated fields from the table: "game_dailies" */
  game_dailies_aggregate: GameDailiesAggregate;
  /** fetch data from the table: "game_dailies" using primary key columns */
  game_dailies_by_pk?: Maybe<GameDailies>;
  /** fetch data from the table in a streaming manner: "game_dailies" */
  game_dailies_stream: Array<GameDailies>;
  /** fetch data from the table: "game_difficulty" */
  game_difficulty: Array<GameDifficulty>;
  /** fetch aggregated fields from the table: "game_difficulty" */
  game_difficulty_aggregate: GameDifficultyAggregate;
  /** fetch data from the table: "game_difficulty" using primary key columns */
  game_difficulty_by_pk?: Maybe<GameDifficulty>;
  /** fetch data from the table in a streaming manner: "game_difficulty" */
  game_difficulty_stream: Array<GameDifficulty>;
  /** fetch data from the table: "game_types" */
  game_types: Array<GameTypes>;
  /** fetch aggregated fields from the table: "game_types" */
  game_types_aggregate: GameTypesAggregate;
  /** fetch data from the table: "game_types" using primary key columns */
  game_types_by_pk?: Maybe<GameTypes>;
  /** fetch data from the table in a streaming manner: "game_types" */
  game_types_stream: Array<GameTypes>;
  /** fetch data from the table: "game_users" */
  game_users: Array<GameUsers>;
  /** fetch aggregated fields from the table: "game_users" */
  game_users_aggregate: GameUsersAggregate;
  /** fetch data from the table: "game_users" using primary key columns */
  game_users_by_pk?: Maybe<GameUsers>;
  /** fetch data from the table in a streaming manner: "game_users" */
  game_users_stream: Array<GameUsers>;
  /** fetch data from the table: "games" */
  games: Array<Games>;
  /** fetch aggregated fields from the table: "games" */
  games_aggregate: GamesAggregate;
  /** fetch data from the table: "games" using primary key columns */
  games_by_pk?: Maybe<Games>;
  /** fetch data from the table in a streaming manner: "games" */
  games_stream: Array<Games>;
  /** execute function "get_random_poem" which returns "poems" */
  get_random_poem: Array<Poems>;
  /** execute function "get_random_poem" and query aggregates on result of table type "poems" */
  get_random_poem_aggregate: PoemsAggregate;
  /** execute function "get_user_words_count" which returns "user_words_count" */
  get_user_words_count: Array<UserWordsCount>;
  /** execute function "get_user_words_count" and query aggregates on result of table type "user_words_count" */
  get_user_words_count_aggregate: UserWordsCountAggregate;
  /** fetch data from the table: "goals" */
  goals: Array<Goals>;
  /** fetch aggregated fields from the table: "goals" */
  goals_aggregate: GoalsAggregate;
  /** fetch data from the table: "goals" using primary key columns */
  goals_by_pk?: Maybe<Goals>;
  /** fetch data from the table in a streaming manner: "goals" */
  goals_stream: Array<Goals>;
  /** fetch data from the table: "images" */
  images: Array<Images>;
  /** fetch aggregated fields from the table: "images" */
  images_aggregate: ImagesAggregate;
  /** fetch data from the table: "images" using primary key columns */
  images_by_pk?: Maybe<Images>;
  /** fetch data from the table in a streaming manner: "images" */
  images_stream: Array<Images>;
  /** fetch data from the table: "interests" */
  interests: Array<Interests>;
  /** fetch aggregated fields from the table: "interests" */
  interests_aggregate: InterestsAggregate;
  /** fetch data from the table: "interests" using primary key columns */
  interests_by_pk?: Maybe<Interests>;
  /** fetch data from the table in a streaming manner: "interests" */
  interests_stream: Array<Interests>;
  /** fetch data from the table: "languages" */
  languages: Array<Languages>;
  /** fetch aggregated fields from the table: "languages" */
  languages_aggregate: LanguagesAggregate;
  /** fetch data from the table: "languages" using primary key columns */
  languages_by_pk?: Maybe<Languages>;
  /** fetch data from the table in a streaming manner: "languages" */
  languages_stream: Array<Languages>;
  /** fetch data from the table: "listenings" */
  listenings: Array<Listenings>;
  /** fetch aggregated fields from the table: "listenings" */
  listenings_aggregate: ListeningsAggregate;
  /** fetch data from the table: "listenings" using primary key columns */
  listenings_by_pk?: Maybe<Listenings>;
  /** fetch data from the table in a streaming manner: "listenings" */
  listenings_stream: Array<Listenings>;
  /** fetch data from the table: "live_class_activities" */
  live_class_activities: Array<LiveClassActivities>;
  /** fetch aggregated fields from the table: "live_class_activities" */
  live_class_activities_aggregate: LiveClassActivitiesAggregate;
  /** fetch data from the table: "live_class_activities" using primary key columns */
  live_class_activities_by_pk?: Maybe<LiveClassActivities>;
  /** fetch data from the table in a streaming manner: "live_class_activities" */
  live_class_activities_stream: Array<LiveClassActivities>;
  /** fetch data from the table: "live_messages" */
  live_messages: Array<LiveMessages>;
  /** fetch aggregated fields from the table: "live_messages" */
  live_messages_aggregate: LiveMessagesAggregate;
  /** fetch data from the table: "live_messages" using primary key columns */
  live_messages_by_pk?: Maybe<LiveMessages>;
  /** fetch data from the table in a streaming manner: "live_messages" */
  live_messages_stream: Array<LiveMessages>;
  /** fetch data from the table: "matching_options" */
  matching_options: Array<MatchingOptions>;
  /** fetch aggregated fields from the table: "matching_options" */
  matching_options_aggregate: MatchingOptionsAggregate;
  /** fetch data from the table: "matching_options" using primary key columns */
  matching_options_by_pk?: Maybe<MatchingOptions>;
  /** fetch data from the table in a streaming manner: "matching_options" */
  matching_options_stream: Array<MatchingOptions>;
  /** fetch data from the table: "matching_responses" */
  matching_responses: Array<MatchingResponses>;
  /** fetch aggregated fields from the table: "matching_responses" */
  matching_responses_aggregate: MatchingResponsesAggregate;
  /** fetch data from the table: "matching_responses" using primary key columns */
  matching_responses_by_pk?: Maybe<MatchingResponses>;
  /** fetch data from the table in a streaming manner: "matching_responses" */
  matching_responses_stream: Array<MatchingResponses>;
  /** An array relationship */
  matchings: Array<Matchings>;
  /** An aggregate relationship */
  matchings_aggregate: MatchingsAggregate;
  /** fetch data from the table: "matchings" using primary key columns */
  matchings_by_pk?: Maybe<Matchings>;
  /** fetch data from the table in a streaming manner: "matchings" */
  matchings_stream: Array<Matchings>;
  /** An array relationship */
  messages: Array<Messages>;
  /** An aggregate relationship */
  messages_aggregate: MessagesAggregate;
  /** fetch data from the table: "messages" using primary key columns */
  messages_by_pk?: Maybe<Messages>;
  /** fetch data from the table in a streaming manner: "messages" */
  messages_stream: Array<Messages>;
  /** fetch data from the table: "multiple_choice_options" */
  multiple_choice_options: Array<MultipleChoiceOptions>;
  /** fetch aggregated fields from the table: "multiple_choice_options" */
  multiple_choice_options_aggregate: MultipleChoiceOptionsAggregate;
  /** fetch data from the table: "multiple_choice_options" using primary key columns */
  multiple_choice_options_by_pk?: Maybe<MultipleChoiceOptions>;
  /** fetch data from the table in a streaming manner: "multiple_choice_options" */
  multiple_choice_options_stream: Array<MultipleChoiceOptions>;
  /** fetch data from the table: "multiple_choice_responses" */
  multiple_choice_responses: Array<MultipleChoiceResponses>;
  /** fetch aggregated fields from the table: "multiple_choice_responses" */
  multiple_choice_responses_aggregate: MultipleChoiceResponsesAggregate;
  /** fetch data from the table: "multiple_choice_responses" using primary key columns */
  multiple_choice_responses_by_pk?: Maybe<MultipleChoiceResponses>;
  /** fetch data from the table in a streaming manner: "multiple_choice_responses" */
  multiple_choice_responses_stream: Array<MultipleChoiceResponses>;
  /** fetch data from the table: "multiple_choices" */
  multiple_choices: Array<MultipleChoices>;
  /** fetch aggregated fields from the table: "multiple_choices" */
  multiple_choices_aggregate: MultipleChoicesAggregate;
  /** fetch data from the table: "multiple_choices" using primary key columns */
  multiple_choices_by_pk?: Maybe<MultipleChoices>;
  /** fetch data from the table in a streaming manner: "multiple_choices" */
  multiple_choices_stream: Array<MultipleChoices>;
  /** fetch data from the table: "open_answer_responses" */
  open_answer_responses: Array<OpenAnswerResponses>;
  /** fetch aggregated fields from the table: "open_answer_responses" */
  open_answer_responses_aggregate: OpenAnswerResponsesAggregate;
  /** fetch data from the table: "open_answer_responses" using primary key columns */
  open_answer_responses_by_pk?: Maybe<OpenAnswerResponses>;
  /** fetch data from the table in a streaming manner: "open_answer_responses" */
  open_answer_responses_stream: Array<OpenAnswerResponses>;
  /** fetch data from the table: "open_answers" */
  open_answers: Array<OpenAnswers>;
  /** fetch aggregated fields from the table: "open_answers" */
  open_answers_aggregate: OpenAnswersAggregate;
  /** fetch data from the table: "open_answers" using primary key columns */
  open_answers_by_pk?: Maybe<OpenAnswers>;
  /** fetch data from the table in a streaming manner: "open_answers" */
  open_answers_stream: Array<OpenAnswers>;
  /** fetch data from the table: "parts_of_speech" */
  parts_of_speech: Array<PartsOfSpeech>;
  /** fetch aggregated fields from the table: "parts_of_speech" */
  parts_of_speech_aggregate: PartsOfSpeechAggregate;
  /** fetch data from the table: "parts_of_speech" using primary key columns */
  parts_of_speech_by_pk?: Maybe<PartsOfSpeech>;
  /** fetch data from the table in a streaming manner: "parts_of_speech" */
  parts_of_speech_stream: Array<PartsOfSpeech>;
  /** fetch data from the table: "payments" */
  payments: Array<Payments>;
  /** fetch aggregated fields from the table: "payments" */
  payments_aggregate: PaymentsAggregate;
  /** fetch data from the table: "payments" using primary key columns */
  payments_by_pk?: Maybe<Payments>;
  /** fetch data from the table in a streaming manner: "payments" */
  payments_stream: Array<Payments>;
  /** fetch data from the table: "phrase_responses" */
  phrase_responses: Array<PhraseResponses>;
  /** fetch aggregated fields from the table: "phrase_responses" */
  phrase_responses_aggregate: PhraseResponsesAggregate;
  /** fetch data from the table: "phrase_responses" using primary key columns */
  phrase_responses_by_pk?: Maybe<PhraseResponses>;
  /** fetch data from the table in a streaming manner: "phrase_responses" */
  phrase_responses_stream: Array<PhraseResponses>;
  /** An array relationship */
  phrases: Array<Phrases>;
  /** An aggregate relationship */
  phrases_aggregate: PhrasesAggregate;
  /** fetch data from the table: "phrases" using primary key columns */
  phrases_by_pk?: Maybe<Phrases>;
  /** fetch data from the table in a streaming manner: "phrases" */
  phrases_stream: Array<Phrases>;
  /** fetch data from the table: "poem_lines" */
  poem_lines: Array<PoemLines>;
  /** fetch aggregated fields from the table: "poem_lines" */
  poem_lines_aggregate: PoemLinesAggregate;
  /** fetch data from the table: "poem_lines" using primary key columns */
  poem_lines_by_pk?: Maybe<PoemLines>;
  /** fetch data from the table in a streaming manner: "poem_lines" */
  poem_lines_stream: Array<PoemLines>;
  /** fetch data from the table: "poems" */
  poems: Array<Poems>;
  /** fetch aggregated fields from the table: "poems" */
  poems_aggregate: PoemsAggregate;
  /** fetch data from the table: "poems" using primary key columns */
  poems_by_pk?: Maybe<Poems>;
  /** fetch data from the table in a streaming manner: "poems" */
  poems_stream: Array<Poems>;
  /** fetch data from the table: "prepositions" */
  prepositions: Array<Prepositions>;
  /** fetch aggregated fields from the table: "prepositions" */
  prepositions_aggregate: PrepositionsAggregate;
  /** fetch data from the table: "prepositions" using primary key columns */
  prepositions_by_pk?: Maybe<Prepositions>;
  /** fetch data from the table in a streaming manner: "prepositions" */
  prepositions_stream: Array<Prepositions>;
  /** fetch data from the table: "readings" */
  readings: Array<Readings>;
  /** fetch aggregated fields from the table: "readings" */
  readings_aggregate: ReadingsAggregate;
  /** fetch data from the table: "readings" using primary key columns */
  readings_by_pk?: Maybe<Readings>;
  /** fetch data from the table in a streaming manner: "readings" */
  readings_stream: Array<Readings>;
  /** execute function "search_users" which returns "users" */
  search_users: Array<Users>;
  /** execute function "search_users" and query aggregates on result of table type "users" */
  search_users_aggregate: UsersAggregate;
  /** fetch data from the table: "session_statuses" */
  session_statuses: Array<SessionStatuses>;
  /** fetch aggregated fields from the table: "session_statuses" */
  session_statuses_aggregate: SessionStatusesAggregate;
  /** fetch data from the table: "session_statuses" using primary key columns */
  session_statuses_by_pk?: Maybe<SessionStatuses>;
  /** fetch data from the table in a streaming manner: "session_statuses" */
  session_statuses_stream: Array<SessionStatuses>;
  /** An array relationship */
  sessions: Array<Sessions>;
  /** An aggregate relationship */
  sessions_aggregate: SessionsAggregate;
  /** fetch data from the table: "sessions" using primary key columns */
  sessions_by_pk?: Maybe<Sessions>;
  /** fetch data from the table in a streaming manner: "sessions" */
  sessions_stream: Array<Sessions>;
  /** An array relationship */
  slots: Array<Slots>;
  /** An aggregate relationship */
  slots_aggregate: SlotsAggregate;
  /** fetch data from the table: "slots" using primary key columns */
  slots_by_pk?: Maybe<Slots>;
  /** fetch data from the table in a streaming manner: "slots" */
  slots_stream: Array<Slots>;
  /** fetch data from the table: "stats" */
  stats: Array<Stats>;
  /** fetch aggregated fields from the table: "stats" */
  stats_aggregate: StatsAggregate;
  /** fetch data from the table: "stats" using primary key columns */
  stats_by_pk?: Maybe<Stats>;
  /** fetch data from the table in a streaming manner: "stats" */
  stats_stream: Array<Stats>;
  /** fetch data from the table: "student_class_sessions" */
  student_class_sessions: Array<StudentClassSessions>;
  /** fetch aggregated fields from the table: "student_class_sessions" */
  student_class_sessions_aggregate: StudentClassSessionsAggregate;
  /** fetch data from the table: "student_class_sessions" using primary key columns */
  student_class_sessions_by_pk?: Maybe<StudentClassSessions>;
  /** fetch data from the table in a streaming manner: "student_class_sessions" */
  student_class_sessions_stream: Array<StudentClassSessions>;
  /** fetch data from the table: "student_classes" */
  student_classes: Array<StudentClasses>;
  /** fetch aggregated fields from the table: "student_classes" */
  student_classes_aggregate: StudentClassesAggregate;
  /** fetch data from the table: "student_classes" using primary key columns */
  student_classes_by_pk?: Maybe<StudentClasses>;
  /** fetch data from the table in a streaming manner: "student_classes" */
  student_classes_stream: Array<StudentClasses>;
  /** fetch data from the table: "student_favorite_teachers" */
  student_favorite_teachers: Array<StudentFavoriteTeachers>;
  /** fetch aggregated fields from the table: "student_favorite_teachers" */
  student_favorite_teachers_aggregate: StudentFavoriteTeachersAggregate;
  /** fetch data from the table: "student_favorite_teachers" using primary key columns */
  student_favorite_teachers_by_pk?: Maybe<StudentFavoriteTeachers>;
  /** fetch data from the table in a streaming manner: "student_favorite_teachers" */
  student_favorite_teachers_stream: Array<StudentFavoriteTeachers>;
  /** fetch data from the table: "student_live_class_activities" */
  student_live_class_activities: Array<StudentLiveClassActivities>;
  /** fetch aggregated fields from the table: "student_live_class_activities" */
  student_live_class_activities_aggregate: StudentLiveClassActivitiesAggregate;
  /** fetch data from the table: "student_live_class_activities" using primary key columns */
  student_live_class_activities_by_pk?: Maybe<StudentLiveClassActivities>;
  /** fetch data from the table in a streaming manner: "student_live_class_activities" */
  student_live_class_activities_stream: Array<StudentLiveClassActivities>;
  /** fetch data from the table: "subjects" */
  subjects: Array<Subjects>;
  /** fetch aggregated fields from the table: "subjects" */
  subjects_aggregate: SubjectsAggregate;
  /** fetch data from the table: "subjects" using primary key columns */
  subjects_by_pk?: Maybe<Subjects>;
  /** fetch data from the table in a streaming manner: "subjects" */
  subjects_stream: Array<Subjects>;
  /** fetch data from the table: "subscriptions" */
  subscriptions: Array<Subscriptions>;
  /** fetch aggregated fields from the table: "subscriptions" */
  subscriptions_aggregate: SubscriptionsAggregate;
  /** fetch data from the table: "subscriptions" using primary key columns */
  subscriptions_by_pk?: Maybe<Subscriptions>;
  /** fetch data from the table in a streaming manner: "subscriptions" */
  subscriptions_stream: Array<Subscriptions>;
  /** fetch data from the table: "synonyms" */
  synonyms: Array<Synonyms>;
  /** fetch aggregated fields from the table: "synonyms" */
  synonyms_aggregate: SynonymsAggregate;
  /** fetch data from the table: "synonyms" using primary key columns */
  synonyms_by_pk?: Maybe<Synonyms>;
  /** fetch data from the table in a streaming manner: "synonyms" */
  synonyms_stream: Array<Synonyms>;
  /** fetch data from the table: "teacher_credentials" */
  teacher_credentials: Array<TeacherCredentials>;
  /** fetch aggregated fields from the table: "teacher_credentials" */
  teacher_credentials_aggregate: TeacherCredentialsAggregate;
  /** fetch data from the table: "teacher_credentials" using primary key columns */
  teacher_credentials_by_pk?: Maybe<TeacherCredentials>;
  /** fetch data from the table in a streaming manner: "teacher_credentials" */
  teacher_credentials_stream: Array<TeacherCredentials>;
  /** fetch data from the table: "teacher_education" */
  teacher_education: Array<TeacherEducation>;
  /** fetch aggregated fields from the table: "teacher_education" */
  teacher_education_aggregate: TeacherEducationAggregate;
  /** fetch data from the table: "teacher_education" using primary key columns */
  teacher_education_by_pk?: Maybe<TeacherEducation>;
  /** fetch data from the table in a streaming manner: "teacher_education" */
  teacher_education_stream: Array<TeacherEducation>;
  /** fetch data from the table: "teacher_interests" */
  teacher_interests: Array<TeacherInterests>;
  /** fetch aggregated fields from the table: "teacher_interests" */
  teacher_interests_aggregate: TeacherInterestsAggregate;
  /** fetch data from the table: "teacher_interests" using primary key columns */
  teacher_interests_by_pk?: Maybe<TeacherInterests>;
  /** fetch data from the table in a streaming manner: "teacher_interests" */
  teacher_interests_stream: Array<TeacherInterests>;
  /** fetch data from the table: "teacher_languages" */
  teacher_languages: Array<TeacherLanguages>;
  /** fetch aggregated fields from the table: "teacher_languages" */
  teacher_languages_aggregate: TeacherLanguagesAggregate;
  /** fetch data from the table: "teacher_languages" using primary key columns */
  teacher_languages_by_pk?: Maybe<TeacherLanguages>;
  /** fetch data from the table in a streaming manner: "teacher_languages" */
  teacher_languages_stream: Array<TeacherLanguages>;
  /** fetch data from the table: "teacher_subjects" */
  teacher_subjects: Array<TeacherSubjects>;
  /** fetch aggregated fields from the table: "teacher_subjects" */
  teacher_subjects_aggregate: TeacherSubjectsAggregate;
  /** fetch data from the table: "teacher_subjects" using primary key columns */
  teacher_subjects_by_pk?: Maybe<TeacherSubjects>;
  /** fetch data from the table in a streaming manner: "teacher_subjects" */
  teacher_subjects_stream: Array<TeacherSubjects>;
  /** fetch data from the table: "teachers" */
  teachers: Array<Teachers>;
  /** fetch aggregated fields from the table: "teachers" */
  teachers_aggregate: TeachersAggregate;
  /** fetch data from the table: "teachers" using primary key columns */
  teachers_by_pk?: Maybe<Teachers>;
  /** fetch data from the table in a streaming manner: "teachers" */
  teachers_stream: Array<Teachers>;
  /** fetch data from the table: "user_courses" */
  user_courses: Array<UserCourses>;
  /** fetch aggregated fields from the table: "user_courses" */
  user_courses_aggregate: UserCoursesAggregate;
  /** fetch data from the table: "user_courses" using primary key columns */
  user_courses_by_pk?: Maybe<UserCourses>;
  /** fetch data from the table in a streaming manner: "user_courses" */
  user_courses_stream: Array<UserCourses>;
  /** fetch data from the table: "user_devices" */
  user_devices: Array<UserDevices>;
  /** fetch aggregated fields from the table: "user_devices" */
  user_devices_aggregate: UserDevicesAggregate;
  /** fetch data from the table: "user_devices" using primary key columns */
  user_devices_by_pk?: Maybe<UserDevices>;
  /** fetch data from the table in a streaming manner: "user_devices" */
  user_devices_stream: Array<UserDevices>;
  /** fetch data from the table: "user_dictionaries" */
  user_dictionaries: Array<UserDictionaries>;
  /** fetch aggregated fields from the table: "user_dictionaries" */
  user_dictionaries_aggregate: UserDictionariesAggregate;
  /** fetch data from the table: "user_dictionaries" using primary key columns */
  user_dictionaries_by_pk?: Maybe<UserDictionaries>;
  /** fetch data from the table in a streaming manner: "user_dictionaries" */
  user_dictionaries_stream: Array<UserDictionaries>;
  /** fetch data from the table: "user_messages" */
  user_messages: Array<UserMessages>;
  /** fetch aggregated fields from the table: "user_messages" */
  user_messages_aggregate: UserMessagesAggregate;
  /** fetch data from the table: "user_messages" using primary key columns */
  user_messages_by_pk?: Maybe<UserMessages>;
  /** fetch data from the table in a streaming manner: "user_messages" */
  user_messages_stream: Array<UserMessages>;
  /** fetch data from the table: "user_words" */
  user_words: Array<UserWords>;
  /** fetch aggregated fields from the table: "user_words" */
  user_words_aggregate: UserWordsAggregate;
  /** fetch data from the table: "user_words" using primary key columns */
  user_words_by_pk?: Maybe<UserWords>;
  /** fetch data from the table: "user_words_count" */
  user_words_count: Array<UserWordsCount>;
  /** fetch aggregated fields from the table: "user_words_count" */
  user_words_count_aggregate: UserWordsCountAggregate;
  /** fetch data from the table: "user_words_count" using primary key columns */
  user_words_count_by_pk?: Maybe<UserWordsCount>;
  /** fetch data from the table in a streaming manner: "user_words_count" */
  user_words_count_stream: Array<UserWordsCount>;
  /** fetch data from the table in a streaming manner: "user_words" */
  user_words_stream: Array<UserWords>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: UsersAggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table in a streaming manner: "users" */
  users_stream: Array<Users>;
  /** fetch data from the table: "vocabulary_sets" */
  vocabulary_sets: Array<VocabularySets>;
  /** fetch aggregated fields from the table: "vocabulary_sets" */
  vocabulary_sets_aggregate: VocabularySetsAggregate;
  /** fetch data from the table: "vocabulary_sets" using primary key columns */
  vocabulary_sets_by_pk?: Maybe<VocabularySets>;
  /** fetch data from the table in a streaming manner: "vocabulary_sets" */
  vocabulary_sets_stream: Array<VocabularySets>;
  /** fetch data from the table: "vocabulary_words" */
  vocabulary_words: Array<VocabularyWords>;
  /** fetch aggregated fields from the table: "vocabulary_words" */
  vocabulary_words_aggregate: VocabularyWordsAggregate;
  /** fetch data from the table: "vocabulary_words" using primary key columns */
  vocabulary_words_by_pk?: Maybe<VocabularyWords>;
  /** fetch data from the table in a streaming manner: "vocabulary_words" */
  vocabulary_words_stream: Array<VocabularyWords>;
  /** fetch data from the table: "wordnet.english_words" */
  wordnet_english_words: Array<WordnetEnglishWords>;
  /** fetch aggregated fields from the table: "wordnet.english_words" */
  wordnet_english_words_aggregate: WordnetEnglishWordsAggregate;
  /** fetch data from the table: "wordnet.english_words" using primary key columns */
  wordnet_english_words_by_pk?: Maybe<WordnetEnglishWords>;
  /** fetch data from the table in a streaming manner: "wordnet.english_words" */
  wordnet_english_words_stream: Array<WordnetEnglishWords>;
  /** execute function "wordnet.search_wordnet_english" which returns "wordnet.english_words" */
  wordnet_search_wordnet_english: Array<WordnetEnglishWords>;
  /** execute function "wordnet.search_wordnet_english" and query aggregates on result of table type "wordnet.english_words" */
  wordnet_search_wordnet_english_aggregate: WordnetEnglishWordsAggregate;
  /** fetch data from the table: "wordnet.synsets" */
  wordnet_synsets: Array<WordnetSynsets>;
  /** fetch aggregated fields from the table: "wordnet.synsets" */
  wordnet_synsets_aggregate: WordnetSynsetsAggregate;
  /** fetch data from the table: "wordnet.synsets" using primary key columns */
  wordnet_synsets_by_pk?: Maybe<WordnetSynsets>;
  /** fetch data from the table in a streaming manner: "wordnet.synsets" */
  wordnet_synsets_stream: Array<WordnetSynsets>;
};


export type SubscriptionRootActivitySetAssignmentsArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetAssignmentsOrderBy>>;
  where?: InputMaybe<ActivitySetAssignmentsBoolExp>;
};


export type SubscriptionRootActivitySetAssignmentsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetAssignmentsOrderBy>>;
  where?: InputMaybe<ActivitySetAssignmentsBoolExp>;
};


export type SubscriptionRootActivitySetAssignmentsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootActivitySetAssignmentsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ActivitySetAssignmentsStreamCursorInput>>;
  where?: InputMaybe<ActivitySetAssignmentsBoolExp>;
};


export type SubscriptionRootActivitySetReportsArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetReportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetReportsOrderBy>>;
  where?: InputMaybe<ActivitySetReportsBoolExp>;
};


export type SubscriptionRootActivitySetReportsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetReportsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetReportsOrderBy>>;
  where?: InputMaybe<ActivitySetReportsBoolExp>;
};


export type SubscriptionRootActivitySetReportsByPkArgs = {
  activitySetId: Scalars['Int']['input'];
  createdBy: Scalars['Int']['input'];
};


export type SubscriptionRootActivitySetReportsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ActivitySetReportsStreamCursorInput>>;
  where?: InputMaybe<ActivitySetReportsBoolExp>;
};


export type SubscriptionRootActivitySetResponsesArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetResponsesOrderBy>>;
  where?: InputMaybe<ActivitySetResponsesBoolExp>;
};


export type SubscriptionRootActivitySetResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetResponsesOrderBy>>;
  where?: InputMaybe<ActivitySetResponsesBoolExp>;
};


export type SubscriptionRootActivitySetResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootActivitySetResponsesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ActivitySetResponsesStreamCursorInput>>;
  where?: InputMaybe<ActivitySetResponsesBoolExp>;
};


export type SubscriptionRootActivitySetsArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetsOrderBy>>;
  where?: InputMaybe<ActivitySetsBoolExp>;
};


export type SubscriptionRootActivitySetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ActivitySetsOrderBy>>;
  where?: InputMaybe<ActivitySetsBoolExp>;
};


export type SubscriptionRootActivitySetsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootActivitySetsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ActivitySetsStreamCursorInput>>;
  where?: InputMaybe<ActivitySetsBoolExp>;
};


export type SubscriptionRootAddressesArgs = {
  distinct_on?: InputMaybe<Array<AddressesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AddressesOrderBy>>;
  where?: InputMaybe<AddressesBoolExp>;
};


export type SubscriptionRootAddressesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AddressesOrderBy>>;
  where?: InputMaybe<AddressesBoolExp>;
};


export type SubscriptionRootAddressesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootAddressesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AddressesStreamCursorInput>>;
  where?: InputMaybe<AddressesBoolExp>;
};


export type SubscriptionRootAnagramResponsesArgs = {
  distinct_on?: InputMaybe<Array<AnagramResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramResponsesOrderBy>>;
  where?: InputMaybe<AnagramResponsesBoolExp>;
};


export type SubscriptionRootAnagramResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnagramResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramResponsesOrderBy>>;
  where?: InputMaybe<AnagramResponsesBoolExp>;
};


export type SubscriptionRootAnagramResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootAnagramResponsesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AnagramResponsesStreamCursorInput>>;
  where?: InputMaybe<AnagramResponsesBoolExp>;
};


export type SubscriptionRootAnagramsArgs = {
  distinct_on?: InputMaybe<Array<AnagramsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramsOrderBy>>;
  where?: InputMaybe<AnagramsBoolExp>;
};


export type SubscriptionRootAnagramsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnagramsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnagramsOrderBy>>;
  where?: InputMaybe<AnagramsBoolExp>;
};


export type SubscriptionRootAnagramsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootAnagramsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AnagramsStreamCursorInput>>;
  where?: InputMaybe<AnagramsBoolExp>;
};


export type SubscriptionRootAnnotationsArgs = {
  distinct_on?: InputMaybe<Array<AnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnnotationsOrderBy>>;
  where?: InputMaybe<AnnotationsBoolExp>;
};


export type SubscriptionRootAnnotationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AnnotationsOrderBy>>;
  where?: InputMaybe<AnnotationsBoolExp>;
};


export type SubscriptionRootAnnotationsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootAnnotationsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AnnotationsStreamCursorInput>>;
  where?: InputMaybe<AnnotationsBoolExp>;
};


export type SubscriptionRootApplicationReviewsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationReviewsOrderBy>>;
  where?: InputMaybe<ApplicationReviewsBoolExp>;
};


export type SubscriptionRootApplicationReviewsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationReviewsOrderBy>>;
  where?: InputMaybe<ApplicationReviewsBoolExp>;
};


export type SubscriptionRootApplicationReviewsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootApplicationReviewsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationReviewsStreamCursorInput>>;
  where?: InputMaybe<ApplicationReviewsBoolExp>;
};


export type SubscriptionRootAvailabilityTimesArgs = {
  distinct_on?: InputMaybe<Array<AvailabilityTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AvailabilityTimesOrderBy>>;
  where?: InputMaybe<AvailabilityTimesBoolExp>;
};


export type SubscriptionRootAvailabilityTimesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AvailabilityTimesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AvailabilityTimesOrderBy>>;
  where?: InputMaybe<AvailabilityTimesBoolExp>;
};


export type SubscriptionRootAvailabilityTimesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootAvailabilityTimesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AvailabilityTimesStreamCursorInput>>;
  where?: InputMaybe<AvailabilityTimesBoolExp>;
};


export type SubscriptionRootCefrLevelsArgs = {
  distinct_on?: InputMaybe<Array<CefrLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CefrLevelsOrderBy>>;
  where?: InputMaybe<CefrLevelsBoolExp>;
};


export type SubscriptionRootCefrLevelsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CefrLevelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CefrLevelsOrderBy>>;
  where?: InputMaybe<CefrLevelsBoolExp>;
};


export type SubscriptionRootCefrLevelsByPkArgs = {
  value: Scalars['String']['input'];
};


export type SubscriptionRootCefrLevelsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CefrLevelsStreamCursorInput>>;
  where?: InputMaybe<CefrLevelsBoolExp>;
};


export type SubscriptionRootClassActivitySetsArgs = {
  distinct_on?: InputMaybe<Array<ClassActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassActivitySetsOrderBy>>;
  where?: InputMaybe<ClassActivitySetsBoolExp>;
};


export type SubscriptionRootClassActivitySetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassActivitySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassActivitySetsOrderBy>>;
  where?: InputMaybe<ClassActivitySetsBoolExp>;
};


export type SubscriptionRootClassActivitySetsByPkArgs = {
  activitySetId: Scalars['Int']['input'];
  classId: Scalars['Int']['input'];
};


export type SubscriptionRootClassActivitySetsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClassActivitySetsStreamCursorInput>>;
  where?: InputMaybe<ClassActivitySetsBoolExp>;
};


export type SubscriptionRootClassAnnotationsArgs = {
  distinct_on?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassAnnotationsOrderBy>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};


export type SubscriptionRootClassAnnotationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassAnnotationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassAnnotationsOrderBy>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};


export type SubscriptionRootClassAnnotationsByPkArgs = {
  annotationId: Scalars['Int']['input'];
  classId: Scalars['Int']['input'];
};


export type SubscriptionRootClassAnnotationsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClassAnnotationsStreamCursorInput>>;
  where?: InputMaybe<ClassAnnotationsBoolExp>;
};


export type SubscriptionRootClassCoursesArgs = {
  distinct_on?: InputMaybe<Array<ClassCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassCoursesOrderBy>>;
  where?: InputMaybe<ClassCoursesBoolExp>;
};


export type SubscriptionRootClassCoursesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassCoursesOrderBy>>;
  where?: InputMaybe<ClassCoursesBoolExp>;
};


export type SubscriptionRootClassCoursesByPkArgs = {
  classId: Scalars['Int']['input'];
  courseId: Scalars['Int']['input'];
};


export type SubscriptionRootClassCoursesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClassCoursesStreamCursorInput>>;
  where?: InputMaybe<ClassCoursesBoolExp>;
};


export type SubscriptionRootClassSessionsArgs = {
  distinct_on?: InputMaybe<Array<ClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSessionsOrderBy>>;
  where?: InputMaybe<ClassSessionsBoolExp>;
};


export type SubscriptionRootClassSessionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSessionsOrderBy>>;
  where?: InputMaybe<ClassSessionsBoolExp>;
};


export type SubscriptionRootClassSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootClassSessionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClassSessionsStreamCursorInput>>;
  where?: InputMaybe<ClassSessionsBoolExp>;
};


export type SubscriptionRootClassSlotBookingsArgs = {
  distinct_on?: InputMaybe<Array<ClassSlotBookingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSlotBookingsOrderBy>>;
  where?: InputMaybe<ClassSlotBookingsBoolExp>;
};


export type SubscriptionRootClassSlotBookingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassSlotBookingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassSlotBookingsOrderBy>>;
  where?: InputMaybe<ClassSlotBookingsBoolExp>;
};


export type SubscriptionRootClassSlotBookingsByPkArgs = {
  slotId: Scalars['Int']['input'];
  studentId: Scalars['Int']['input'];
};


export type SubscriptionRootClassSlotBookingsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClassSlotBookingsStreamCursorInput>>;
  where?: InputMaybe<ClassSlotBookingsBoolExp>;
};


export type SubscriptionRootClassesArgs = {
  distinct_on?: InputMaybe<Array<ClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassesOrderBy>>;
  where?: InputMaybe<ClassesBoolExp>;
};


export type SubscriptionRootClassesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ClassesOrderBy>>;
  where?: InputMaybe<ClassesBoolExp>;
};


export type SubscriptionRootClassesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootClassesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClassesStreamCursorInput>>;
  where?: InputMaybe<ClassesBoolExp>;
};


export type SubscriptionRootCourseActivitiesArgs = {
  distinct_on?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseActivitiesOrderBy>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


export type SubscriptionRootCourseActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseActivitiesOrderBy>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


export type SubscriptionRootCourseActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootCourseActivitiesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CourseActivitiesStreamCursorInput>>;
  where?: InputMaybe<CourseActivitiesBoolExp>;
};


export type SubscriptionRootCourseReviewsArgs = {
  distinct_on?: InputMaybe<Array<CourseReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseReviewsOrderBy>>;
  where?: InputMaybe<CourseReviewsBoolExp>;
};


export type SubscriptionRootCourseReviewsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseReviewsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseReviewsOrderBy>>;
  where?: InputMaybe<CourseReviewsBoolExp>;
};


export type SubscriptionRootCourseReviewsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootCourseReviewsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CourseReviewsStreamCursorInput>>;
  where?: InputMaybe<CourseReviewsBoolExp>;
};


export type SubscriptionRootCourseSummaryArgs = {
  distinct_on?: InputMaybe<Array<CourseSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseSummaryOrderBy>>;
  where?: InputMaybe<CourseSummaryBoolExp>;
};


export type SubscriptionRootCourseSummaryAggregateArgs = {
  distinct_on?: InputMaybe<Array<CourseSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CourseSummaryOrderBy>>;
  where?: InputMaybe<CourseSummaryBoolExp>;
};


export type SubscriptionRootCourseSummaryStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CourseSummaryStreamCursorInput>>;
  where?: InputMaybe<CourseSummaryBoolExp>;
};


export type SubscriptionRootCoursesArgs = {
  distinct_on?: InputMaybe<Array<CoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CoursesOrderBy>>;
  where?: InputMaybe<CoursesBoolExp>;
};


export type SubscriptionRootCoursesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CoursesOrderBy>>;
  where?: InputMaybe<CoursesBoolExp>;
};


export type SubscriptionRootCoursesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootCoursesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CoursesStreamCursorInput>>;
  where?: InputMaybe<CoursesBoolExp>;
};


export type SubscriptionRootDailyStatsArgs = {
  distinct_on?: InputMaybe<Array<DailyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DailyStatsOrderBy>>;
  where?: InputMaybe<DailyStatsBoolExp>;
};


export type SubscriptionRootDailyStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<DailyStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DailyStatsOrderBy>>;
  where?: InputMaybe<DailyStatsBoolExp>;
};


export type SubscriptionRootDailyStatsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootDailyStatsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DailyStatsStreamCursorInput>>;
  where?: InputMaybe<DailyStatsBoolExp>;
};


export type SubscriptionRootDictionariesArgs = {
  distinct_on?: InputMaybe<Array<DictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DictionariesOrderBy>>;
  where?: InputMaybe<DictionariesBoolExp>;
};


export type SubscriptionRootDictionariesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DictionariesOrderBy>>;
  where?: InputMaybe<DictionariesBoolExp>;
};


export type SubscriptionRootDictionariesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootDictionariesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DictionariesStreamCursorInput>>;
  where?: InputMaybe<DictionariesBoolExp>;
};


export type SubscriptionRootEmojisArgs = {
  distinct_on?: InputMaybe<Array<EmojisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EmojisOrderBy>>;
  where?: InputMaybe<EmojisBoolExp>;
};


export type SubscriptionRootEmojisAggregateArgs = {
  distinct_on?: InputMaybe<Array<EmojisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EmojisOrderBy>>;
  where?: InputMaybe<EmojisBoolExp>;
};


export type SubscriptionRootEmojisByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootEmojisStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<EmojisStreamCursorInput>>;
  where?: InputMaybe<EmojisBoolExp>;
};


export type SubscriptionRootEmployeesArgs = {
  distinct_on?: InputMaybe<Array<EmployeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EmployeesOrderBy>>;
  where?: InputMaybe<EmployeesBoolExp>;
};


export type SubscriptionRootEmployeesAggregateArgs = {
  distinct_on?: InputMaybe<Array<EmployeesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EmployeesOrderBy>>;
  where?: InputMaybe<EmployeesBoolExp>;
};


export type SubscriptionRootEmployeesByPkArgs = {
  userId: Scalars['Int']['input'];
};


export type SubscriptionRootEmployeesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<EmployeesStreamCursorInput>>;
  where?: InputMaybe<EmployeesBoolExp>;
};


export type SubscriptionRootExampleJoinsArgs = {
  distinct_on?: InputMaybe<Array<ExampleJoinsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExampleJoinsOrderBy>>;
  where?: InputMaybe<ExampleJoinsBoolExp>;
};


export type SubscriptionRootExampleJoinsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ExampleJoinsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExampleJoinsOrderBy>>;
  where?: InputMaybe<ExampleJoinsBoolExp>;
};


export type SubscriptionRootExampleJoinsByPkArgs = {
  from_id: Scalars['Int']['input'];
  to_id: Scalars['Int']['input'];
};


export type SubscriptionRootExampleJoinsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ExampleJoinsStreamCursorInput>>;
  where?: InputMaybe<ExampleJoinsBoolExp>;
};


export type SubscriptionRootExamplesArgs = {
  distinct_on?: InputMaybe<Array<ExamplesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExamplesOrderBy>>;
  where?: InputMaybe<ExamplesBoolExp>;
};


export type SubscriptionRootExamplesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ExamplesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExamplesOrderBy>>;
  where?: InputMaybe<ExamplesBoolExp>;
};


export type SubscriptionRootExamplesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootExamplesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ExamplesStreamCursorInput>>;
  where?: InputMaybe<ExamplesBoolExp>;
};


export type SubscriptionRootExpiredRefreshTokensArgs = {
  distinct_on?: InputMaybe<Array<ExpiredRefreshTokensSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExpiredRefreshTokensOrderBy>>;
  where?: InputMaybe<ExpiredRefreshTokensBoolExp>;
};


export type SubscriptionRootExpiredRefreshTokensAggregateArgs = {
  distinct_on?: InputMaybe<Array<ExpiredRefreshTokensSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ExpiredRefreshTokensOrderBy>>;
  where?: InputMaybe<ExpiredRefreshTokensBoolExp>;
};


export type SubscriptionRootExpiredRefreshTokensByPkArgs = {
  token: Scalars['String']['input'];
};


export type SubscriptionRootExpiredRefreshTokensStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ExpiredRefreshTokensStreamCursorInput>>;
  where?: InputMaybe<ExpiredRefreshTokensBoolExp>;
};


export type SubscriptionRootFillInTheBlankOptionsArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankOptionsOrderBy>>;
  where?: InputMaybe<FillInTheBlankOptionsBoolExp>;
};


export type SubscriptionRootFillInTheBlankOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankOptionsOrderBy>>;
  where?: InputMaybe<FillInTheBlankOptionsBoolExp>;
};


export type SubscriptionRootFillInTheBlankOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootFillInTheBlankOptionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<FillInTheBlankOptionsStreamCursorInput>>;
  where?: InputMaybe<FillInTheBlankOptionsBoolExp>;
};


export type SubscriptionRootFillInTheBlankResponsesArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankResponsesOrderBy>>;
  where?: InputMaybe<FillInTheBlankResponsesBoolExp>;
};


export type SubscriptionRootFillInTheBlankResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlankResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlankResponsesOrderBy>>;
  where?: InputMaybe<FillInTheBlankResponsesBoolExp>;
};


export type SubscriptionRootFillInTheBlankResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootFillInTheBlankResponsesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<FillInTheBlankResponsesStreamCursorInput>>;
  where?: InputMaybe<FillInTheBlankResponsesBoolExp>;
};


export type SubscriptionRootFillInTheBlanksArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlanksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlanksOrderBy>>;
  where?: InputMaybe<FillInTheBlanksBoolExp>;
};


export type SubscriptionRootFillInTheBlanksAggregateArgs = {
  distinct_on?: InputMaybe<Array<FillInTheBlanksSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FillInTheBlanksOrderBy>>;
  where?: InputMaybe<FillInTheBlanksBoolExp>;
};


export type SubscriptionRootFillInTheBlanksByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootFillInTheBlanksStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<FillInTheBlanksStreamCursorInput>>;
  where?: InputMaybe<FillInTheBlanksBoolExp>;
};


export type SubscriptionRootGameDailiesArgs = {
  distinct_on?: InputMaybe<Array<GameDailiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameDailiesOrderBy>>;
  where?: InputMaybe<GameDailiesBoolExp>;
};


export type SubscriptionRootGameDailiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameDailiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameDailiesOrderBy>>;
  where?: InputMaybe<GameDailiesBoolExp>;
};


export type SubscriptionRootGameDailiesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootGameDailiesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<GameDailiesStreamCursorInput>>;
  where?: InputMaybe<GameDailiesBoolExp>;
};


export type SubscriptionRootGameDifficultyArgs = {
  distinct_on?: InputMaybe<Array<GameDifficultySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameDifficultyOrderBy>>;
  where?: InputMaybe<GameDifficultyBoolExp>;
};


export type SubscriptionRootGameDifficultyAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameDifficultySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameDifficultyOrderBy>>;
  where?: InputMaybe<GameDifficultyBoolExp>;
};


export type SubscriptionRootGameDifficultyByPkArgs = {
  value: Scalars['String']['input'];
};


export type SubscriptionRootGameDifficultyStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<GameDifficultyStreamCursorInput>>;
  where?: InputMaybe<GameDifficultyBoolExp>;
};


export type SubscriptionRootGameTypesArgs = {
  distinct_on?: InputMaybe<Array<GameTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameTypesOrderBy>>;
  where?: InputMaybe<GameTypesBoolExp>;
};


export type SubscriptionRootGameTypesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameTypesOrderBy>>;
  where?: InputMaybe<GameTypesBoolExp>;
};


export type SubscriptionRootGameTypesByPkArgs = {
  value: Scalars['String']['input'];
};


export type SubscriptionRootGameTypesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<GameTypesStreamCursorInput>>;
  where?: InputMaybe<GameTypesBoolExp>;
};


export type SubscriptionRootGameUsersArgs = {
  distinct_on?: InputMaybe<Array<GameUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameUsersOrderBy>>;
  where?: InputMaybe<GameUsersBoolExp>;
};


export type SubscriptionRootGameUsersAggregateArgs = {
  distinct_on?: InputMaybe<Array<GameUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GameUsersOrderBy>>;
  where?: InputMaybe<GameUsersBoolExp>;
};


export type SubscriptionRootGameUsersByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootGameUsersStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<GameUsersStreamCursorInput>>;
  where?: InputMaybe<GameUsersBoolExp>;
};


export type SubscriptionRootGamesArgs = {
  distinct_on?: InputMaybe<Array<GamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GamesOrderBy>>;
  where?: InputMaybe<GamesBoolExp>;
};


export type SubscriptionRootGamesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GamesOrderBy>>;
  where?: InputMaybe<GamesBoolExp>;
};


export type SubscriptionRootGamesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootGamesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<GamesStreamCursorInput>>;
  where?: InputMaybe<GamesBoolExp>;
};


export type SubscriptionRootGetRandomPoemArgs = {
  args?: InputMaybe<GetRandomPoemArgs>;
  distinct_on?: InputMaybe<Array<PoemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemsOrderBy>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type SubscriptionRootGetRandomPoemAggregateArgs = {
  args?: InputMaybe<GetRandomPoemArgs>;
  distinct_on?: InputMaybe<Array<PoemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemsOrderBy>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type SubscriptionRootGetUserWordsCountArgs = {
  args: GetUserWordsCountArgs;
  distinct_on?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsCountOrderBy>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type SubscriptionRootGetUserWordsCountAggregateArgs = {
  args: GetUserWordsCountArgs;
  distinct_on?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsCountOrderBy>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type SubscriptionRootGoalsArgs = {
  distinct_on?: InputMaybe<Array<GoalsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GoalsOrderBy>>;
  where?: InputMaybe<GoalsBoolExp>;
};


export type SubscriptionRootGoalsAggregateArgs = {
  distinct_on?: InputMaybe<Array<GoalsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<GoalsOrderBy>>;
  where?: InputMaybe<GoalsBoolExp>;
};


export type SubscriptionRootGoalsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootGoalsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<GoalsStreamCursorInput>>;
  where?: InputMaybe<GoalsBoolExp>;
};


export type SubscriptionRootImagesArgs = {
  distinct_on?: InputMaybe<Array<ImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ImagesOrderBy>>;
  where?: InputMaybe<ImagesBoolExp>;
};


export type SubscriptionRootImagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ImagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ImagesOrderBy>>;
  where?: InputMaybe<ImagesBoolExp>;
};


export type SubscriptionRootImagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootImagesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ImagesStreamCursorInput>>;
  where?: InputMaybe<ImagesBoolExp>;
};


export type SubscriptionRootInterestsArgs = {
  distinct_on?: InputMaybe<Array<InterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterestsOrderBy>>;
  where?: InputMaybe<InterestsBoolExp>;
};


export type SubscriptionRootInterestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<InterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterestsOrderBy>>;
  where?: InputMaybe<InterestsBoolExp>;
};


export type SubscriptionRootInterestsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootInterestsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<InterestsStreamCursorInput>>;
  where?: InputMaybe<InterestsBoolExp>;
};


export type SubscriptionRootLanguagesArgs = {
  distinct_on?: InputMaybe<Array<LanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LanguagesOrderBy>>;
  where?: InputMaybe<LanguagesBoolExp>;
};


export type SubscriptionRootLanguagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<LanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LanguagesOrderBy>>;
  where?: InputMaybe<LanguagesBoolExp>;
};


export type SubscriptionRootLanguagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootLanguagesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<LanguagesStreamCursorInput>>;
  where?: InputMaybe<LanguagesBoolExp>;
};


export type SubscriptionRootListeningsArgs = {
  distinct_on?: InputMaybe<Array<ListeningsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ListeningsOrderBy>>;
  where?: InputMaybe<ListeningsBoolExp>;
};


export type SubscriptionRootListeningsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ListeningsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ListeningsOrderBy>>;
  where?: InputMaybe<ListeningsBoolExp>;
};


export type SubscriptionRootListeningsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootListeningsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ListeningsStreamCursorInput>>;
  where?: InputMaybe<ListeningsBoolExp>;
};


export type SubscriptionRootLiveClassActivitiesArgs = {
  distinct_on?: InputMaybe<Array<LiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveClassActivitiesOrderBy>>;
  where?: InputMaybe<LiveClassActivitiesBoolExp>;
};


export type SubscriptionRootLiveClassActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<LiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveClassActivitiesOrderBy>>;
  where?: InputMaybe<LiveClassActivitiesBoolExp>;
};


export type SubscriptionRootLiveClassActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootLiveClassActivitiesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<LiveClassActivitiesStreamCursorInput>>;
  where?: InputMaybe<LiveClassActivitiesBoolExp>;
};


export type SubscriptionRootLiveMessagesArgs = {
  distinct_on?: InputMaybe<Array<LiveMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveMessagesOrderBy>>;
  where?: InputMaybe<LiveMessagesBoolExp>;
};


export type SubscriptionRootLiveMessagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<LiveMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<LiveMessagesOrderBy>>;
  where?: InputMaybe<LiveMessagesBoolExp>;
};


export type SubscriptionRootLiveMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootLiveMessagesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<LiveMessagesStreamCursorInput>>;
  where?: InputMaybe<LiveMessagesBoolExp>;
};


export type SubscriptionRootMatchingOptionsArgs = {
  distinct_on?: InputMaybe<Array<MatchingOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingOptionsOrderBy>>;
  where?: InputMaybe<MatchingOptionsBoolExp>;
};


export type SubscriptionRootMatchingOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingOptionsOrderBy>>;
  where?: InputMaybe<MatchingOptionsBoolExp>;
};


export type SubscriptionRootMatchingOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootMatchingOptionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MatchingOptionsStreamCursorInput>>;
  where?: InputMaybe<MatchingOptionsBoolExp>;
};


export type SubscriptionRootMatchingResponsesArgs = {
  distinct_on?: InputMaybe<Array<MatchingResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingResponsesOrderBy>>;
  where?: InputMaybe<MatchingResponsesBoolExp>;
};


export type SubscriptionRootMatchingResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingResponsesOrderBy>>;
  where?: InputMaybe<MatchingResponsesBoolExp>;
};


export type SubscriptionRootMatchingResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootMatchingResponsesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MatchingResponsesStreamCursorInput>>;
  where?: InputMaybe<MatchingResponsesBoolExp>;
};


export type SubscriptionRootMatchingsArgs = {
  distinct_on?: InputMaybe<Array<MatchingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingsOrderBy>>;
  where?: InputMaybe<MatchingsBoolExp>;
};


export type SubscriptionRootMatchingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MatchingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MatchingsOrderBy>>;
  where?: InputMaybe<MatchingsBoolExp>;
};


export type SubscriptionRootMatchingsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootMatchingsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MatchingsStreamCursorInput>>;
  where?: InputMaybe<MatchingsBoolExp>;
};


export type SubscriptionRootMessagesArgs = {
  distinct_on?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type SubscriptionRootMessagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type SubscriptionRootMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootMessagesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MessagesStreamCursorInput>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type SubscriptionRootMultipleChoiceOptionsArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceOptionsOrderBy>>;
  where?: InputMaybe<MultipleChoiceOptionsBoolExp>;
};


export type SubscriptionRootMultipleChoiceOptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceOptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceOptionsOrderBy>>;
  where?: InputMaybe<MultipleChoiceOptionsBoolExp>;
};


export type SubscriptionRootMultipleChoiceOptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootMultipleChoiceOptionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MultipleChoiceOptionsStreamCursorInput>>;
  where?: InputMaybe<MultipleChoiceOptionsBoolExp>;
};


export type SubscriptionRootMultipleChoiceResponsesArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceResponsesOrderBy>>;
  where?: InputMaybe<MultipleChoiceResponsesBoolExp>;
};


export type SubscriptionRootMultipleChoiceResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoiceResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoiceResponsesOrderBy>>;
  where?: InputMaybe<MultipleChoiceResponsesBoolExp>;
};


export type SubscriptionRootMultipleChoiceResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootMultipleChoiceResponsesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MultipleChoiceResponsesStreamCursorInput>>;
  where?: InputMaybe<MultipleChoiceResponsesBoolExp>;
};


export type SubscriptionRootMultipleChoicesArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoicesOrderBy>>;
  where?: InputMaybe<MultipleChoicesBoolExp>;
};


export type SubscriptionRootMultipleChoicesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MultipleChoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MultipleChoicesOrderBy>>;
  where?: InputMaybe<MultipleChoicesBoolExp>;
};


export type SubscriptionRootMultipleChoicesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootMultipleChoicesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MultipleChoicesStreamCursorInput>>;
  where?: InputMaybe<MultipleChoicesBoolExp>;
};


export type SubscriptionRootOpenAnswerResponsesArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswerResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswerResponsesOrderBy>>;
  where?: InputMaybe<OpenAnswerResponsesBoolExp>;
};


export type SubscriptionRootOpenAnswerResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswerResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswerResponsesOrderBy>>;
  where?: InputMaybe<OpenAnswerResponsesBoolExp>;
};


export type SubscriptionRootOpenAnswerResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootOpenAnswerResponsesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<OpenAnswerResponsesStreamCursorInput>>;
  where?: InputMaybe<OpenAnswerResponsesBoolExp>;
};


export type SubscriptionRootOpenAnswersArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswersOrderBy>>;
  where?: InputMaybe<OpenAnswersBoolExp>;
};


export type SubscriptionRootOpenAnswersAggregateArgs = {
  distinct_on?: InputMaybe<Array<OpenAnswersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<OpenAnswersOrderBy>>;
  where?: InputMaybe<OpenAnswersBoolExp>;
};


export type SubscriptionRootOpenAnswersByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootOpenAnswersStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<OpenAnswersStreamCursorInput>>;
  where?: InputMaybe<OpenAnswersBoolExp>;
};


export type SubscriptionRootPartsOfSpeechArgs = {
  distinct_on?: InputMaybe<Array<PartsOfSpeechSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PartsOfSpeechOrderBy>>;
  where?: InputMaybe<PartsOfSpeechBoolExp>;
};


export type SubscriptionRootPartsOfSpeechAggregateArgs = {
  distinct_on?: InputMaybe<Array<PartsOfSpeechSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PartsOfSpeechOrderBy>>;
  where?: InputMaybe<PartsOfSpeechBoolExp>;
};


export type SubscriptionRootPartsOfSpeechByPkArgs = {
  value: Scalars['String']['input'];
};


export type SubscriptionRootPartsOfSpeechStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PartsOfSpeechStreamCursorInput>>;
  where?: InputMaybe<PartsOfSpeechBoolExp>;
};


export type SubscriptionRootPaymentsArgs = {
  distinct_on?: InputMaybe<Array<PaymentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PaymentsOrderBy>>;
  where?: InputMaybe<PaymentsBoolExp>;
};


export type SubscriptionRootPaymentsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PaymentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PaymentsOrderBy>>;
  where?: InputMaybe<PaymentsBoolExp>;
};


export type SubscriptionRootPaymentsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootPaymentsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PaymentsStreamCursorInput>>;
  where?: InputMaybe<PaymentsBoolExp>;
};


export type SubscriptionRootPhraseResponsesArgs = {
  distinct_on?: InputMaybe<Array<PhraseResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhraseResponsesOrderBy>>;
  where?: InputMaybe<PhraseResponsesBoolExp>;
};


export type SubscriptionRootPhraseResponsesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PhraseResponsesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhraseResponsesOrderBy>>;
  where?: InputMaybe<PhraseResponsesBoolExp>;
};


export type SubscriptionRootPhraseResponsesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootPhraseResponsesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PhraseResponsesStreamCursorInput>>;
  where?: InputMaybe<PhraseResponsesBoolExp>;
};


export type SubscriptionRootPhrasesArgs = {
  distinct_on?: InputMaybe<Array<PhrasesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhrasesOrderBy>>;
  where?: InputMaybe<PhrasesBoolExp>;
};


export type SubscriptionRootPhrasesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PhrasesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhrasesOrderBy>>;
  where?: InputMaybe<PhrasesBoolExp>;
};


export type SubscriptionRootPhrasesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootPhrasesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PhrasesStreamCursorInput>>;
  where?: InputMaybe<PhrasesBoolExp>;
};


export type SubscriptionRootPoemLinesArgs = {
  distinct_on?: InputMaybe<Array<PoemLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemLinesOrderBy>>;
  where?: InputMaybe<PoemLinesBoolExp>;
};


export type SubscriptionRootPoemLinesAggregateArgs = {
  distinct_on?: InputMaybe<Array<PoemLinesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemLinesOrderBy>>;
  where?: InputMaybe<PoemLinesBoolExp>;
};


export type SubscriptionRootPoemLinesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootPoemLinesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PoemLinesStreamCursorInput>>;
  where?: InputMaybe<PoemLinesBoolExp>;
};


export type SubscriptionRootPoemsArgs = {
  distinct_on?: InputMaybe<Array<PoemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemsOrderBy>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type SubscriptionRootPoemsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PoemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PoemsOrderBy>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type SubscriptionRootPoemsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootPoemsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PoemsStreamCursorInput>>;
  where?: InputMaybe<PoemsBoolExp>;
};


export type SubscriptionRootPrepositionsArgs = {
  distinct_on?: InputMaybe<Array<PrepositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PrepositionsOrderBy>>;
  where?: InputMaybe<PrepositionsBoolExp>;
};


export type SubscriptionRootPrepositionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PrepositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PrepositionsOrderBy>>;
  where?: InputMaybe<PrepositionsBoolExp>;
};


export type SubscriptionRootPrepositionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootPrepositionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PrepositionsStreamCursorInput>>;
  where?: InputMaybe<PrepositionsBoolExp>;
};


export type SubscriptionRootReadingsArgs = {
  distinct_on?: InputMaybe<Array<ReadingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ReadingsOrderBy>>;
  where?: InputMaybe<ReadingsBoolExp>;
};


export type SubscriptionRootReadingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ReadingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ReadingsOrderBy>>;
  where?: InputMaybe<ReadingsBoolExp>;
};


export type SubscriptionRootReadingsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootReadingsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ReadingsStreamCursorInput>>;
  where?: InputMaybe<ReadingsBoolExp>;
};


export type SubscriptionRootSearchUsersArgs = {
  args: SearchUsersArgs;
  distinct_on?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type SubscriptionRootSearchUsersAggregateArgs = {
  args: SearchUsersArgs;
  distinct_on?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type SubscriptionRootSessionStatusesArgs = {
  distinct_on?: InputMaybe<Array<SessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionStatusesOrderBy>>;
  where?: InputMaybe<SessionStatusesBoolExp>;
};


export type SubscriptionRootSessionStatusesAggregateArgs = {
  distinct_on?: InputMaybe<Array<SessionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionStatusesOrderBy>>;
  where?: InputMaybe<SessionStatusesBoolExp>;
};


export type SubscriptionRootSessionStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


export type SubscriptionRootSessionStatusesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SessionStatusesStreamCursorInput>>;
  where?: InputMaybe<SessionStatusesBoolExp>;
};


export type SubscriptionRootSessionsArgs = {
  distinct_on?: InputMaybe<Array<SessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionsOrderBy>>;
  where?: InputMaybe<SessionsBoolExp>;
};


export type SubscriptionRootSessionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SessionsOrderBy>>;
  where?: InputMaybe<SessionsBoolExp>;
};


export type SubscriptionRootSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootSessionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SessionsStreamCursorInput>>;
  where?: InputMaybe<SessionsBoolExp>;
};


export type SubscriptionRootSlotsArgs = {
  distinct_on?: InputMaybe<Array<SlotsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SlotsOrderBy>>;
  where?: InputMaybe<SlotsBoolExp>;
};


export type SubscriptionRootSlotsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SlotsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SlotsOrderBy>>;
  where?: InputMaybe<SlotsBoolExp>;
};


export type SubscriptionRootSlotsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootSlotsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SlotsStreamCursorInput>>;
  where?: InputMaybe<SlotsBoolExp>;
};


export type SubscriptionRootStatsArgs = {
  distinct_on?: InputMaybe<Array<StatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StatsOrderBy>>;
  where?: InputMaybe<StatsBoolExp>;
};


export type SubscriptionRootStatsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StatsOrderBy>>;
  where?: InputMaybe<StatsBoolExp>;
};


export type SubscriptionRootStatsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootStatsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<StatsStreamCursorInput>>;
  where?: InputMaybe<StatsBoolExp>;
};


export type SubscriptionRootStudentClassSessionsArgs = {
  distinct_on?: InputMaybe<Array<StudentClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassSessionsOrderBy>>;
  where?: InputMaybe<StudentClassSessionsBoolExp>;
};


export type SubscriptionRootStudentClassSessionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentClassSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassSessionsOrderBy>>;
  where?: InputMaybe<StudentClassSessionsBoolExp>;
};


export type SubscriptionRootStudentClassSessionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootStudentClassSessionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<StudentClassSessionsStreamCursorInput>>;
  where?: InputMaybe<StudentClassSessionsBoolExp>;
};


export type SubscriptionRootStudentClassesArgs = {
  distinct_on?: InputMaybe<Array<StudentClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassesOrderBy>>;
  where?: InputMaybe<StudentClassesBoolExp>;
};


export type SubscriptionRootStudentClassesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentClassesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentClassesOrderBy>>;
  where?: InputMaybe<StudentClassesBoolExp>;
};


export type SubscriptionRootStudentClassesByPkArgs = {
  classId: Scalars['Int']['input'];
  studentId: Scalars['Int']['input'];
};


export type SubscriptionRootStudentClassesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<StudentClassesStreamCursorInput>>;
  where?: InputMaybe<StudentClassesBoolExp>;
};


export type SubscriptionRootStudentFavoriteTeachersArgs = {
  distinct_on?: InputMaybe<Array<StudentFavoriteTeachersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentFavoriteTeachersOrderBy>>;
  where?: InputMaybe<StudentFavoriteTeachersBoolExp>;
};


export type SubscriptionRootStudentFavoriteTeachersAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentFavoriteTeachersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentFavoriteTeachersOrderBy>>;
  where?: InputMaybe<StudentFavoriteTeachersBoolExp>;
};


export type SubscriptionRootStudentFavoriteTeachersByPkArgs = {
  studentId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


export type SubscriptionRootStudentFavoriteTeachersStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<StudentFavoriteTeachersStreamCursorInput>>;
  where?: InputMaybe<StudentFavoriteTeachersBoolExp>;
};


export type SubscriptionRootStudentLiveClassActivitiesArgs = {
  distinct_on?: InputMaybe<Array<StudentLiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentLiveClassActivitiesOrderBy>>;
  where?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
};


export type SubscriptionRootStudentLiveClassActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StudentLiveClassActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<StudentLiveClassActivitiesOrderBy>>;
  where?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
};


export type SubscriptionRootStudentLiveClassActivitiesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootStudentLiveClassActivitiesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<StudentLiveClassActivitiesStreamCursorInput>>;
  where?: InputMaybe<StudentLiveClassActivitiesBoolExp>;
};


export type SubscriptionRootSubjectsArgs = {
  distinct_on?: InputMaybe<Array<SubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SubjectsOrderBy>>;
  where?: InputMaybe<SubjectsBoolExp>;
};


export type SubscriptionRootSubjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SubjectsOrderBy>>;
  where?: InputMaybe<SubjectsBoolExp>;
};


export type SubscriptionRootSubjectsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootSubjectsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SubjectsStreamCursorInput>>;
  where?: InputMaybe<SubjectsBoolExp>;
};


export type SubscriptionRootSubscriptionsArgs = {
  distinct_on?: InputMaybe<Array<SubscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SubscriptionsOrderBy>>;
  where?: InputMaybe<SubscriptionsBoolExp>;
};


export type SubscriptionRootSubscriptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SubscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SubscriptionsOrderBy>>;
  where?: InputMaybe<SubscriptionsBoolExp>;
};


export type SubscriptionRootSubscriptionsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootSubscriptionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SubscriptionsStreamCursorInput>>;
  where?: InputMaybe<SubscriptionsBoolExp>;
};


export type SubscriptionRootSynonymsArgs = {
  distinct_on?: InputMaybe<Array<SynonymsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SynonymsOrderBy>>;
  where?: InputMaybe<SynonymsBoolExp>;
};


export type SubscriptionRootSynonymsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SynonymsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SynonymsOrderBy>>;
  where?: InputMaybe<SynonymsBoolExp>;
};


export type SubscriptionRootSynonymsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootSynonymsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SynonymsStreamCursorInput>>;
  where?: InputMaybe<SynonymsBoolExp>;
};


export type SubscriptionRootTeacherCredentialsArgs = {
  distinct_on?: InputMaybe<Array<TeacherCredentialsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherCredentialsOrderBy>>;
  where?: InputMaybe<TeacherCredentialsBoolExp>;
};


export type SubscriptionRootTeacherCredentialsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherCredentialsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherCredentialsOrderBy>>;
  where?: InputMaybe<TeacherCredentialsBoolExp>;
};


export type SubscriptionRootTeacherCredentialsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootTeacherCredentialsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TeacherCredentialsStreamCursorInput>>;
  where?: InputMaybe<TeacherCredentialsBoolExp>;
};


export type SubscriptionRootTeacherEducationArgs = {
  distinct_on?: InputMaybe<Array<TeacherEducationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherEducationOrderBy>>;
  where?: InputMaybe<TeacherEducationBoolExp>;
};


export type SubscriptionRootTeacherEducationAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherEducationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherEducationOrderBy>>;
  where?: InputMaybe<TeacherEducationBoolExp>;
};


export type SubscriptionRootTeacherEducationByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootTeacherEducationStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TeacherEducationStreamCursorInput>>;
  where?: InputMaybe<TeacherEducationBoolExp>;
};


export type SubscriptionRootTeacherInterestsArgs = {
  distinct_on?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherInterestsOrderBy>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};


export type SubscriptionRootTeacherInterestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherInterestsOrderBy>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};


export type SubscriptionRootTeacherInterestsByPkArgs = {
  interestId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


export type SubscriptionRootTeacherInterestsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TeacherInterestsStreamCursorInput>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};


export type SubscriptionRootTeacherLanguagesArgs = {
  distinct_on?: InputMaybe<Array<TeacherLanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherLanguagesOrderBy>>;
  where?: InputMaybe<TeacherLanguagesBoolExp>;
};


export type SubscriptionRootTeacherLanguagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherLanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherLanguagesOrderBy>>;
  where?: InputMaybe<TeacherLanguagesBoolExp>;
};


export type SubscriptionRootTeacherLanguagesByPkArgs = {
  languageId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


export type SubscriptionRootTeacherLanguagesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TeacherLanguagesStreamCursorInput>>;
  where?: InputMaybe<TeacherLanguagesBoolExp>;
};


export type SubscriptionRootTeacherSubjectsArgs = {
  distinct_on?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherSubjectsOrderBy>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};


export type SubscriptionRootTeacherSubjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherSubjectsOrderBy>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};


export type SubscriptionRootTeacherSubjectsByPkArgs = {
  subjectId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};


export type SubscriptionRootTeacherSubjectsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TeacherSubjectsStreamCursorInput>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};


export type SubscriptionRootTeachersArgs = {
  distinct_on?: InputMaybe<Array<TeachersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeachersOrderBy>>;
  where?: InputMaybe<TeachersBoolExp>;
};


export type SubscriptionRootTeachersAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeachersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeachersOrderBy>>;
  where?: InputMaybe<TeachersBoolExp>;
};


export type SubscriptionRootTeachersByPkArgs = {
  userId: Scalars['Int']['input'];
};


export type SubscriptionRootTeachersStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TeachersStreamCursorInput>>;
  where?: InputMaybe<TeachersBoolExp>;
};


export type SubscriptionRootUserCoursesArgs = {
  distinct_on?: InputMaybe<Array<UserCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserCoursesOrderBy>>;
  where?: InputMaybe<UserCoursesBoolExp>;
};


export type SubscriptionRootUserCoursesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserCoursesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserCoursesOrderBy>>;
  where?: InputMaybe<UserCoursesBoolExp>;
};


export type SubscriptionRootUserCoursesByPkArgs = {
  courseId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


export type SubscriptionRootUserCoursesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserCoursesStreamCursorInput>>;
  where?: InputMaybe<UserCoursesBoolExp>;
};


export type SubscriptionRootUserDevicesArgs = {
  distinct_on?: InputMaybe<Array<UserDevicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDevicesOrderBy>>;
  where?: InputMaybe<UserDevicesBoolExp>;
};


export type SubscriptionRootUserDevicesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserDevicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDevicesOrderBy>>;
  where?: InputMaybe<UserDevicesBoolExp>;
};


export type SubscriptionRootUserDevicesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootUserDevicesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserDevicesStreamCursorInput>>;
  where?: InputMaybe<UserDevicesBoolExp>;
};


export type SubscriptionRootUserDictionariesArgs = {
  distinct_on?: InputMaybe<Array<UserDictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDictionariesOrderBy>>;
  where?: InputMaybe<UserDictionariesBoolExp>;
};


export type SubscriptionRootUserDictionariesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserDictionariesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserDictionariesOrderBy>>;
  where?: InputMaybe<UserDictionariesBoolExp>;
};


export type SubscriptionRootUserDictionariesByPkArgs = {
  dictionaryId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


export type SubscriptionRootUserDictionariesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserDictionariesStreamCursorInput>>;
  where?: InputMaybe<UserDictionariesBoolExp>;
};


export type SubscriptionRootUserMessagesArgs = {
  distinct_on?: InputMaybe<Array<UserMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserMessagesOrderBy>>;
  where?: InputMaybe<UserMessagesBoolExp>;
};


export type SubscriptionRootUserMessagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserMessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserMessagesOrderBy>>;
  where?: InputMaybe<UserMessagesBoolExp>;
};


export type SubscriptionRootUserMessagesByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootUserMessagesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserMessagesStreamCursorInput>>;
  where?: InputMaybe<UserMessagesBoolExp>;
};


export type SubscriptionRootUserWordsArgs = {
  distinct_on?: InputMaybe<Array<UserWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsOrderBy>>;
  where?: InputMaybe<UserWordsBoolExp>;
};


export type SubscriptionRootUserWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsOrderBy>>;
  where?: InputMaybe<UserWordsBoolExp>;
};


export type SubscriptionRootUserWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootUserWordsCountArgs = {
  distinct_on?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsCountOrderBy>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type SubscriptionRootUserWordsCountAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsCountOrderBy>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type SubscriptionRootUserWordsCountByPkArgs = {
  date: Scalars['date']['input'];
};


export type SubscriptionRootUserWordsCountStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserWordsCountStreamCursorInput>>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};


export type SubscriptionRootUserWordsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserWordsStreamCursorInput>>;
  where?: InputMaybe<UserWordsBoolExp>;
};


export type SubscriptionRootUsersArgs = {
  distinct_on?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type SubscriptionRootUsersAggregateArgs = {
  distinct_on?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type SubscriptionRootUsersByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootUsersStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UsersStreamCursorInput>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type SubscriptionRootVocabularySetsArgs = {
  distinct_on?: InputMaybe<Array<VocabularySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularySetsOrderBy>>;
  where?: InputMaybe<VocabularySetsBoolExp>;
};


export type SubscriptionRootVocabularySetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<VocabularySetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularySetsOrderBy>>;
  where?: InputMaybe<VocabularySetsBoolExp>;
};


export type SubscriptionRootVocabularySetsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootVocabularySetsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<VocabularySetsStreamCursorInput>>;
  where?: InputMaybe<VocabularySetsBoolExp>;
};


export type SubscriptionRootVocabularyWordsArgs = {
  distinct_on?: InputMaybe<Array<VocabularyWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularyWordsOrderBy>>;
  where?: InputMaybe<VocabularyWordsBoolExp>;
};


export type SubscriptionRootVocabularyWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<VocabularyWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularyWordsOrderBy>>;
  where?: InputMaybe<VocabularyWordsBoolExp>;
};


export type SubscriptionRootVocabularyWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootVocabularyWordsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<VocabularyWordsStreamCursorInput>>;
  where?: InputMaybe<VocabularyWordsBoolExp>;
};


export type SubscriptionRootWordnetEnglishWordsArgs = {
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type SubscriptionRootWordnetEnglishWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type SubscriptionRootWordnetEnglishWordsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootWordnetEnglishWordsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<WordnetEnglishWordsStreamCursorInput>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type SubscriptionRootWordnetSearchWordnetEnglishArgs = {
  args: WordnetSearchWordnetEnglishArgs;
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type SubscriptionRootWordnetSearchWordnetEnglishAggregateArgs = {
  args: WordnetSearchWordnetEnglishArgs;
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


export type SubscriptionRootWordnetSynsetsArgs = {
  distinct_on?: InputMaybe<Array<WordnetSynsetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetSynsetsOrderBy>>;
  where?: InputMaybe<WordnetSynsetsBoolExp>;
};


export type SubscriptionRootWordnetSynsetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<WordnetSynsetsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetSynsetsOrderBy>>;
  where?: InputMaybe<WordnetSynsetsBoolExp>;
};


export type SubscriptionRootWordnetSynsetsByPkArgs = {
  id: Scalars['Int']['input'];
};


export type SubscriptionRootWordnetSynsetsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<WordnetSynsetsStreamCursorInput>>;
  where?: InputMaybe<WordnetSynsetsBoolExp>;
};

/** columns and relationships of "subscriptions" */
export type Subscriptions = {
  __typename?: 'subscriptions';
  amount: Scalars['Int']['output'];
  canceledAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  currency: Scalars['String']['output'];
  currentPeriodEnd: Scalars['timestamptz']['output'];
  currentPeriodStart: Scalars['timestamptz']['output'];
  daysUntilDue: Scalars['Int']['output'];
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['Int']['output'];
  isApple: Scalars['Boolean']['output'];
  isGoogle: Scalars['Boolean']['output'];
  isStripe: Scalars['Boolean']['output'];
  startedAt: Scalars['timestamptz']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "subscriptions" */
export type SubscriptionsAggregate = {
  __typename?: 'subscriptions_aggregate';
  aggregate?: Maybe<SubscriptionsAggregateFields>;
  nodes: Array<Subscriptions>;
};

/** aggregate fields of "subscriptions" */
export type SubscriptionsAggregateFields = {
  __typename?: 'subscriptions_aggregate_fields';
  avg?: Maybe<SubscriptionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<SubscriptionsMaxFields>;
  min?: Maybe<SubscriptionsMinFields>;
  stddev?: Maybe<SubscriptionsStddevFields>;
  stddev_pop?: Maybe<SubscriptionsStddevPopFields>;
  stddev_samp?: Maybe<SubscriptionsStddevSampFields>;
  sum?: Maybe<SubscriptionsSumFields>;
  var_pop?: Maybe<SubscriptionsVarPopFields>;
  var_samp?: Maybe<SubscriptionsVarSampFields>;
  variance?: Maybe<SubscriptionsVarianceFields>;
};


/** aggregate fields of "subscriptions" */
export type SubscriptionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SubscriptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type SubscriptionsAvgFields = {
  __typename?: 'subscriptions_avg_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  daysUntilDue?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "subscriptions". All fields are combined with a logical 'AND'. */
export type SubscriptionsBoolExp = {
  _and?: InputMaybe<Array<SubscriptionsBoolExp>>;
  _not?: InputMaybe<SubscriptionsBoolExp>;
  _or?: InputMaybe<Array<SubscriptionsBoolExp>>;
  amount?: InputMaybe<IntComparisonExp>;
  canceledAt?: InputMaybe<TimestamptzComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  currentPeriodEnd?: InputMaybe<TimestamptzComparisonExp>;
  currentPeriodStart?: InputMaybe<TimestamptzComparisonExp>;
  daysUntilDue?: InputMaybe<IntComparisonExp>;
  endedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  isApple?: InputMaybe<BooleanComparisonExp>;
  isGoogle?: InputMaybe<BooleanComparisonExp>;
  isStripe?: InputMaybe<BooleanComparisonExp>;
  startedAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "subscriptions" */
export enum SubscriptionsConstraint {
  /** unique or primary key constraint on columns "id" */
  SubscriptionsPkey = 'subscriptions_pkey'
}

/** input type for incrementing numeric columns in table "subscriptions" */
export type SubscriptionsIncInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  daysUntilDue?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "subscriptions" */
export type SubscriptionsInsertInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  currentPeriodEnd?: InputMaybe<Scalars['timestamptz']['input']>;
  currentPeriodStart?: InputMaybe<Scalars['timestamptz']['input']>;
  daysUntilDue?: InputMaybe<Scalars['Int']['input']>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isApple?: InputMaybe<Scalars['Boolean']['input']>;
  isGoogle?: InputMaybe<Scalars['Boolean']['input']>;
  isStripe?: InputMaybe<Scalars['Boolean']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type SubscriptionsMaxFields = {
  __typename?: 'subscriptions_max_fields';
  amount?: Maybe<Scalars['Int']['output']>;
  canceledAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  currentPeriodEnd?: Maybe<Scalars['timestamptz']['output']>;
  currentPeriodStart?: Maybe<Scalars['timestamptz']['output']>;
  daysUntilDue?: Maybe<Scalars['Int']['output']>;
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type SubscriptionsMinFields = {
  __typename?: 'subscriptions_min_fields';
  amount?: Maybe<Scalars['Int']['output']>;
  canceledAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  currentPeriodEnd?: Maybe<Scalars['timestamptz']['output']>;
  currentPeriodStart?: Maybe<Scalars['timestamptz']['output']>;
  daysUntilDue?: Maybe<Scalars['Int']['output']>;
  endedAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "subscriptions" */
export type SubscriptionsMutationResponse = {
  __typename?: 'subscriptions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Subscriptions>;
};

/** on_conflict condition type for table "subscriptions" */
export type SubscriptionsOnConflict = {
  constraint: SubscriptionsConstraint;
  update_columns?: Array<SubscriptionsUpdateColumn>;
  where?: InputMaybe<SubscriptionsBoolExp>;
};

/** Ordering options when selecting data from "subscriptions". */
export type SubscriptionsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  canceledAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  currentPeriodEnd?: InputMaybe<OrderBy>;
  currentPeriodStart?: InputMaybe<OrderBy>;
  daysUntilDue?: InputMaybe<OrderBy>;
  endedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isApple?: InputMaybe<OrderBy>;
  isGoogle?: InputMaybe<OrderBy>;
  isStripe?: InputMaybe<OrderBy>;
  startedAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: subscriptions */
export type SubscriptionsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "subscriptions" */
export enum SubscriptionsSelectColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Currency = 'currency',
  /** column name */
  CurrentPeriodEnd = 'currentPeriodEnd',
  /** column name */
  CurrentPeriodStart = 'currentPeriodStart',
  /** column name */
  DaysUntilDue = 'daysUntilDue',
  /** column name */
  EndedAt = 'endedAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsApple = 'isApple',
  /** column name */
  IsGoogle = 'isGoogle',
  /** column name */
  IsStripe = 'isStripe',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "subscriptions" */
export type SubscriptionsSetInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  currentPeriodEnd?: InputMaybe<Scalars['timestamptz']['input']>;
  currentPeriodStart?: InputMaybe<Scalars['timestamptz']['input']>;
  daysUntilDue?: InputMaybe<Scalars['Int']['input']>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isApple?: InputMaybe<Scalars['Boolean']['input']>;
  isGoogle?: InputMaybe<Scalars['Boolean']['input']>;
  isStripe?: InputMaybe<Scalars['Boolean']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type SubscriptionsStddevFields = {
  __typename?: 'subscriptions_stddev_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  daysUntilDue?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type SubscriptionsStddevPopFields = {
  __typename?: 'subscriptions_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  daysUntilDue?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type SubscriptionsStddevSampFields = {
  __typename?: 'subscriptions_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  daysUntilDue?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "subscriptions" */
export type SubscriptionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SubscriptionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SubscriptionsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['Int']['input']>;
  canceledAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  currentPeriodEnd?: InputMaybe<Scalars['timestamptz']['input']>;
  currentPeriodStart?: InputMaybe<Scalars['timestamptz']['input']>;
  daysUntilDue?: InputMaybe<Scalars['Int']['input']>;
  endedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isApple?: InputMaybe<Scalars['Boolean']['input']>;
  isGoogle?: InputMaybe<Scalars['Boolean']['input']>;
  isStripe?: InputMaybe<Scalars['Boolean']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type SubscriptionsSumFields = {
  __typename?: 'subscriptions_sum_fields';
  amount?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  daysUntilDue?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "subscriptions" */
export enum SubscriptionsUpdateColumn {
  /** column name */
  Amount = 'amount',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Currency = 'currency',
  /** column name */
  CurrentPeriodEnd = 'currentPeriodEnd',
  /** column name */
  CurrentPeriodStart = 'currentPeriodStart',
  /** column name */
  DaysUntilDue = 'daysUntilDue',
  /** column name */
  EndedAt = 'endedAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsApple = 'isApple',
  /** column name */
  IsGoogle = 'isGoogle',
  /** column name */
  IsStripe = 'isStripe',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type SubscriptionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SubscriptionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SubscriptionsSetInput>;
  /** filter the rows which have to be updated */
  where: SubscriptionsBoolExp;
};

/** aggregate var_pop on columns */
export type SubscriptionsVarPopFields = {
  __typename?: 'subscriptions_var_pop_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  daysUntilDue?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type SubscriptionsVarSampFields = {
  __typename?: 'subscriptions_var_samp_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  daysUntilDue?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type SubscriptionsVarianceFields = {
  __typename?: 'subscriptions_variance_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  daysUntilDue?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "synonyms" */
export type Synonyms = {
  __typename?: 'synonyms';
  headword: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  subject_id: Scalars['Int']['output'];
  words: Scalars['jsonb']['output'];
};


/** columns and relationships of "synonyms" */
export type SynonymsWordsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "synonyms" */
export type SynonymsAggregate = {
  __typename?: 'synonyms_aggregate';
  aggregate?: Maybe<SynonymsAggregateFields>;
  nodes: Array<Synonyms>;
};

/** aggregate fields of "synonyms" */
export type SynonymsAggregateFields = {
  __typename?: 'synonyms_aggregate_fields';
  avg?: Maybe<SynonymsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<SynonymsMaxFields>;
  min?: Maybe<SynonymsMinFields>;
  stddev?: Maybe<SynonymsStddevFields>;
  stddev_pop?: Maybe<SynonymsStddevPopFields>;
  stddev_samp?: Maybe<SynonymsStddevSampFields>;
  sum?: Maybe<SynonymsSumFields>;
  var_pop?: Maybe<SynonymsVarPopFields>;
  var_samp?: Maybe<SynonymsVarSampFields>;
  variance?: Maybe<SynonymsVarianceFields>;
};


/** aggregate fields of "synonyms" */
export type SynonymsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SynonymsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SynonymsAppendInput = {
  words?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type SynonymsAvgFields = {
  __typename?: 'synonyms_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  subject_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "synonyms". All fields are combined with a logical 'AND'. */
export type SynonymsBoolExp = {
  _and?: InputMaybe<Array<SynonymsBoolExp>>;
  _not?: InputMaybe<SynonymsBoolExp>;
  _or?: InputMaybe<Array<SynonymsBoolExp>>;
  headword?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  subject_id?: InputMaybe<IntComparisonExp>;
  words?: InputMaybe<JsonbComparisonExp>;
};

/** unique or primary key constraints on table "synonyms" */
export enum SynonymsConstraint {
  /** unique or primary key constraint on columns "id" */
  SynonymsPkey = 'synonyms_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SynonymsDeleteAtPathInput = {
  words?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SynonymsDeleteElemInput = {
  words?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SynonymsDeleteKeyInput = {
  words?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "synonyms" */
export type SynonymsIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  subject_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "synonyms" */
export type SynonymsInsertInput = {
  headword?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  subject_id?: InputMaybe<Scalars['Int']['input']>;
  words?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate max on columns */
export type SynonymsMaxFields = {
  __typename?: 'synonyms_max_fields';
  headword?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  subject_id?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type SynonymsMinFields = {
  __typename?: 'synonyms_min_fields';
  headword?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  subject_id?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "synonyms" */
export type SynonymsMutationResponse = {
  __typename?: 'synonyms_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Synonyms>;
};

/** on_conflict condition type for table "synonyms" */
export type SynonymsOnConflict = {
  constraint: SynonymsConstraint;
  update_columns?: Array<SynonymsUpdateColumn>;
  where?: InputMaybe<SynonymsBoolExp>;
};

/** Ordering options when selecting data from "synonyms". */
export type SynonymsOrderBy = {
  headword?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  subject_id?: InputMaybe<OrderBy>;
  words?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: synonyms */
export type SynonymsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SynonymsPrependInput = {
  words?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "synonyms" */
export enum SynonymsSelectColumn {
  /** column name */
  Headword = 'headword',
  /** column name */
  Id = 'id',
  /** column name */
  SubjectId = 'subject_id',
  /** column name */
  Words = 'words'
}

/** input type for updating data in table "synonyms" */
export type SynonymsSetInput = {
  headword?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  subject_id?: InputMaybe<Scalars['Int']['input']>;
  words?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate stddev on columns */
export type SynonymsStddevFields = {
  __typename?: 'synonyms_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  subject_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type SynonymsStddevPopFields = {
  __typename?: 'synonyms_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  subject_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type SynonymsStddevSampFields = {
  __typename?: 'synonyms_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  subject_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "synonyms" */
export type SynonymsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SynonymsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SynonymsStreamCursorValueInput = {
  headword?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  subject_id?: InputMaybe<Scalars['Int']['input']>;
  words?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate sum on columns */
export type SynonymsSumFields = {
  __typename?: 'synonyms_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  subject_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "synonyms" */
export enum SynonymsUpdateColumn {
  /** column name */
  Headword = 'headword',
  /** column name */
  Id = 'id',
  /** column name */
  SubjectId = 'subject_id',
  /** column name */
  Words = 'words'
}

export type SynonymsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SynonymsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<SynonymsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<SynonymsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<SynonymsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SynonymsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SynonymsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SynonymsSetInput>;
  /** filter the rows which have to be updated */
  where: SynonymsBoolExp;
};

/** aggregate var_pop on columns */
export type SynonymsVarPopFields = {
  __typename?: 'synonyms_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  subject_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type SynonymsVarSampFields = {
  __typename?: 'synonyms_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  subject_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type SynonymsVarianceFields = {
  __typename?: 'synonyms_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  subject_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "teacher_credentials" */
export type TeacherCredentials = {
  __typename?: 'teacher_credentials';
  createdAt: Scalars['timestamptz']['output'];
  credentialUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  teacherId: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "teacher_credentials" */
export type TeacherCredentialsAggregate = {
  __typename?: 'teacher_credentials_aggregate';
  aggregate?: Maybe<TeacherCredentialsAggregateFields>;
  nodes: Array<TeacherCredentials>;
};

export type TeacherCredentialsAggregateBoolExp = {
  count?: InputMaybe<TeacherCredentialsAggregateBoolExpCount>;
};

export type TeacherCredentialsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TeacherCredentialsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TeacherCredentialsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "teacher_credentials" */
export type TeacherCredentialsAggregateFields = {
  __typename?: 'teacher_credentials_aggregate_fields';
  avg?: Maybe<TeacherCredentialsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TeacherCredentialsMaxFields>;
  min?: Maybe<TeacherCredentialsMinFields>;
  stddev?: Maybe<TeacherCredentialsStddevFields>;
  stddev_pop?: Maybe<TeacherCredentialsStddevPopFields>;
  stddev_samp?: Maybe<TeacherCredentialsStddevSampFields>;
  sum?: Maybe<TeacherCredentialsSumFields>;
  var_pop?: Maybe<TeacherCredentialsVarPopFields>;
  var_samp?: Maybe<TeacherCredentialsVarSampFields>;
  variance?: Maybe<TeacherCredentialsVarianceFields>;
};


/** aggregate fields of "teacher_credentials" */
export type TeacherCredentialsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TeacherCredentialsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "teacher_credentials" */
export type TeacherCredentialsAggregateOrderBy = {
  avg?: InputMaybe<TeacherCredentialsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TeacherCredentialsMaxOrderBy>;
  min?: InputMaybe<TeacherCredentialsMinOrderBy>;
  stddev?: InputMaybe<TeacherCredentialsStddevOrderBy>;
  stddev_pop?: InputMaybe<TeacherCredentialsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<TeacherCredentialsStddevSampOrderBy>;
  sum?: InputMaybe<TeacherCredentialsSumOrderBy>;
  var_pop?: InputMaybe<TeacherCredentialsVarPopOrderBy>;
  var_samp?: InputMaybe<TeacherCredentialsVarSampOrderBy>;
  variance?: InputMaybe<TeacherCredentialsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "teacher_credentials" */
export type TeacherCredentialsArrRelInsertInput = {
  data: Array<TeacherCredentialsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TeacherCredentialsOnConflict>;
};

/** aggregate avg on columns */
export type TeacherCredentialsAvgFields = {
  __typename?: 'teacher_credentials_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "teacher_credentials" */
export type TeacherCredentialsAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "teacher_credentials". All fields are combined with a logical 'AND'. */
export type TeacherCredentialsBoolExp = {
  _and?: InputMaybe<Array<TeacherCredentialsBoolExp>>;
  _not?: InputMaybe<TeacherCredentialsBoolExp>;
  _or?: InputMaybe<Array<TeacherCredentialsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  credentialUrl?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "teacher_credentials" */
export enum TeacherCredentialsConstraint {
  /** unique or primary key constraint on columns "id" */
  TeacherCredentialsPkey = 'teacher_credentials_pkey'
}

/** input type for incrementing numeric columns in table "teacher_credentials" */
export type TeacherCredentialsIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "teacher_credentials" */
export type TeacherCredentialsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  credentialUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type TeacherCredentialsMaxFields = {
  __typename?: 'teacher_credentials_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  credentialUrl?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "teacher_credentials" */
export type TeacherCredentialsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  credentialUrl?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TeacherCredentialsMinFields = {
  __typename?: 'teacher_credentials_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  credentialUrl?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "teacher_credentials" */
export type TeacherCredentialsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  credentialUrl?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "teacher_credentials" */
export type TeacherCredentialsMutationResponse = {
  __typename?: 'teacher_credentials_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TeacherCredentials>;
};

/** on_conflict condition type for table "teacher_credentials" */
export type TeacherCredentialsOnConflict = {
  constraint: TeacherCredentialsConstraint;
  update_columns?: Array<TeacherCredentialsUpdateColumn>;
  where?: InputMaybe<TeacherCredentialsBoolExp>;
};

/** Ordering options when selecting data from "teacher_credentials". */
export type TeacherCredentialsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  credentialUrl?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: teacher_credentials */
export type TeacherCredentialsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "teacher_credentials" */
export enum TeacherCredentialsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CredentialUrl = 'credentialUrl',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "teacher_credentials" */
export type TeacherCredentialsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  credentialUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type TeacherCredentialsStddevFields = {
  __typename?: 'teacher_credentials_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "teacher_credentials" */
export type TeacherCredentialsStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TeacherCredentialsStddevPopFields = {
  __typename?: 'teacher_credentials_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "teacher_credentials" */
export type TeacherCredentialsStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TeacherCredentialsStddevSampFields = {
  __typename?: 'teacher_credentials_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "teacher_credentials" */
export type TeacherCredentialsStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "teacher_credentials" */
export type TeacherCredentialsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TeacherCredentialsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeacherCredentialsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  credentialUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type TeacherCredentialsSumFields = {
  __typename?: 'teacher_credentials_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "teacher_credentials" */
export type TeacherCredentialsSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** update columns of table "teacher_credentials" */
export enum TeacherCredentialsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CredentialUrl = 'credentialUrl',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type TeacherCredentialsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TeacherCredentialsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TeacherCredentialsSetInput>;
  /** filter the rows which have to be updated */
  where: TeacherCredentialsBoolExp;
};

/** aggregate var_pop on columns */
export type TeacherCredentialsVarPopFields = {
  __typename?: 'teacher_credentials_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "teacher_credentials" */
export type TeacherCredentialsVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TeacherCredentialsVarSampFields = {
  __typename?: 'teacher_credentials_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "teacher_credentials" */
export type TeacherCredentialsVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TeacherCredentialsVarianceFields = {
  __typename?: 'teacher_credentials_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "teacher_credentials" */
export type TeacherCredentialsVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "teacher_education" */
export type TeacherEducation = {
  __typename?: 'teacher_education';
  createdAt: Scalars['timestamptz']['output'];
  diplomaUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  institution: Scalars['String']['output'];
  level: Scalars['String']['output'];
  teacherId: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "teacher_education" */
export type TeacherEducationAggregate = {
  __typename?: 'teacher_education_aggregate';
  aggregate?: Maybe<TeacherEducationAggregateFields>;
  nodes: Array<TeacherEducation>;
};

export type TeacherEducationAggregateBoolExp = {
  count?: InputMaybe<TeacherEducationAggregateBoolExpCount>;
};

export type TeacherEducationAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TeacherEducationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TeacherEducationBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "teacher_education" */
export type TeacherEducationAggregateFields = {
  __typename?: 'teacher_education_aggregate_fields';
  avg?: Maybe<TeacherEducationAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TeacherEducationMaxFields>;
  min?: Maybe<TeacherEducationMinFields>;
  stddev?: Maybe<TeacherEducationStddevFields>;
  stddev_pop?: Maybe<TeacherEducationStddevPopFields>;
  stddev_samp?: Maybe<TeacherEducationStddevSampFields>;
  sum?: Maybe<TeacherEducationSumFields>;
  var_pop?: Maybe<TeacherEducationVarPopFields>;
  var_samp?: Maybe<TeacherEducationVarSampFields>;
  variance?: Maybe<TeacherEducationVarianceFields>;
};


/** aggregate fields of "teacher_education" */
export type TeacherEducationAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TeacherEducationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "teacher_education" */
export type TeacherEducationAggregateOrderBy = {
  avg?: InputMaybe<TeacherEducationAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TeacherEducationMaxOrderBy>;
  min?: InputMaybe<TeacherEducationMinOrderBy>;
  stddev?: InputMaybe<TeacherEducationStddevOrderBy>;
  stddev_pop?: InputMaybe<TeacherEducationStddevPopOrderBy>;
  stddev_samp?: InputMaybe<TeacherEducationStddevSampOrderBy>;
  sum?: InputMaybe<TeacherEducationSumOrderBy>;
  var_pop?: InputMaybe<TeacherEducationVarPopOrderBy>;
  var_samp?: InputMaybe<TeacherEducationVarSampOrderBy>;
  variance?: InputMaybe<TeacherEducationVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "teacher_education" */
export type TeacherEducationArrRelInsertInput = {
  data: Array<TeacherEducationInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TeacherEducationOnConflict>;
};

/** aggregate avg on columns */
export type TeacherEducationAvgFields = {
  __typename?: 'teacher_education_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "teacher_education" */
export type TeacherEducationAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "teacher_education". All fields are combined with a logical 'AND'. */
export type TeacherEducationBoolExp = {
  _and?: InputMaybe<Array<TeacherEducationBoolExp>>;
  _not?: InputMaybe<TeacherEducationBoolExp>;
  _or?: InputMaybe<Array<TeacherEducationBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  diplomaUrl?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  institution?: InputMaybe<StringComparisonExp>;
  level?: InputMaybe<StringComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "teacher_education" */
export enum TeacherEducationConstraint {
  /** unique or primary key constraint on columns "id" */
  TeacherEducationPkey = 'teacher_education_pkey'
}

/** input type for incrementing numeric columns in table "teacher_education" */
export type TeacherEducationIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "teacher_education" */
export type TeacherEducationInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  diplomaUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type TeacherEducationMaxFields = {
  __typename?: 'teacher_education_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  diplomaUrl?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  institution?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "teacher_education" */
export type TeacherEducationMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  diplomaUrl?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  institution?: InputMaybe<OrderBy>;
  level?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TeacherEducationMinFields = {
  __typename?: 'teacher_education_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  diplomaUrl?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  institution?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['String']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "teacher_education" */
export type TeacherEducationMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  diplomaUrl?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  institution?: InputMaybe<OrderBy>;
  level?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "teacher_education" */
export type TeacherEducationMutationResponse = {
  __typename?: 'teacher_education_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TeacherEducation>;
};

/** on_conflict condition type for table "teacher_education" */
export type TeacherEducationOnConflict = {
  constraint: TeacherEducationConstraint;
  update_columns?: Array<TeacherEducationUpdateColumn>;
  where?: InputMaybe<TeacherEducationBoolExp>;
};

/** Ordering options when selecting data from "teacher_education". */
export type TeacherEducationOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  diplomaUrl?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  institution?: InputMaybe<OrderBy>;
  level?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: teacher_education */
export type TeacherEducationPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "teacher_education" */
export enum TeacherEducationSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DiplomaUrl = 'diplomaUrl',
  /** column name */
  Id = 'id',
  /** column name */
  Institution = 'institution',
  /** column name */
  Level = 'level',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "teacher_education" */
export type TeacherEducationSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  diplomaUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type TeacherEducationStddevFields = {
  __typename?: 'teacher_education_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "teacher_education" */
export type TeacherEducationStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TeacherEducationStddevPopFields = {
  __typename?: 'teacher_education_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "teacher_education" */
export type TeacherEducationStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TeacherEducationStddevSampFields = {
  __typename?: 'teacher_education_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "teacher_education" */
export type TeacherEducationStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "teacher_education" */
export type TeacherEducationStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TeacherEducationStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeacherEducationStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  diplomaUrl?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type TeacherEducationSumFields = {
  __typename?: 'teacher_education_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "teacher_education" */
export type TeacherEducationSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** update columns of table "teacher_education" */
export enum TeacherEducationUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DiplomaUrl = 'diplomaUrl',
  /** column name */
  Id = 'id',
  /** column name */
  Institution = 'institution',
  /** column name */
  Level = 'level',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type TeacherEducationUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TeacherEducationIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TeacherEducationSetInput>;
  /** filter the rows which have to be updated */
  where: TeacherEducationBoolExp;
};

/** aggregate var_pop on columns */
export type TeacherEducationVarPopFields = {
  __typename?: 'teacher_education_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "teacher_education" */
export type TeacherEducationVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TeacherEducationVarSampFields = {
  __typename?: 'teacher_education_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "teacher_education" */
export type TeacherEducationVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TeacherEducationVarianceFields = {
  __typename?: 'teacher_education_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "teacher_education" */
export type TeacherEducationVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "teacher_interests" */
export type TeacherInterests = {
  __typename?: 'teacher_interests';
  /** An object relationship */
  interest: Interests;
  interestId: Scalars['Int']['output'];
  teacherId: Scalars['Int']['output'];
};

/** aggregated selection of "teacher_interests" */
export type TeacherInterestsAggregate = {
  __typename?: 'teacher_interests_aggregate';
  aggregate?: Maybe<TeacherInterestsAggregateFields>;
  nodes: Array<TeacherInterests>;
};

export type TeacherInterestsAggregateBoolExp = {
  count?: InputMaybe<TeacherInterestsAggregateBoolExpCount>;
};

export type TeacherInterestsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TeacherInterestsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "teacher_interests" */
export type TeacherInterestsAggregateFields = {
  __typename?: 'teacher_interests_aggregate_fields';
  avg?: Maybe<TeacherInterestsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TeacherInterestsMaxFields>;
  min?: Maybe<TeacherInterestsMinFields>;
  stddev?: Maybe<TeacherInterestsStddevFields>;
  stddev_pop?: Maybe<TeacherInterestsStddevPopFields>;
  stddev_samp?: Maybe<TeacherInterestsStddevSampFields>;
  sum?: Maybe<TeacherInterestsSumFields>;
  var_pop?: Maybe<TeacherInterestsVarPopFields>;
  var_samp?: Maybe<TeacherInterestsVarSampFields>;
  variance?: Maybe<TeacherInterestsVarianceFields>;
};


/** aggregate fields of "teacher_interests" */
export type TeacherInterestsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "teacher_interests" */
export type TeacherInterestsAggregateOrderBy = {
  avg?: InputMaybe<TeacherInterestsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TeacherInterestsMaxOrderBy>;
  min?: InputMaybe<TeacherInterestsMinOrderBy>;
  stddev?: InputMaybe<TeacherInterestsStddevOrderBy>;
  stddev_pop?: InputMaybe<TeacherInterestsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<TeacherInterestsStddevSampOrderBy>;
  sum?: InputMaybe<TeacherInterestsSumOrderBy>;
  var_pop?: InputMaybe<TeacherInterestsVarPopOrderBy>;
  var_samp?: InputMaybe<TeacherInterestsVarSampOrderBy>;
  variance?: InputMaybe<TeacherInterestsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "teacher_interests" */
export type TeacherInterestsArrRelInsertInput = {
  data: Array<TeacherInterestsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TeacherInterestsOnConflict>;
};

/** aggregate avg on columns */
export type TeacherInterestsAvgFields = {
  __typename?: 'teacher_interests_avg_fields';
  interestId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "teacher_interests" */
export type TeacherInterestsAvgOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "teacher_interests". All fields are combined with a logical 'AND'. */
export type TeacherInterestsBoolExp = {
  _and?: InputMaybe<Array<TeacherInterestsBoolExp>>;
  _not?: InputMaybe<TeacherInterestsBoolExp>;
  _or?: InputMaybe<Array<TeacherInterestsBoolExp>>;
  interest?: InputMaybe<InterestsBoolExp>;
  interestId?: InputMaybe<IntComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "teacher_interests" */
export enum TeacherInterestsConstraint {
  /** unique or primary key constraint on columns "teacher_id", "interest_id" */
  TeacherInterestsPkey = 'teacher_interests_pkey'
}

/** input type for incrementing numeric columns in table "teacher_interests" */
export type TeacherInterestsIncInput = {
  interestId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "teacher_interests" */
export type TeacherInterestsInsertInput = {
  interest?: InputMaybe<InterestsObjRelInsertInput>;
  interestId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type TeacherInterestsMaxFields = {
  __typename?: 'teacher_interests_max_fields';
  interestId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "teacher_interests" */
export type TeacherInterestsMaxOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TeacherInterestsMinFields = {
  __typename?: 'teacher_interests_min_fields';
  interestId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "teacher_interests" */
export type TeacherInterestsMinOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "teacher_interests" */
export type TeacherInterestsMutationResponse = {
  __typename?: 'teacher_interests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TeacherInterests>;
};

/** on_conflict condition type for table "teacher_interests" */
export type TeacherInterestsOnConflict = {
  constraint: TeacherInterestsConstraint;
  update_columns?: Array<TeacherInterestsUpdateColumn>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};

/** Ordering options when selecting data from "teacher_interests". */
export type TeacherInterestsOrderBy = {
  interest?: InputMaybe<InterestsOrderBy>;
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: teacher_interests */
export type TeacherInterestsPkColumnsInput = {
  interestId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};

/** select columns of table "teacher_interests" */
export enum TeacherInterestsSelectColumn {
  /** column name */
  InterestId = 'interestId',
  /** column name */
  TeacherId = 'teacherId'
}

/** input type for updating data in table "teacher_interests" */
export type TeacherInterestsSetInput = {
  interestId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type TeacherInterestsStddevFields = {
  __typename?: 'teacher_interests_stddev_fields';
  interestId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "teacher_interests" */
export type TeacherInterestsStddevOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TeacherInterestsStddevPopFields = {
  __typename?: 'teacher_interests_stddev_pop_fields';
  interestId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "teacher_interests" */
export type TeacherInterestsStddevPopOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TeacherInterestsStddevSampFields = {
  __typename?: 'teacher_interests_stddev_samp_fields';
  interestId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "teacher_interests" */
export type TeacherInterestsStddevSampOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "teacher_interests" */
export type TeacherInterestsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TeacherInterestsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeacherInterestsStreamCursorValueInput = {
  interestId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type TeacherInterestsSumFields = {
  __typename?: 'teacher_interests_sum_fields';
  interestId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "teacher_interests" */
export type TeacherInterestsSumOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** update columns of table "teacher_interests" */
export enum TeacherInterestsUpdateColumn {
  /** column name */
  InterestId = 'interestId',
  /** column name */
  TeacherId = 'teacherId'
}

export type TeacherInterestsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TeacherInterestsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TeacherInterestsSetInput>;
  /** filter the rows which have to be updated */
  where: TeacherInterestsBoolExp;
};

/** aggregate var_pop on columns */
export type TeacherInterestsVarPopFields = {
  __typename?: 'teacher_interests_var_pop_fields';
  interestId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "teacher_interests" */
export type TeacherInterestsVarPopOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TeacherInterestsVarSampFields = {
  __typename?: 'teacher_interests_var_samp_fields';
  interestId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "teacher_interests" */
export type TeacherInterestsVarSampOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TeacherInterestsVarianceFields = {
  __typename?: 'teacher_interests_variance_fields';
  interestId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "teacher_interests" */
export type TeacherInterestsVarianceOrderBy = {
  interestId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "teacher_languages" */
export type TeacherLanguages = {
  __typename?: 'teacher_languages';
  cefr: CefrLevelsEnum;
  /** An object relationship */
  language: Languages;
  languageId: Scalars['Int']['output'];
  teacherId: Scalars['Int']['output'];
};

/** aggregated selection of "teacher_languages" */
export type TeacherLanguagesAggregate = {
  __typename?: 'teacher_languages_aggregate';
  aggregate?: Maybe<TeacherLanguagesAggregateFields>;
  nodes: Array<TeacherLanguages>;
};

export type TeacherLanguagesAggregateBoolExp = {
  count?: InputMaybe<TeacherLanguagesAggregateBoolExpCount>;
};

export type TeacherLanguagesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TeacherLanguagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TeacherLanguagesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "teacher_languages" */
export type TeacherLanguagesAggregateFields = {
  __typename?: 'teacher_languages_aggregate_fields';
  avg?: Maybe<TeacherLanguagesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TeacherLanguagesMaxFields>;
  min?: Maybe<TeacherLanguagesMinFields>;
  stddev?: Maybe<TeacherLanguagesStddevFields>;
  stddev_pop?: Maybe<TeacherLanguagesStddevPopFields>;
  stddev_samp?: Maybe<TeacherLanguagesStddevSampFields>;
  sum?: Maybe<TeacherLanguagesSumFields>;
  var_pop?: Maybe<TeacherLanguagesVarPopFields>;
  var_samp?: Maybe<TeacherLanguagesVarSampFields>;
  variance?: Maybe<TeacherLanguagesVarianceFields>;
};


/** aggregate fields of "teacher_languages" */
export type TeacherLanguagesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TeacherLanguagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "teacher_languages" */
export type TeacherLanguagesAggregateOrderBy = {
  avg?: InputMaybe<TeacherLanguagesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TeacherLanguagesMaxOrderBy>;
  min?: InputMaybe<TeacherLanguagesMinOrderBy>;
  stddev?: InputMaybe<TeacherLanguagesStddevOrderBy>;
  stddev_pop?: InputMaybe<TeacherLanguagesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<TeacherLanguagesStddevSampOrderBy>;
  sum?: InputMaybe<TeacherLanguagesSumOrderBy>;
  var_pop?: InputMaybe<TeacherLanguagesVarPopOrderBy>;
  var_samp?: InputMaybe<TeacherLanguagesVarSampOrderBy>;
  variance?: InputMaybe<TeacherLanguagesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "teacher_languages" */
export type TeacherLanguagesArrRelInsertInput = {
  data: Array<TeacherLanguagesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TeacherLanguagesOnConflict>;
};

/** aggregate avg on columns */
export type TeacherLanguagesAvgFields = {
  __typename?: 'teacher_languages_avg_fields';
  languageId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "teacher_languages" */
export type TeacherLanguagesAvgOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "teacher_languages". All fields are combined with a logical 'AND'. */
export type TeacherLanguagesBoolExp = {
  _and?: InputMaybe<Array<TeacherLanguagesBoolExp>>;
  _not?: InputMaybe<TeacherLanguagesBoolExp>;
  _or?: InputMaybe<Array<TeacherLanguagesBoolExp>>;
  cefr?: InputMaybe<CefrLevelsEnumComparisonExp>;
  language?: InputMaybe<LanguagesBoolExp>;
  languageId?: InputMaybe<IntComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "teacher_languages" */
export enum TeacherLanguagesConstraint {
  /** unique or primary key constraint on columns "teacher_id", "language_id" */
  TeacherLanguagesPkey = 'teacher_languages_pkey',
  /** unique or primary key constraint on columns "teacher_id", "language_id" */
  TeacherLanguagesTeacherIdLanguageIdKey = 'teacher_languages_teacher_id_language_id_key'
}

/** input type for incrementing numeric columns in table "teacher_languages" */
export type TeacherLanguagesIncInput = {
  languageId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "teacher_languages" */
export type TeacherLanguagesInsertInput = {
  cefr?: InputMaybe<CefrLevelsEnum>;
  language?: InputMaybe<LanguagesObjRelInsertInput>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type TeacherLanguagesMaxFields = {
  __typename?: 'teacher_languages_max_fields';
  languageId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "teacher_languages" */
export type TeacherLanguagesMaxOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TeacherLanguagesMinFields = {
  __typename?: 'teacher_languages_min_fields';
  languageId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "teacher_languages" */
export type TeacherLanguagesMinOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "teacher_languages" */
export type TeacherLanguagesMutationResponse = {
  __typename?: 'teacher_languages_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TeacherLanguages>;
};

/** on_conflict condition type for table "teacher_languages" */
export type TeacherLanguagesOnConflict = {
  constraint: TeacherLanguagesConstraint;
  update_columns?: Array<TeacherLanguagesUpdateColumn>;
  where?: InputMaybe<TeacherLanguagesBoolExp>;
};

/** Ordering options when selecting data from "teacher_languages". */
export type TeacherLanguagesOrderBy = {
  cefr?: InputMaybe<OrderBy>;
  language?: InputMaybe<LanguagesOrderBy>;
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: teacher_languages */
export type TeacherLanguagesPkColumnsInput = {
  languageId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};

/** select columns of table "teacher_languages" */
export enum TeacherLanguagesSelectColumn {
  /** column name */
  Cefr = 'cefr',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  TeacherId = 'teacherId'
}

/** input type for updating data in table "teacher_languages" */
export type TeacherLanguagesSetInput = {
  cefr?: InputMaybe<CefrLevelsEnum>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type TeacherLanguagesStddevFields = {
  __typename?: 'teacher_languages_stddev_fields';
  languageId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "teacher_languages" */
export type TeacherLanguagesStddevOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TeacherLanguagesStddevPopFields = {
  __typename?: 'teacher_languages_stddev_pop_fields';
  languageId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "teacher_languages" */
export type TeacherLanguagesStddevPopOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TeacherLanguagesStddevSampFields = {
  __typename?: 'teacher_languages_stddev_samp_fields';
  languageId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "teacher_languages" */
export type TeacherLanguagesStddevSampOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "teacher_languages" */
export type TeacherLanguagesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TeacherLanguagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeacherLanguagesStreamCursorValueInput = {
  cefr?: InputMaybe<CefrLevelsEnum>;
  languageId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type TeacherLanguagesSumFields = {
  __typename?: 'teacher_languages_sum_fields';
  languageId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "teacher_languages" */
export type TeacherLanguagesSumOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** update columns of table "teacher_languages" */
export enum TeacherLanguagesUpdateColumn {
  /** column name */
  Cefr = 'cefr',
  /** column name */
  LanguageId = 'languageId',
  /** column name */
  TeacherId = 'teacherId'
}

export type TeacherLanguagesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TeacherLanguagesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TeacherLanguagesSetInput>;
  /** filter the rows which have to be updated */
  where: TeacherLanguagesBoolExp;
};

/** aggregate var_pop on columns */
export type TeacherLanguagesVarPopFields = {
  __typename?: 'teacher_languages_var_pop_fields';
  languageId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "teacher_languages" */
export type TeacherLanguagesVarPopOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TeacherLanguagesVarSampFields = {
  __typename?: 'teacher_languages_var_samp_fields';
  languageId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "teacher_languages" */
export type TeacherLanguagesVarSampOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TeacherLanguagesVarianceFields = {
  __typename?: 'teacher_languages_variance_fields';
  languageId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "teacher_languages" */
export type TeacherLanguagesVarianceOrderBy = {
  languageId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "teacher_subjects" */
export type TeacherSubjects = {
  __typename?: 'teacher_subjects';
  preferredLevel?: Maybe<CefrLevelsEnum>;
  /** An object relationship */
  subject: Subjects;
  subjectId: Scalars['Int']['output'];
  teacherId: Scalars['Int']['output'];
  yearsOfExperience: Scalars['Int']['output'];
};

/** aggregated selection of "teacher_subjects" */
export type TeacherSubjectsAggregate = {
  __typename?: 'teacher_subjects_aggregate';
  aggregate?: Maybe<TeacherSubjectsAggregateFields>;
  nodes: Array<TeacherSubjects>;
};

export type TeacherSubjectsAggregateBoolExp = {
  count?: InputMaybe<TeacherSubjectsAggregateBoolExpCount>;
};

export type TeacherSubjectsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TeacherSubjectsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "teacher_subjects" */
export type TeacherSubjectsAggregateFields = {
  __typename?: 'teacher_subjects_aggregate_fields';
  avg?: Maybe<TeacherSubjectsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TeacherSubjectsMaxFields>;
  min?: Maybe<TeacherSubjectsMinFields>;
  stddev?: Maybe<TeacherSubjectsStddevFields>;
  stddev_pop?: Maybe<TeacherSubjectsStddevPopFields>;
  stddev_samp?: Maybe<TeacherSubjectsStddevSampFields>;
  sum?: Maybe<TeacherSubjectsSumFields>;
  var_pop?: Maybe<TeacherSubjectsVarPopFields>;
  var_samp?: Maybe<TeacherSubjectsVarSampFields>;
  variance?: Maybe<TeacherSubjectsVarianceFields>;
};


/** aggregate fields of "teacher_subjects" */
export type TeacherSubjectsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "teacher_subjects" */
export type TeacherSubjectsAggregateOrderBy = {
  avg?: InputMaybe<TeacherSubjectsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TeacherSubjectsMaxOrderBy>;
  min?: InputMaybe<TeacherSubjectsMinOrderBy>;
  stddev?: InputMaybe<TeacherSubjectsStddevOrderBy>;
  stddev_pop?: InputMaybe<TeacherSubjectsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<TeacherSubjectsStddevSampOrderBy>;
  sum?: InputMaybe<TeacherSubjectsSumOrderBy>;
  var_pop?: InputMaybe<TeacherSubjectsVarPopOrderBy>;
  var_samp?: InputMaybe<TeacherSubjectsVarSampOrderBy>;
  variance?: InputMaybe<TeacherSubjectsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "teacher_subjects" */
export type TeacherSubjectsArrRelInsertInput = {
  data: Array<TeacherSubjectsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TeacherSubjectsOnConflict>;
};

/** aggregate avg on columns */
export type TeacherSubjectsAvgFields = {
  __typename?: 'teacher_subjects_avg_fields';
  subjectId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  yearsOfExperience?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "teacher_subjects" */
export type TeacherSubjectsAvgOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "teacher_subjects". All fields are combined with a logical 'AND'. */
export type TeacherSubjectsBoolExp = {
  _and?: InputMaybe<Array<TeacherSubjectsBoolExp>>;
  _not?: InputMaybe<TeacherSubjectsBoolExp>;
  _or?: InputMaybe<Array<TeacherSubjectsBoolExp>>;
  preferredLevel?: InputMaybe<CefrLevelsEnumComparisonExp>;
  subject?: InputMaybe<SubjectsBoolExp>;
  subjectId?: InputMaybe<IntComparisonExp>;
  teacherId?: InputMaybe<IntComparisonExp>;
  yearsOfExperience?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "teacher_subjects" */
export enum TeacherSubjectsConstraint {
  /** unique or primary key constraint on columns "teacher_id", "subject_id" */
  TeacherSubjectsPkey = 'teacher_subjects_pkey',
  /** unique or primary key constraint on columns "teacher_id", "subject_id" */
  TeacherSubjectsTeacherIdSubjectIdKey = 'teacher_subjects_teacher_id_subject_id_key'
}

/** input type for incrementing numeric columns in table "teacher_subjects" */
export type TeacherSubjectsIncInput = {
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  yearsOfExperience?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "teacher_subjects" */
export type TeacherSubjectsInsertInput = {
  preferredLevel?: InputMaybe<CefrLevelsEnum>;
  subject?: InputMaybe<SubjectsObjRelInsertInput>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  yearsOfExperience?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type TeacherSubjectsMaxFields = {
  __typename?: 'teacher_subjects_max_fields';
  subjectId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  yearsOfExperience?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "teacher_subjects" */
export type TeacherSubjectsMaxOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TeacherSubjectsMinFields = {
  __typename?: 'teacher_subjects_min_fields';
  subjectId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  yearsOfExperience?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "teacher_subjects" */
export type TeacherSubjectsMinOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "teacher_subjects" */
export type TeacherSubjectsMutationResponse = {
  __typename?: 'teacher_subjects_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TeacherSubjects>;
};

/** on_conflict condition type for table "teacher_subjects" */
export type TeacherSubjectsOnConflict = {
  constraint: TeacherSubjectsConstraint;
  update_columns?: Array<TeacherSubjectsUpdateColumn>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};

/** Ordering options when selecting data from "teacher_subjects". */
export type TeacherSubjectsOrderBy = {
  preferredLevel?: InputMaybe<OrderBy>;
  subject?: InputMaybe<SubjectsOrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: teacher_subjects */
export type TeacherSubjectsPkColumnsInput = {
  subjectId: Scalars['Int']['input'];
  teacherId: Scalars['Int']['input'];
};

/** select columns of table "teacher_subjects" */
export enum TeacherSubjectsSelectColumn {
  /** column name */
  PreferredLevel = 'preferredLevel',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  YearsOfExperience = 'yearsOfExperience'
}

/** input type for updating data in table "teacher_subjects" */
export type TeacherSubjectsSetInput = {
  preferredLevel?: InputMaybe<CefrLevelsEnum>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  yearsOfExperience?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type TeacherSubjectsStddevFields = {
  __typename?: 'teacher_subjects_stddev_fields';
  subjectId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  yearsOfExperience?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "teacher_subjects" */
export type TeacherSubjectsStddevOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TeacherSubjectsStddevPopFields = {
  __typename?: 'teacher_subjects_stddev_pop_fields';
  subjectId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  yearsOfExperience?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "teacher_subjects" */
export type TeacherSubjectsStddevPopOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TeacherSubjectsStddevSampFields = {
  __typename?: 'teacher_subjects_stddev_samp_fields';
  subjectId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  yearsOfExperience?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "teacher_subjects" */
export type TeacherSubjectsStddevSampOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "teacher_subjects" */
export type TeacherSubjectsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TeacherSubjectsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeacherSubjectsStreamCursorValueInput = {
  preferredLevel?: InputMaybe<CefrLevelsEnum>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  teacherId?: InputMaybe<Scalars['Int']['input']>;
  yearsOfExperience?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type TeacherSubjectsSumFields = {
  __typename?: 'teacher_subjects_sum_fields';
  subjectId?: Maybe<Scalars['Int']['output']>;
  teacherId?: Maybe<Scalars['Int']['output']>;
  yearsOfExperience?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "teacher_subjects" */
export type TeacherSubjectsSumOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** update columns of table "teacher_subjects" */
export enum TeacherSubjectsUpdateColumn {
  /** column name */
  PreferredLevel = 'preferredLevel',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  TeacherId = 'teacherId',
  /** column name */
  YearsOfExperience = 'yearsOfExperience'
}

export type TeacherSubjectsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TeacherSubjectsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TeacherSubjectsSetInput>;
  /** filter the rows which have to be updated */
  where: TeacherSubjectsBoolExp;
};

/** aggregate var_pop on columns */
export type TeacherSubjectsVarPopFields = {
  __typename?: 'teacher_subjects_var_pop_fields';
  subjectId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  yearsOfExperience?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "teacher_subjects" */
export type TeacherSubjectsVarPopOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TeacherSubjectsVarSampFields = {
  __typename?: 'teacher_subjects_var_samp_fields';
  subjectId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  yearsOfExperience?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "teacher_subjects" */
export type TeacherSubjectsVarSampOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TeacherSubjectsVarianceFields = {
  __typename?: 'teacher_subjects_variance_fields';
  subjectId?: Maybe<Scalars['Float']['output']>;
  teacherId?: Maybe<Scalars['Float']['output']>;
  yearsOfExperience?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "teacher_subjects" */
export type TeacherSubjectsVarianceOrderBy = {
  subjectId?: InputMaybe<OrderBy>;
  teacherId?: InputMaybe<OrderBy>;
  yearsOfExperience?: InputMaybe<OrderBy>;
};

/** columns and relationships of "teachers" */
export type Teachers = {
  __typename?: 'teachers';
  /** An object relationship */
  applicationReview?: Maybe<ApplicationReviews>;
  applicationReviewId?: Maybe<Scalars['Int']['output']>;
  applicationSubmittedAt?: Maybe<Scalars['timestamptz']['output']>;
  bio?: Maybe<Scalars['String']['output']>;
  classPriceUsd?: Maybe<Scalars['Int']['output']>;
  created_at: Scalars['timestamptz']['output'];
  isApproved: Scalars['Boolean']['output'];
  isVerified: Scalars['Boolean']['output'];
  priceUsd?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  slots: Array<Slots>;
  /** An aggregate relationship */
  slots_aggregate: SlotsAggregate;
  streamReady?: Maybe<Scalars['Boolean']['output']>;
  stripeBusinessAccount?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  teacherCredentials: Array<TeacherCredentials>;
  /** An aggregate relationship */
  teacherCredentials_aggregate: TeacherCredentialsAggregate;
  /** An array relationship */
  teacherEducation: Array<TeacherEducation>;
  /** An aggregate relationship */
  teacherEducation_aggregate: TeacherEducationAggregate;
  /** An array relationship */
  teacherInterests: Array<TeacherInterests>;
  /** An aggregate relationship */
  teacherInterests_aggregate: TeacherInterestsAggregate;
  /** An array relationship */
  teacherLanguages: Array<TeacherLanguages>;
  /** An aggregate relationship */
  teacherLanguages_aggregate: TeacherLanguagesAggregate;
  /** An array relationship */
  teacherSubjects: Array<TeacherSubjects>;
  /** An aggregate relationship */
  teacherSubjects_aggregate: TeacherSubjectsAggregate;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['Int']['output'];
  videoUrl?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "teachers" */
export type TeachersSlotsArgs = {
  distinct_on?: InputMaybe<Array<SlotsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SlotsOrderBy>>;
  where?: InputMaybe<SlotsBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersSlotsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SlotsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SlotsOrderBy>>;
  where?: InputMaybe<SlotsBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherCredentialsArgs = {
  distinct_on?: InputMaybe<Array<TeacherCredentialsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherCredentialsOrderBy>>;
  where?: InputMaybe<TeacherCredentialsBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherCredentialsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherCredentialsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherCredentialsOrderBy>>;
  where?: InputMaybe<TeacherCredentialsBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherEducationArgs = {
  distinct_on?: InputMaybe<Array<TeacherEducationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherEducationOrderBy>>;
  where?: InputMaybe<TeacherEducationBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherEducationAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherEducationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherEducationOrderBy>>;
  where?: InputMaybe<TeacherEducationBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherInterestsArgs = {
  distinct_on?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherInterestsOrderBy>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherInterestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherInterestsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherInterestsOrderBy>>;
  where?: InputMaybe<TeacherInterestsBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherLanguagesArgs = {
  distinct_on?: InputMaybe<Array<TeacherLanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherLanguagesOrderBy>>;
  where?: InputMaybe<TeacherLanguagesBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherLanguagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherLanguagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherLanguagesOrderBy>>;
  where?: InputMaybe<TeacherLanguagesBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherSubjectsArgs = {
  distinct_on?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherSubjectsOrderBy>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};


/** columns and relationships of "teachers" */
export type TeachersTeacherSubjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TeacherSubjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TeacherSubjectsOrderBy>>;
  where?: InputMaybe<TeacherSubjectsBoolExp>;
};

/** aggregated selection of "teachers" */
export type TeachersAggregate = {
  __typename?: 'teachers_aggregate';
  aggregate?: Maybe<TeachersAggregateFields>;
  nodes: Array<Teachers>;
};

/** aggregate fields of "teachers" */
export type TeachersAggregateFields = {
  __typename?: 'teachers_aggregate_fields';
  avg?: Maybe<TeachersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TeachersMaxFields>;
  min?: Maybe<TeachersMinFields>;
  stddev?: Maybe<TeachersStddevFields>;
  stddev_pop?: Maybe<TeachersStddevPopFields>;
  stddev_samp?: Maybe<TeachersStddevSampFields>;
  sum?: Maybe<TeachersSumFields>;
  var_pop?: Maybe<TeachersVarPopFields>;
  var_samp?: Maybe<TeachersVarSampFields>;
  variance?: Maybe<TeachersVarianceFields>;
};


/** aggregate fields of "teachers" */
export type TeachersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TeachersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type TeachersAvgFields = {
  __typename?: 'teachers_avg_fields';
  applicationReviewId?: Maybe<Scalars['Float']['output']>;
  classPriceUsd?: Maybe<Scalars['Float']['output']>;
  priceUsd?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "teachers". All fields are combined with a logical 'AND'. */
export type TeachersBoolExp = {
  _and?: InputMaybe<Array<TeachersBoolExp>>;
  _not?: InputMaybe<TeachersBoolExp>;
  _or?: InputMaybe<Array<TeachersBoolExp>>;
  applicationReview?: InputMaybe<ApplicationReviewsBoolExp>;
  applicationReviewId?: InputMaybe<IntComparisonExp>;
  applicationSubmittedAt?: InputMaybe<TimestamptzComparisonExp>;
  bio?: InputMaybe<StringComparisonExp>;
  classPriceUsd?: InputMaybe<IntComparisonExp>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  isApproved?: InputMaybe<BooleanComparisonExp>;
  isVerified?: InputMaybe<BooleanComparisonExp>;
  priceUsd?: InputMaybe<IntComparisonExp>;
  slots?: InputMaybe<SlotsBoolExp>;
  slots_aggregate?: InputMaybe<SlotsAggregateBoolExp>;
  streamReady?: InputMaybe<BooleanComparisonExp>;
  stripeBusinessAccount?: InputMaybe<StringComparisonExp>;
  teacherCredentials?: InputMaybe<TeacherCredentialsBoolExp>;
  teacherCredentials_aggregate?: InputMaybe<TeacherCredentialsAggregateBoolExp>;
  teacherEducation?: InputMaybe<TeacherEducationBoolExp>;
  teacherEducation_aggregate?: InputMaybe<TeacherEducationAggregateBoolExp>;
  teacherInterests?: InputMaybe<TeacherInterestsBoolExp>;
  teacherInterests_aggregate?: InputMaybe<TeacherInterestsAggregateBoolExp>;
  teacherLanguages?: InputMaybe<TeacherLanguagesBoolExp>;
  teacherLanguages_aggregate?: InputMaybe<TeacherLanguagesAggregateBoolExp>;
  teacherSubjects?: InputMaybe<TeacherSubjectsBoolExp>;
  teacherSubjects_aggregate?: InputMaybe<TeacherSubjectsAggregateBoolExp>;
  updated_at?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<IntComparisonExp>;
  videoUrl?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "teachers" */
export enum TeachersConstraint {
  /** unique or primary key constraint on columns "user_id" */
  TeachersPkey = 'teachers_pkey'
}

/** input type for incrementing numeric columns in table "teachers" */
export type TeachersIncInput = {
  applicationReviewId?: InputMaybe<Scalars['Int']['input']>;
  classPriceUsd?: InputMaybe<Scalars['Int']['input']>;
  priceUsd?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "teachers" */
export type TeachersInsertInput = {
  applicationReview?: InputMaybe<ApplicationReviewsObjRelInsertInput>;
  applicationReviewId?: InputMaybe<Scalars['Int']['input']>;
  applicationSubmittedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  bio?: InputMaybe<Scalars['String']['input']>;
  classPriceUsd?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  priceUsd?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<SlotsArrRelInsertInput>;
  streamReady?: InputMaybe<Scalars['Boolean']['input']>;
  stripeBusinessAccount?: InputMaybe<Scalars['String']['input']>;
  teacherCredentials?: InputMaybe<TeacherCredentialsArrRelInsertInput>;
  teacherEducation?: InputMaybe<TeacherEducationArrRelInsertInput>;
  teacherInterests?: InputMaybe<TeacherInterestsArrRelInsertInput>;
  teacherLanguages?: InputMaybe<TeacherLanguagesArrRelInsertInput>;
  teacherSubjects?: InputMaybe<TeacherSubjectsArrRelInsertInput>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  videoUrl?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type TeachersMaxFields = {
  __typename?: 'teachers_max_fields';
  applicationReviewId?: Maybe<Scalars['Int']['output']>;
  applicationSubmittedAt?: Maybe<Scalars['timestamptz']['output']>;
  bio?: Maybe<Scalars['String']['output']>;
  classPriceUsd?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  priceUsd?: Maybe<Scalars['Int']['output']>;
  stripeBusinessAccount?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  videoUrl?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type TeachersMinFields = {
  __typename?: 'teachers_min_fields';
  applicationReviewId?: Maybe<Scalars['Int']['output']>;
  applicationSubmittedAt?: Maybe<Scalars['timestamptz']['output']>;
  bio?: Maybe<Scalars['String']['output']>;
  classPriceUsd?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  priceUsd?: Maybe<Scalars['Int']['output']>;
  stripeBusinessAccount?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  videoUrl?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "teachers" */
export type TeachersMutationResponse = {
  __typename?: 'teachers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Teachers>;
};

/** input type for inserting object relation for remote table "teachers" */
export type TeachersObjRelInsertInput = {
  data: TeachersInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TeachersOnConflict>;
};

/** on_conflict condition type for table "teachers" */
export type TeachersOnConflict = {
  constraint: TeachersConstraint;
  update_columns?: Array<TeachersUpdateColumn>;
  where?: InputMaybe<TeachersBoolExp>;
};

/** Ordering options when selecting data from "teachers". */
export type TeachersOrderBy = {
  applicationReview?: InputMaybe<ApplicationReviewsOrderBy>;
  applicationReviewId?: InputMaybe<OrderBy>;
  applicationSubmittedAt?: InputMaybe<OrderBy>;
  bio?: InputMaybe<OrderBy>;
  classPriceUsd?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  isApproved?: InputMaybe<OrderBy>;
  isVerified?: InputMaybe<OrderBy>;
  priceUsd?: InputMaybe<OrderBy>;
  slots_aggregate?: InputMaybe<SlotsAggregateOrderBy>;
  streamReady?: InputMaybe<OrderBy>;
  stripeBusinessAccount?: InputMaybe<OrderBy>;
  teacherCredentials_aggregate?: InputMaybe<TeacherCredentialsAggregateOrderBy>;
  teacherEducation_aggregate?: InputMaybe<TeacherEducationAggregateOrderBy>;
  teacherInterests_aggregate?: InputMaybe<TeacherInterestsAggregateOrderBy>;
  teacherLanguages_aggregate?: InputMaybe<TeacherLanguagesAggregateOrderBy>;
  teacherSubjects_aggregate?: InputMaybe<TeacherSubjectsAggregateOrderBy>;
  updated_at?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  videoUrl?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: teachers */
export type TeachersPkColumnsInput = {
  userId: Scalars['Int']['input'];
};

/** select columns of table "teachers" */
export enum TeachersSelectColumn {
  /** column name */
  ApplicationReviewId = 'applicationReviewId',
  /** column name */
  ApplicationSubmittedAt = 'applicationSubmittedAt',
  /** column name */
  Bio = 'bio',
  /** column name */
  ClassPriceUsd = 'classPriceUsd',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  IsApproved = 'isApproved',
  /** column name */
  IsVerified = 'isVerified',
  /** column name */
  PriceUsd = 'priceUsd',
  /** column name */
  StreamReady = 'streamReady',
  /** column name */
  StripeBusinessAccount = 'stripeBusinessAccount',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId',
  /** column name */
  VideoUrl = 'videoUrl'
}

/** input type for updating data in table "teachers" */
export type TeachersSetInput = {
  applicationReviewId?: InputMaybe<Scalars['Int']['input']>;
  applicationSubmittedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  bio?: InputMaybe<Scalars['String']['input']>;
  classPriceUsd?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  priceUsd?: InputMaybe<Scalars['Int']['input']>;
  streamReady?: InputMaybe<Scalars['Boolean']['input']>;
  stripeBusinessAccount?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  videoUrl?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type TeachersStddevFields = {
  __typename?: 'teachers_stddev_fields';
  applicationReviewId?: Maybe<Scalars['Float']['output']>;
  classPriceUsd?: Maybe<Scalars['Float']['output']>;
  priceUsd?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type TeachersStddevPopFields = {
  __typename?: 'teachers_stddev_pop_fields';
  applicationReviewId?: Maybe<Scalars['Float']['output']>;
  classPriceUsd?: Maybe<Scalars['Float']['output']>;
  priceUsd?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type TeachersStddevSampFields = {
  __typename?: 'teachers_stddev_samp_fields';
  applicationReviewId?: Maybe<Scalars['Float']['output']>;
  classPriceUsd?: Maybe<Scalars['Float']['output']>;
  priceUsd?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "teachers" */
export type TeachersStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TeachersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeachersStreamCursorValueInput = {
  applicationReviewId?: InputMaybe<Scalars['Int']['input']>;
  applicationSubmittedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  bio?: InputMaybe<Scalars['String']['input']>;
  classPriceUsd?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  priceUsd?: InputMaybe<Scalars['Int']['input']>;
  streamReady?: InputMaybe<Scalars['Boolean']['input']>;
  stripeBusinessAccount?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  videoUrl?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type TeachersSumFields = {
  __typename?: 'teachers_sum_fields';
  applicationReviewId?: Maybe<Scalars['Int']['output']>;
  classPriceUsd?: Maybe<Scalars['Int']['output']>;
  priceUsd?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "teachers" */
export enum TeachersUpdateColumn {
  /** column name */
  ApplicationReviewId = 'applicationReviewId',
  /** column name */
  ApplicationSubmittedAt = 'applicationSubmittedAt',
  /** column name */
  Bio = 'bio',
  /** column name */
  ClassPriceUsd = 'classPriceUsd',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  IsApproved = 'isApproved',
  /** column name */
  IsVerified = 'isVerified',
  /** column name */
  PriceUsd = 'priceUsd',
  /** column name */
  StreamReady = 'streamReady',
  /** column name */
  StripeBusinessAccount = 'stripeBusinessAccount',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId',
  /** column name */
  VideoUrl = 'videoUrl'
}

export type TeachersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TeachersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TeachersSetInput>;
  /** filter the rows which have to be updated */
  where: TeachersBoolExp;
};

/** aggregate var_pop on columns */
export type TeachersVarPopFields = {
  __typename?: 'teachers_var_pop_fields';
  applicationReviewId?: Maybe<Scalars['Float']['output']>;
  classPriceUsd?: Maybe<Scalars['Float']['output']>;
  priceUsd?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type TeachersVarSampFields = {
  __typename?: 'teachers_var_samp_fields';
  applicationReviewId?: Maybe<Scalars['Float']['output']>;
  classPriceUsd?: Maybe<Scalars['Float']['output']>;
  priceUsd?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type TeachersVarianceFields = {
  __typename?: 'teachers_variance_fields';
  applicationReviewId?: Maybe<Scalars['Float']['output']>;
  classPriceUsd?: Maybe<Scalars['Float']['output']>;
  priceUsd?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'. */
export type TimeComparisonExp = {
  _eq?: InputMaybe<Scalars['time']['input']>;
  _gt?: InputMaybe<Scalars['time']['input']>;
  _gte?: InputMaybe<Scalars['time']['input']>;
  _in?: InputMaybe<Array<Scalars['time']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['time']['input']>;
  _lte?: InputMaybe<Scalars['time']['input']>;
  _neq?: InputMaybe<Scalars['time']['input']>;
  _nin?: InputMaybe<Array<Scalars['time']['input']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type TimestamptzComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
};

/** Boolean expression to compare columns of type "timetz". All fields are combined with logical 'AND'. */
export type TimetzComparisonExp = {
  _eq?: InputMaybe<Scalars['timetz']['input']>;
  _gt?: InputMaybe<Scalars['timetz']['input']>;
  _gte?: InputMaybe<Scalars['timetz']['input']>;
  _in?: InputMaybe<Array<Scalars['timetz']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timetz']['input']>;
  _lte?: InputMaybe<Scalars['timetz']['input']>;
  _neq?: InputMaybe<Scalars['timetz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timetz']['input']>>;
};

/** columns and relationships of "user_courses" */
export type UserCourses = {
  __typename?: 'user_courses';
  courseId: Scalars['Int']['output'];
  lastActivitySetId?: Maybe<Scalars['Int']['output']>;
  paymentId?: Maybe<Scalars['Int']['output']>;
  userId: Scalars['Int']['output'];
};

/** aggregated selection of "user_courses" */
export type UserCoursesAggregate = {
  __typename?: 'user_courses_aggregate';
  aggregate?: Maybe<UserCoursesAggregateFields>;
  nodes: Array<UserCourses>;
};

export type UserCoursesAggregateBoolExp = {
  count?: InputMaybe<UserCoursesAggregateBoolExpCount>;
};

export type UserCoursesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserCoursesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserCoursesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "user_courses" */
export type UserCoursesAggregateFields = {
  __typename?: 'user_courses_aggregate_fields';
  avg?: Maybe<UserCoursesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UserCoursesMaxFields>;
  min?: Maybe<UserCoursesMinFields>;
  stddev?: Maybe<UserCoursesStddevFields>;
  stddev_pop?: Maybe<UserCoursesStddevPopFields>;
  stddev_samp?: Maybe<UserCoursesStddevSampFields>;
  sum?: Maybe<UserCoursesSumFields>;
  var_pop?: Maybe<UserCoursesVarPopFields>;
  var_samp?: Maybe<UserCoursesVarSampFields>;
  variance?: Maybe<UserCoursesVarianceFields>;
};


/** aggregate fields of "user_courses" */
export type UserCoursesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserCoursesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_courses" */
export type UserCoursesAggregateOrderBy = {
  avg?: InputMaybe<UserCoursesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserCoursesMaxOrderBy>;
  min?: InputMaybe<UserCoursesMinOrderBy>;
  stddev?: InputMaybe<UserCoursesStddevOrderBy>;
  stddev_pop?: InputMaybe<UserCoursesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<UserCoursesStddevSampOrderBy>;
  sum?: InputMaybe<UserCoursesSumOrderBy>;
  var_pop?: InputMaybe<UserCoursesVarPopOrderBy>;
  var_samp?: InputMaybe<UserCoursesVarSampOrderBy>;
  variance?: InputMaybe<UserCoursesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "user_courses" */
export type UserCoursesArrRelInsertInput = {
  data: Array<UserCoursesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<UserCoursesOnConflict>;
};

/** aggregate avg on columns */
export type UserCoursesAvgFields = {
  __typename?: 'user_courses_avg_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  lastActivitySetId?: Maybe<Scalars['Float']['output']>;
  paymentId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_courses" */
export type UserCoursesAvgOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "user_courses". All fields are combined with a logical 'AND'. */
export type UserCoursesBoolExp = {
  _and?: InputMaybe<Array<UserCoursesBoolExp>>;
  _not?: InputMaybe<UserCoursesBoolExp>;
  _or?: InputMaybe<Array<UserCoursesBoolExp>>;
  courseId?: InputMaybe<IntComparisonExp>;
  lastActivitySetId?: InputMaybe<IntComparisonExp>;
  paymentId?: InputMaybe<IntComparisonExp>;
  userId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "user_courses" */
export enum UserCoursesConstraint {
  /** unique or primary key constraint on columns "user_id", "course_id" */
  UserCoursesPkey = 'user_courses_pkey'
}

/** input type for incrementing numeric columns in table "user_courses" */
export type UserCoursesIncInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  lastActivitySetId?: InputMaybe<Scalars['Int']['input']>;
  paymentId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_courses" */
export type UserCoursesInsertInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  lastActivitySetId?: InputMaybe<Scalars['Int']['input']>;
  paymentId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type UserCoursesMaxFields = {
  __typename?: 'user_courses_max_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  lastActivitySetId?: Maybe<Scalars['Int']['output']>;
  paymentId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "user_courses" */
export type UserCoursesMaxOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserCoursesMinFields = {
  __typename?: 'user_courses_min_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  lastActivitySetId?: Maybe<Scalars['Int']['output']>;
  paymentId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "user_courses" */
export type UserCoursesMinOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_courses" */
export type UserCoursesMutationResponse = {
  __typename?: 'user_courses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserCourses>;
};

/** on_conflict condition type for table "user_courses" */
export type UserCoursesOnConflict = {
  constraint: UserCoursesConstraint;
  update_columns?: Array<UserCoursesUpdateColumn>;
  where?: InputMaybe<UserCoursesBoolExp>;
};

/** Ordering options when selecting data from "user_courses". */
export type UserCoursesOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_courses */
export type UserCoursesPkColumnsInput = {
  courseId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** select columns of table "user_courses" */
export enum UserCoursesSelectColumn {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  LastActivitySetId = 'lastActivitySetId',
  /** column name */
  PaymentId = 'paymentId',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_courses" */
export type UserCoursesSetInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  lastActivitySetId?: InputMaybe<Scalars['Int']['input']>;
  paymentId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type UserCoursesStddevFields = {
  __typename?: 'user_courses_stddev_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  lastActivitySetId?: Maybe<Scalars['Float']['output']>;
  paymentId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_courses" */
export type UserCoursesStddevOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type UserCoursesStddevPopFields = {
  __typename?: 'user_courses_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  lastActivitySetId?: Maybe<Scalars['Float']['output']>;
  paymentId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_courses" */
export type UserCoursesStddevPopOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type UserCoursesStddevSampFields = {
  __typename?: 'user_courses_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  lastActivitySetId?: Maybe<Scalars['Float']['output']>;
  paymentId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_courses" */
export type UserCoursesStddevSampOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "user_courses" */
export type UserCoursesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: UserCoursesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserCoursesStreamCursorValueInput = {
  courseId?: InputMaybe<Scalars['Int']['input']>;
  lastActivitySetId?: InputMaybe<Scalars['Int']['input']>;
  paymentId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type UserCoursesSumFields = {
  __typename?: 'user_courses_sum_fields';
  courseId?: Maybe<Scalars['Int']['output']>;
  lastActivitySetId?: Maybe<Scalars['Int']['output']>;
  paymentId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "user_courses" */
export type UserCoursesSumOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** update columns of table "user_courses" */
export enum UserCoursesUpdateColumn {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  LastActivitySetId = 'lastActivitySetId',
  /** column name */
  PaymentId = 'paymentId',
  /** column name */
  UserId = 'userId'
}

export type UserCoursesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserCoursesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserCoursesSetInput>;
  /** filter the rows which have to be updated */
  where: UserCoursesBoolExp;
};

/** aggregate var_pop on columns */
export type UserCoursesVarPopFields = {
  __typename?: 'user_courses_var_pop_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  lastActivitySetId?: Maybe<Scalars['Float']['output']>;
  paymentId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_courses" */
export type UserCoursesVarPopOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type UserCoursesVarSampFields = {
  __typename?: 'user_courses_var_samp_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  lastActivitySetId?: Maybe<Scalars['Float']['output']>;
  paymentId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_courses" */
export type UserCoursesVarSampOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type UserCoursesVarianceFields = {
  __typename?: 'user_courses_variance_fields';
  courseId?: Maybe<Scalars['Float']['output']>;
  lastActivitySetId?: Maybe<Scalars['Float']['output']>;
  paymentId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_courses" */
export type UserCoursesVarianceOrderBy = {
  courseId?: InputMaybe<OrderBy>;
  lastActivitySetId?: InputMaybe<OrderBy>;
  paymentId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "user_devices" */
export type UserDevices = {
  __typename?: 'user_devices';
  device_name: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  is_logged_out: Scalars['Boolean']['output'];
  user_id: Scalars['Int']['output'];
};

/** aggregated selection of "user_devices" */
export type UserDevicesAggregate = {
  __typename?: 'user_devices_aggregate';
  aggregate?: Maybe<UserDevicesAggregateFields>;
  nodes: Array<UserDevices>;
};

/** aggregate fields of "user_devices" */
export type UserDevicesAggregateFields = {
  __typename?: 'user_devices_aggregate_fields';
  avg?: Maybe<UserDevicesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UserDevicesMaxFields>;
  min?: Maybe<UserDevicesMinFields>;
  stddev?: Maybe<UserDevicesStddevFields>;
  stddev_pop?: Maybe<UserDevicesStddevPopFields>;
  stddev_samp?: Maybe<UserDevicesStddevSampFields>;
  sum?: Maybe<UserDevicesSumFields>;
  var_pop?: Maybe<UserDevicesVarPopFields>;
  var_samp?: Maybe<UserDevicesVarSampFields>;
  variance?: Maybe<UserDevicesVarianceFields>;
};


/** aggregate fields of "user_devices" */
export type UserDevicesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserDevicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type UserDevicesAvgFields = {
  __typename?: 'user_devices_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "user_devices". All fields are combined with a logical 'AND'. */
export type UserDevicesBoolExp = {
  _and?: InputMaybe<Array<UserDevicesBoolExp>>;
  _not?: InputMaybe<UserDevicesBoolExp>;
  _or?: InputMaybe<Array<UserDevicesBoolExp>>;
  device_name?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  is_logged_out?: InputMaybe<BooleanComparisonExp>;
  user_id?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "user_devices" */
export enum UserDevicesConstraint {
  /** unique or primary key constraint on columns "id" */
  UserDevicesPkey = 'user_devices_pkey',
  /** unique or primary key constraint on columns "user_id", "device_name" */
  UserDevicesUserIdDeviceNameKey = 'user_devices_user_id_device_name_key'
}

/** input type for incrementing numeric columns in table "user_devices" */
export type UserDevicesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_devices" */
export type UserDevicesInsertInput = {
  device_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  is_logged_out?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type UserDevicesMaxFields = {
  __typename?: 'user_devices_max_fields';
  device_name?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type UserDevicesMinFields = {
  __typename?: 'user_devices_min_fields';
  device_name?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "user_devices" */
export type UserDevicesMutationResponse = {
  __typename?: 'user_devices_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserDevices>;
};

/** on_conflict condition type for table "user_devices" */
export type UserDevicesOnConflict = {
  constraint: UserDevicesConstraint;
  update_columns?: Array<UserDevicesUpdateColumn>;
  where?: InputMaybe<UserDevicesBoolExp>;
};

/** Ordering options when selecting data from "user_devices". */
export type UserDevicesOrderBy = {
  device_name?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  is_logged_out?: InputMaybe<OrderBy>;
  user_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_devices */
export type UserDevicesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "user_devices" */
export enum UserDevicesSelectColumn {
  /** column name */
  DeviceName = 'device_name',
  /** column name */
  Id = 'id',
  /** column name */
  IsLoggedOut = 'is_logged_out',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_devices" */
export type UserDevicesSetInput = {
  device_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  is_logged_out?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type UserDevicesStddevFields = {
  __typename?: 'user_devices_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type UserDevicesStddevPopFields = {
  __typename?: 'user_devices_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type UserDevicesStddevSampFields = {
  __typename?: 'user_devices_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "user_devices" */
export type UserDevicesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: UserDevicesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserDevicesStreamCursorValueInput = {
  device_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  is_logged_out?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type UserDevicesSumFields = {
  __typename?: 'user_devices_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "user_devices" */
export enum UserDevicesUpdateColumn {
  /** column name */
  DeviceName = 'device_name',
  /** column name */
  Id = 'id',
  /** column name */
  IsLoggedOut = 'is_logged_out',
  /** column name */
  UserId = 'user_id'
}

export type UserDevicesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserDevicesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserDevicesSetInput>;
  /** filter the rows which have to be updated */
  where: UserDevicesBoolExp;
};

/** aggregate var_pop on columns */
export type UserDevicesVarPopFields = {
  __typename?: 'user_devices_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type UserDevicesVarSampFields = {
  __typename?: 'user_devices_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type UserDevicesVarianceFields = {
  __typename?: 'user_devices_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "user_dictionaries" */
export type UserDictionaries = {
  __typename?: 'user_dictionaries';
  dictionaryId: Scalars['Int']['output'];
  userId: Scalars['Int']['output'];
};

/** aggregated selection of "user_dictionaries" */
export type UserDictionariesAggregate = {
  __typename?: 'user_dictionaries_aggregate';
  aggregate?: Maybe<UserDictionariesAggregateFields>;
  nodes: Array<UserDictionaries>;
};

export type UserDictionariesAggregateBoolExp = {
  count?: InputMaybe<UserDictionariesAggregateBoolExpCount>;
};

export type UserDictionariesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserDictionariesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserDictionariesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "user_dictionaries" */
export type UserDictionariesAggregateFields = {
  __typename?: 'user_dictionaries_aggregate_fields';
  avg?: Maybe<UserDictionariesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UserDictionariesMaxFields>;
  min?: Maybe<UserDictionariesMinFields>;
  stddev?: Maybe<UserDictionariesStddevFields>;
  stddev_pop?: Maybe<UserDictionariesStddevPopFields>;
  stddev_samp?: Maybe<UserDictionariesStddevSampFields>;
  sum?: Maybe<UserDictionariesSumFields>;
  var_pop?: Maybe<UserDictionariesVarPopFields>;
  var_samp?: Maybe<UserDictionariesVarSampFields>;
  variance?: Maybe<UserDictionariesVarianceFields>;
};


/** aggregate fields of "user_dictionaries" */
export type UserDictionariesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserDictionariesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_dictionaries" */
export type UserDictionariesAggregateOrderBy = {
  avg?: InputMaybe<UserDictionariesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserDictionariesMaxOrderBy>;
  min?: InputMaybe<UserDictionariesMinOrderBy>;
  stddev?: InputMaybe<UserDictionariesStddevOrderBy>;
  stddev_pop?: InputMaybe<UserDictionariesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<UserDictionariesStddevSampOrderBy>;
  sum?: InputMaybe<UserDictionariesSumOrderBy>;
  var_pop?: InputMaybe<UserDictionariesVarPopOrderBy>;
  var_samp?: InputMaybe<UserDictionariesVarSampOrderBy>;
  variance?: InputMaybe<UserDictionariesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "user_dictionaries" */
export type UserDictionariesArrRelInsertInput = {
  data: Array<UserDictionariesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<UserDictionariesOnConflict>;
};

/** aggregate avg on columns */
export type UserDictionariesAvgFields = {
  __typename?: 'user_dictionaries_avg_fields';
  dictionaryId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_dictionaries" */
export type UserDictionariesAvgOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "user_dictionaries". All fields are combined with a logical 'AND'. */
export type UserDictionariesBoolExp = {
  _and?: InputMaybe<Array<UserDictionariesBoolExp>>;
  _not?: InputMaybe<UserDictionariesBoolExp>;
  _or?: InputMaybe<Array<UserDictionariesBoolExp>>;
  dictionaryId?: InputMaybe<IntComparisonExp>;
  userId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "user_dictionaries" */
export enum UserDictionariesConstraint {
  /** unique or primary key constraint on columns "user_id", "dictionary_id" */
  UserDictionariesPkey = 'user_dictionaries_pkey'
}

/** input type for incrementing numeric columns in table "user_dictionaries" */
export type UserDictionariesIncInput = {
  dictionaryId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_dictionaries" */
export type UserDictionariesInsertInput = {
  dictionaryId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type UserDictionariesMaxFields = {
  __typename?: 'user_dictionaries_max_fields';
  dictionaryId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "user_dictionaries" */
export type UserDictionariesMaxOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserDictionariesMinFields = {
  __typename?: 'user_dictionaries_min_fields';
  dictionaryId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "user_dictionaries" */
export type UserDictionariesMinOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_dictionaries" */
export type UserDictionariesMutationResponse = {
  __typename?: 'user_dictionaries_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserDictionaries>;
};

/** on_conflict condition type for table "user_dictionaries" */
export type UserDictionariesOnConflict = {
  constraint: UserDictionariesConstraint;
  update_columns?: Array<UserDictionariesUpdateColumn>;
  where?: InputMaybe<UserDictionariesBoolExp>;
};

/** Ordering options when selecting data from "user_dictionaries". */
export type UserDictionariesOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_dictionaries */
export type UserDictionariesPkColumnsInput = {
  dictionaryId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** select columns of table "user_dictionaries" */
export enum UserDictionariesSelectColumn {
  /** column name */
  DictionaryId = 'dictionaryId',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "user_dictionaries" */
export type UserDictionariesSetInput = {
  dictionaryId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type UserDictionariesStddevFields = {
  __typename?: 'user_dictionaries_stddev_fields';
  dictionaryId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_dictionaries" */
export type UserDictionariesStddevOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type UserDictionariesStddevPopFields = {
  __typename?: 'user_dictionaries_stddev_pop_fields';
  dictionaryId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_dictionaries" */
export type UserDictionariesStddevPopOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type UserDictionariesStddevSampFields = {
  __typename?: 'user_dictionaries_stddev_samp_fields';
  dictionaryId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_dictionaries" */
export type UserDictionariesStddevSampOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "user_dictionaries" */
export type UserDictionariesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: UserDictionariesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserDictionariesStreamCursorValueInput = {
  dictionaryId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type UserDictionariesSumFields = {
  __typename?: 'user_dictionaries_sum_fields';
  dictionaryId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "user_dictionaries" */
export type UserDictionariesSumOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** update columns of table "user_dictionaries" */
export enum UserDictionariesUpdateColumn {
  /** column name */
  DictionaryId = 'dictionaryId',
  /** column name */
  UserId = 'userId'
}

export type UserDictionariesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserDictionariesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserDictionariesSetInput>;
  /** filter the rows which have to be updated */
  where: UserDictionariesBoolExp;
};

/** aggregate var_pop on columns */
export type UserDictionariesVarPopFields = {
  __typename?: 'user_dictionaries_var_pop_fields';
  dictionaryId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_dictionaries" */
export type UserDictionariesVarPopOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type UserDictionariesVarSampFields = {
  __typename?: 'user_dictionaries_var_samp_fields';
  dictionaryId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_dictionaries" */
export type UserDictionariesVarSampOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type UserDictionariesVarianceFields = {
  __typename?: 'user_dictionaries_variance_fields';
  dictionaryId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_dictionaries" */
export type UserDictionariesVarianceOrderBy = {
  dictionaryId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "user_messages" */
export type UserMessages = {
  __typename?: 'user_messages';
  createdAt: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  lastMessage?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  messages: Array<Messages>;
  /** An aggregate relationship */
  messages_aggregate: MessagesAggregate;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userOne: Scalars['Int']['output'];
  /** An object relationship */
  userOneFields: Users;
  userTwo: Scalars['Int']['output'];
  /** An object relationship */
  userTwoFields: Users;
};


/** columns and relationships of "user_messages" */
export type UserMessagesMessagesArgs = {
  distinct_on?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** columns and relationships of "user_messages" */
export type UserMessagesMessagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};

/** aggregated selection of "user_messages" */
export type UserMessagesAggregate = {
  __typename?: 'user_messages_aggregate';
  aggregate?: Maybe<UserMessagesAggregateFields>;
  nodes: Array<UserMessages>;
};

/** aggregate fields of "user_messages" */
export type UserMessagesAggregateFields = {
  __typename?: 'user_messages_aggregate_fields';
  avg?: Maybe<UserMessagesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UserMessagesMaxFields>;
  min?: Maybe<UserMessagesMinFields>;
  stddev?: Maybe<UserMessagesStddevFields>;
  stddev_pop?: Maybe<UserMessagesStddevPopFields>;
  stddev_samp?: Maybe<UserMessagesStddevSampFields>;
  sum?: Maybe<UserMessagesSumFields>;
  var_pop?: Maybe<UserMessagesVarPopFields>;
  var_samp?: Maybe<UserMessagesVarSampFields>;
  variance?: Maybe<UserMessagesVarianceFields>;
};


/** aggregate fields of "user_messages" */
export type UserMessagesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserMessagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type UserMessagesAvgFields = {
  __typename?: 'user_messages_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userOne?: Maybe<Scalars['Float']['output']>;
  userTwo?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "user_messages". All fields are combined with a logical 'AND'. */
export type UserMessagesBoolExp = {
  _and?: InputMaybe<Array<UserMessagesBoolExp>>;
  _not?: InputMaybe<UserMessagesBoolExp>;
  _or?: InputMaybe<Array<UserMessagesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  lastMessage?: InputMaybe<StringComparisonExp>;
  messages?: InputMaybe<MessagesBoolExp>;
  messages_aggregate?: InputMaybe<MessagesAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userOne?: InputMaybe<IntComparisonExp>;
  userOneFields?: InputMaybe<UsersBoolExp>;
  userTwo?: InputMaybe<IntComparisonExp>;
  userTwoFields?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "user_messages" */
export enum UserMessagesConstraint {
  /** unique or primary key constraint on columns "id" */
  UserMessagesPkey = 'user_messages_pkey',
  /** unique or primary key constraint on columns "user_two", "user_one" */
  UserMessagesUserOneUserTwoKey = 'user_messages_user_one_user_two_key'
}

/** input type for incrementing numeric columns in table "user_messages" */
export type UserMessagesIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  userOne?: InputMaybe<Scalars['Int']['input']>;
  userTwo?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_messages" */
export type UserMessagesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastMessage?: InputMaybe<Scalars['String']['input']>;
  messages?: InputMaybe<MessagesArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userOne?: InputMaybe<Scalars['Int']['input']>;
  userOneFields?: InputMaybe<UsersObjRelInsertInput>;
  userTwo?: InputMaybe<Scalars['Int']['input']>;
  userTwoFields?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type UserMessagesMaxFields = {
  __typename?: 'user_messages_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  lastMessage?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userOne?: Maybe<Scalars['Int']['output']>;
  userTwo?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type UserMessagesMinFields = {
  __typename?: 'user_messages_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  lastMessage?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userOne?: Maybe<Scalars['Int']['output']>;
  userTwo?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "user_messages" */
export type UserMessagesMutationResponse = {
  __typename?: 'user_messages_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserMessages>;
};

/** input type for inserting object relation for remote table "user_messages" */
export type UserMessagesObjRelInsertInput = {
  data: UserMessagesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<UserMessagesOnConflict>;
};

/** on_conflict condition type for table "user_messages" */
export type UserMessagesOnConflict = {
  constraint: UserMessagesConstraint;
  update_columns?: Array<UserMessagesUpdateColumn>;
  where?: InputMaybe<UserMessagesBoolExp>;
};

/** Ordering options when selecting data from "user_messages". */
export type UserMessagesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastMessage?: InputMaybe<OrderBy>;
  messages_aggregate?: InputMaybe<MessagesAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userOne?: InputMaybe<OrderBy>;
  userOneFields?: InputMaybe<UsersOrderBy>;
  userTwo?: InputMaybe<OrderBy>;
  userTwoFields?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: user_messages */
export type UserMessagesPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "user_messages" */
export enum UserMessagesSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastMessage = 'lastMessage',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserOne = 'userOne',
  /** column name */
  UserTwo = 'userTwo'
}

/** input type for updating data in table "user_messages" */
export type UserMessagesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastMessage?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userOne?: InputMaybe<Scalars['Int']['input']>;
  userTwo?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type UserMessagesStddevFields = {
  __typename?: 'user_messages_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userOne?: Maybe<Scalars['Float']['output']>;
  userTwo?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type UserMessagesStddevPopFields = {
  __typename?: 'user_messages_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userOne?: Maybe<Scalars['Float']['output']>;
  userTwo?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type UserMessagesStddevSampFields = {
  __typename?: 'user_messages_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userOne?: Maybe<Scalars['Float']['output']>;
  userTwo?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "user_messages" */
export type UserMessagesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: UserMessagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserMessagesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastMessage?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userOne?: InputMaybe<Scalars['Int']['input']>;
  userTwo?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type UserMessagesSumFields = {
  __typename?: 'user_messages_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  userOne?: Maybe<Scalars['Int']['output']>;
  userTwo?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "user_messages" */
export enum UserMessagesUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastMessage = 'lastMessage',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserOne = 'userOne',
  /** column name */
  UserTwo = 'userTwo'
}

export type UserMessagesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserMessagesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserMessagesSetInput>;
  /** filter the rows which have to be updated */
  where: UserMessagesBoolExp;
};

/** aggregate var_pop on columns */
export type UserMessagesVarPopFields = {
  __typename?: 'user_messages_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userOne?: Maybe<Scalars['Float']['output']>;
  userTwo?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type UserMessagesVarSampFields = {
  __typename?: 'user_messages_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userOne?: Maybe<Scalars['Float']['output']>;
  userTwo?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type UserMessagesVarianceFields = {
  __typename?: 'user_messages_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  userOne?: Maybe<Scalars['Float']['output']>;
  userTwo?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "user_words" */
export type UserWords = {
  __typename?: 'user_words';
  created_at: Scalars['timestamptz']['output'];
  efactor: Scalars['float8']['output'];
  id: Scalars['Int']['output'];
  interval: Scalars['Int']['output'];
  lastReviewAt: Scalars['timestamptz']['output'];
  nextReviewAt: Scalars['timestamptz']['output'];
  repetition: Scalars['Int']['output'];
  subjectId?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: Users;
  userId: Scalars['Int']['output'];
  /** An object relationship */
  vocabularyWord: VocabularyWords;
  vocabularyWordId: Scalars['Int']['output'];
};

/** aggregated selection of "user_words" */
export type UserWordsAggregate = {
  __typename?: 'user_words_aggregate';
  aggregate?: Maybe<UserWordsAggregateFields>;
  nodes: Array<UserWords>;
};

export type UserWordsAggregateBoolExp = {
  avg?: InputMaybe<UserWordsAggregateBoolExpAvg>;
  corr?: InputMaybe<UserWordsAggregateBoolExpCorr>;
  count?: InputMaybe<UserWordsAggregateBoolExpCount>;
  covar_samp?: InputMaybe<UserWordsAggregateBoolExpCovarSamp>;
  max?: InputMaybe<UserWordsAggregateBoolExpMax>;
  min?: InputMaybe<UserWordsAggregateBoolExpMin>;
  stddev_samp?: InputMaybe<UserWordsAggregateBoolExpStddevSamp>;
  sum?: InputMaybe<UserWordsAggregateBoolExpSum>;
  var_samp?: InputMaybe<UserWordsAggregateBoolExpVarSamp>;
};

export type UserWordsAggregateBoolExpAvg = {
  arguments: UserWordsSelectColumnUserWordsAggregateBoolExpAvgArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: Float8ComparisonExp;
};

export type UserWordsAggregateBoolExpCorr = {
  arguments: UserWordsAggregateBoolExpCorrArguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: Float8ComparisonExp;
};

export type UserWordsAggregateBoolExpCorrArguments = {
  X: UserWordsSelectColumnUserWordsAggregateBoolExpCorrArgumentsColumns;
  Y: UserWordsSelectColumnUserWordsAggregateBoolExpCorrArgumentsColumns;
};

export type UserWordsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserWordsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: IntComparisonExp;
};

export type UserWordsAggregateBoolExpCovarSamp = {
  arguments: UserWordsAggregateBoolExpCovarSampArguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: Float8ComparisonExp;
};

export type UserWordsAggregateBoolExpCovarSampArguments = {
  X: UserWordsSelectColumnUserWordsAggregateBoolExpCovarSampArgumentsColumns;
  Y: UserWordsSelectColumnUserWordsAggregateBoolExpCovarSampArgumentsColumns;
};

export type UserWordsAggregateBoolExpMax = {
  arguments: UserWordsSelectColumnUserWordsAggregateBoolExpMaxArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: Float8ComparisonExp;
};

export type UserWordsAggregateBoolExpMin = {
  arguments: UserWordsSelectColumnUserWordsAggregateBoolExpMinArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: Float8ComparisonExp;
};

export type UserWordsAggregateBoolExpStddevSamp = {
  arguments: UserWordsSelectColumnUserWordsAggregateBoolExpStddevSampArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: Float8ComparisonExp;
};

export type UserWordsAggregateBoolExpSum = {
  arguments: UserWordsSelectColumnUserWordsAggregateBoolExpSumArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: Float8ComparisonExp;
};

export type UserWordsAggregateBoolExpVarSamp = {
  arguments: UserWordsSelectColumnUserWordsAggregateBoolExpVarSampArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserWordsBoolExp>;
  predicate: Float8ComparisonExp;
};

/** aggregate fields of "user_words" */
export type UserWordsAggregateFields = {
  __typename?: 'user_words_aggregate_fields';
  avg?: Maybe<UserWordsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UserWordsMaxFields>;
  min?: Maybe<UserWordsMinFields>;
  stddev?: Maybe<UserWordsStddevFields>;
  stddev_pop?: Maybe<UserWordsStddevPopFields>;
  stddev_samp?: Maybe<UserWordsStddevSampFields>;
  sum?: Maybe<UserWordsSumFields>;
  var_pop?: Maybe<UserWordsVarPopFields>;
  var_samp?: Maybe<UserWordsVarSampFields>;
  variance?: Maybe<UserWordsVarianceFields>;
};


/** aggregate fields of "user_words" */
export type UserWordsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserWordsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_words" */
export type UserWordsAggregateOrderBy = {
  avg?: InputMaybe<UserWordsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserWordsMaxOrderBy>;
  min?: InputMaybe<UserWordsMinOrderBy>;
  stddev?: InputMaybe<UserWordsStddevOrderBy>;
  stddev_pop?: InputMaybe<UserWordsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<UserWordsStddevSampOrderBy>;
  sum?: InputMaybe<UserWordsSumOrderBy>;
  var_pop?: InputMaybe<UserWordsVarPopOrderBy>;
  var_samp?: InputMaybe<UserWordsVarSampOrderBy>;
  variance?: InputMaybe<UserWordsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "user_words" */
export type UserWordsArrRelInsertInput = {
  data: Array<UserWordsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<UserWordsOnConflict>;
};

/** aggregate avg on columns */
export type UserWordsAvgFields = {
  __typename?: 'user_words_avg_fields';
  efactor?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  interval?: Maybe<Scalars['Float']['output']>;
  repetition?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  vocabularyWordId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_words" */
export type UserWordsAvgOrderBy = {
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "user_words". All fields are combined with a logical 'AND'. */
export type UserWordsBoolExp = {
  _and?: InputMaybe<Array<UserWordsBoolExp>>;
  _not?: InputMaybe<UserWordsBoolExp>;
  _or?: InputMaybe<Array<UserWordsBoolExp>>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  efactor?: InputMaybe<Float8ComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  interval?: InputMaybe<IntComparisonExp>;
  lastReviewAt?: InputMaybe<TimestamptzComparisonExp>;
  nextReviewAt?: InputMaybe<TimestamptzComparisonExp>;
  repetition?: InputMaybe<IntComparisonExp>;
  subjectId?: InputMaybe<IntComparisonExp>;
  updated_at?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<IntComparisonExp>;
  vocabularyWord?: InputMaybe<VocabularyWordsBoolExp>;
  vocabularyWordId?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "user_words" */
export enum UserWordsConstraint {
  /** unique or primary key constraint on columns "id" */
  UserWordsPkey = 'user_words_pkey',
  /** unique or primary key constraint on columns "user_id", "vocabulary_word_id" */
  UserWordsVocabularyWordIdUserIdKey = 'user_words_vocabulary_word_id_user_id_key'
}

/** columns and relationships of "user_words_count" */
export type UserWordsCount = {
  __typename?: 'user_words_count';
  count: Scalars['Int']['output'];
  date: Scalars['date']['output'];
};

export type UserWordsCountAggregate = {
  __typename?: 'user_words_count_aggregate';
  aggregate?: Maybe<UserWordsCountAggregateFields>;
  nodes: Array<UserWordsCount>;
};

/** aggregate fields of "user_words_count" */
export type UserWordsCountAggregateFields = {
  __typename?: 'user_words_count_aggregate_fields';
  avg?: Maybe<UserWordsCountAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UserWordsCountMaxFields>;
  min?: Maybe<UserWordsCountMinFields>;
  stddev?: Maybe<UserWordsCountStddevFields>;
  stddev_pop?: Maybe<UserWordsCountStddevPopFields>;
  stddev_samp?: Maybe<UserWordsCountStddevSampFields>;
  sum?: Maybe<UserWordsCountSumFields>;
  var_pop?: Maybe<UserWordsCountVarPopFields>;
  var_samp?: Maybe<UserWordsCountVarSampFields>;
  variance?: Maybe<UserWordsCountVarianceFields>;
};


/** aggregate fields of "user_words_count" */
export type UserWordsCountAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserWordsCountSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type UserWordsCountAvgFields = {
  __typename?: 'user_words_count_avg_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "user_words_count". All fields are combined with a logical 'AND'. */
export type UserWordsCountBoolExp = {
  _and?: InputMaybe<Array<UserWordsCountBoolExp>>;
  _not?: InputMaybe<UserWordsCountBoolExp>;
  _or?: InputMaybe<Array<UserWordsCountBoolExp>>;
  count?: InputMaybe<IntComparisonExp>;
  date?: InputMaybe<DateComparisonExp>;
};

/** unique or primary key constraints on table "user_words_count" */
export enum UserWordsCountConstraint {
  /** unique or primary key constraint on columns "date" */
  UserWordsCountPkey = 'user_words_count_pkey'
}

/** input type for incrementing numeric columns in table "user_words_count" */
export type UserWordsCountIncInput = {
  count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_words_count" */
export type UserWordsCountInsertInput = {
  count?: InputMaybe<Scalars['Int']['input']>;
  date?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate max on columns */
export type UserWordsCountMaxFields = {
  __typename?: 'user_words_count_max_fields';
  count?: Maybe<Scalars['Int']['output']>;
  date?: Maybe<Scalars['date']['output']>;
};

/** aggregate min on columns */
export type UserWordsCountMinFields = {
  __typename?: 'user_words_count_min_fields';
  count?: Maybe<Scalars['Int']['output']>;
  date?: Maybe<Scalars['date']['output']>;
};

/** response of any mutation on the table "user_words_count" */
export type UserWordsCountMutationResponse = {
  __typename?: 'user_words_count_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserWordsCount>;
};

/** on_conflict condition type for table "user_words_count" */
export type UserWordsCountOnConflict = {
  constraint: UserWordsCountConstraint;
  update_columns?: Array<UserWordsCountUpdateColumn>;
  where?: InputMaybe<UserWordsCountBoolExp>;
};

/** Ordering options when selecting data from "user_words_count". */
export type UserWordsCountOrderBy = {
  count?: InputMaybe<OrderBy>;
  date?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_words_count */
export type UserWordsCountPkColumnsInput = {
  date: Scalars['date']['input'];
};

/** select columns of table "user_words_count" */
export enum UserWordsCountSelectColumn {
  /** column name */
  Count = 'count',
  /** column name */
  Date = 'date'
}

/** input type for updating data in table "user_words_count" */
export type UserWordsCountSetInput = {
  count?: InputMaybe<Scalars['Int']['input']>;
  date?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate stddev on columns */
export type UserWordsCountStddevFields = {
  __typename?: 'user_words_count_stddev_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type UserWordsCountStddevPopFields = {
  __typename?: 'user_words_count_stddev_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type UserWordsCountStddevSampFields = {
  __typename?: 'user_words_count_stddev_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "user_words_count" */
export type UserWordsCountStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: UserWordsCountStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserWordsCountStreamCursorValueInput = {
  count?: InputMaybe<Scalars['Int']['input']>;
  date?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate sum on columns */
export type UserWordsCountSumFields = {
  __typename?: 'user_words_count_sum_fields';
  count?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "user_words_count" */
export enum UserWordsCountUpdateColumn {
  /** column name */
  Count = 'count',
  /** column name */
  Date = 'date'
}

export type UserWordsCountUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserWordsCountIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserWordsCountSetInput>;
  /** filter the rows which have to be updated */
  where: UserWordsCountBoolExp;
};

/** aggregate var_pop on columns */
export type UserWordsCountVarPopFields = {
  __typename?: 'user_words_count_var_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type UserWordsCountVarSampFields = {
  __typename?: 'user_words_count_var_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type UserWordsCountVarianceFields = {
  __typename?: 'user_words_count_variance_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** input type for incrementing numeric columns in table "user_words" */
export type UserWordsIncInput = {
  efactor?: InputMaybe<Scalars['float8']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  interval?: InputMaybe<Scalars['Int']['input']>;
  repetition?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  vocabularyWordId?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_words" */
export type UserWordsInsertInput = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  efactor?: InputMaybe<Scalars['float8']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  interval?: InputMaybe<Scalars['Int']['input']>;
  lastReviewAt?: InputMaybe<Scalars['timestamptz']['input']>;
  nextReviewAt?: InputMaybe<Scalars['timestamptz']['input']>;
  repetition?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  vocabularyWord?: InputMaybe<VocabularyWordsObjRelInsertInput>;
  vocabularyWordId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type UserWordsMaxFields = {
  __typename?: 'user_words_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  efactor?: Maybe<Scalars['float8']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  interval?: Maybe<Scalars['Int']['output']>;
  lastReviewAt?: Maybe<Scalars['timestamptz']['output']>;
  nextReviewAt?: Maybe<Scalars['timestamptz']['output']>;
  repetition?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  vocabularyWordId?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "user_words" */
export type UserWordsMaxOrderBy = {
  created_at?: InputMaybe<OrderBy>;
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  lastReviewAt?: InputMaybe<OrderBy>;
  nextReviewAt?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserWordsMinFields = {
  __typename?: 'user_words_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  efactor?: Maybe<Scalars['float8']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  interval?: Maybe<Scalars['Int']['output']>;
  lastReviewAt?: Maybe<Scalars['timestamptz']['output']>;
  nextReviewAt?: Maybe<Scalars['timestamptz']['output']>;
  repetition?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  vocabularyWordId?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "user_words" */
export type UserWordsMinOrderBy = {
  created_at?: InputMaybe<OrderBy>;
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  lastReviewAt?: InputMaybe<OrderBy>;
  nextReviewAt?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_words" */
export type UserWordsMutationResponse = {
  __typename?: 'user_words_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserWords>;
};

/** on_conflict condition type for table "user_words" */
export type UserWordsOnConflict = {
  constraint: UserWordsConstraint;
  update_columns?: Array<UserWordsUpdateColumn>;
  where?: InputMaybe<UserWordsBoolExp>;
};

/** Ordering options when selecting data from "user_words". */
export type UserWordsOrderBy = {
  created_at?: InputMaybe<OrderBy>;
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  lastReviewAt?: InputMaybe<OrderBy>;
  nextReviewAt?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  updated_at?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWord?: InputMaybe<VocabularyWordsOrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_words */
export type UserWordsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "user_words" */
export enum UserWordsSelectColumn {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Efactor = 'efactor',
  /** column name */
  Id = 'id',
  /** column name */
  Interval = 'interval',
  /** column name */
  LastReviewAt = 'lastReviewAt',
  /** column name */
  NextReviewAt = 'nextReviewAt',
  /** column name */
  Repetition = 'repetition',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId',
  /** column name */
  VocabularyWordId = 'vocabularyWordId'
}

/** select "user_words_aggregate_bool_exp_avg_arguments_columns" columns of table "user_words" */
export enum UserWordsSelectColumnUserWordsAggregateBoolExpAvgArgumentsColumns {
  /** column name */
  Efactor = 'efactor'
}

/** select "user_words_aggregate_bool_exp_corr_arguments_columns" columns of table "user_words" */
export enum UserWordsSelectColumnUserWordsAggregateBoolExpCorrArgumentsColumns {
  /** column name */
  Efactor = 'efactor'
}

/** select "user_words_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "user_words" */
export enum UserWordsSelectColumnUserWordsAggregateBoolExpCovarSampArgumentsColumns {
  /** column name */
  Efactor = 'efactor'
}

/** select "user_words_aggregate_bool_exp_max_arguments_columns" columns of table "user_words" */
export enum UserWordsSelectColumnUserWordsAggregateBoolExpMaxArgumentsColumns {
  /** column name */
  Efactor = 'efactor'
}

/** select "user_words_aggregate_bool_exp_min_arguments_columns" columns of table "user_words" */
export enum UserWordsSelectColumnUserWordsAggregateBoolExpMinArgumentsColumns {
  /** column name */
  Efactor = 'efactor'
}

/** select "user_words_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "user_words" */
export enum UserWordsSelectColumnUserWordsAggregateBoolExpStddevSampArgumentsColumns {
  /** column name */
  Efactor = 'efactor'
}

/** select "user_words_aggregate_bool_exp_sum_arguments_columns" columns of table "user_words" */
export enum UserWordsSelectColumnUserWordsAggregateBoolExpSumArgumentsColumns {
  /** column name */
  Efactor = 'efactor'
}

/** select "user_words_aggregate_bool_exp_var_samp_arguments_columns" columns of table "user_words" */
export enum UserWordsSelectColumnUserWordsAggregateBoolExpVarSampArgumentsColumns {
  /** column name */
  Efactor = 'efactor'
}

/** input type for updating data in table "user_words" */
export type UserWordsSetInput = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  efactor?: InputMaybe<Scalars['float8']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  interval?: InputMaybe<Scalars['Int']['input']>;
  lastReviewAt?: InputMaybe<Scalars['timestamptz']['input']>;
  nextReviewAt?: InputMaybe<Scalars['timestamptz']['input']>;
  repetition?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  vocabularyWordId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type UserWordsStddevFields = {
  __typename?: 'user_words_stddev_fields';
  efactor?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  interval?: Maybe<Scalars['Float']['output']>;
  repetition?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  vocabularyWordId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_words" */
export type UserWordsStddevOrderBy = {
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type UserWordsStddevPopFields = {
  __typename?: 'user_words_stddev_pop_fields';
  efactor?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  interval?: Maybe<Scalars['Float']['output']>;
  repetition?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  vocabularyWordId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_words" */
export type UserWordsStddevPopOrderBy = {
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type UserWordsStddevSampFields = {
  __typename?: 'user_words_stddev_samp_fields';
  efactor?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  interval?: Maybe<Scalars['Float']['output']>;
  repetition?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  vocabularyWordId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_words" */
export type UserWordsStddevSampOrderBy = {
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "user_words" */
export type UserWordsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: UserWordsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserWordsStreamCursorValueInput = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  efactor?: InputMaybe<Scalars['float8']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  interval?: InputMaybe<Scalars['Int']['input']>;
  lastReviewAt?: InputMaybe<Scalars['timestamptz']['input']>;
  nextReviewAt?: InputMaybe<Scalars['timestamptz']['input']>;
  repetition?: InputMaybe<Scalars['Int']['input']>;
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  vocabularyWordId?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type UserWordsSumFields = {
  __typename?: 'user_words_sum_fields';
  efactor?: Maybe<Scalars['float8']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  interval?: Maybe<Scalars['Int']['output']>;
  repetition?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  vocabularyWordId?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "user_words" */
export type UserWordsSumOrderBy = {
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** update columns of table "user_words" */
export enum UserWordsUpdateColumn {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Efactor = 'efactor',
  /** column name */
  Id = 'id',
  /** column name */
  Interval = 'interval',
  /** column name */
  LastReviewAt = 'lastReviewAt',
  /** column name */
  NextReviewAt = 'nextReviewAt',
  /** column name */
  Repetition = 'repetition',
  /** column name */
  SubjectId = 'subjectId',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId',
  /** column name */
  VocabularyWordId = 'vocabularyWordId'
}

export type UserWordsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserWordsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserWordsSetInput>;
  /** filter the rows which have to be updated */
  where: UserWordsBoolExp;
};

/** aggregate var_pop on columns */
export type UserWordsVarPopFields = {
  __typename?: 'user_words_var_pop_fields';
  efactor?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  interval?: Maybe<Scalars['Float']['output']>;
  repetition?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  vocabularyWordId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_words" */
export type UserWordsVarPopOrderBy = {
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type UserWordsVarSampFields = {
  __typename?: 'user_words_var_samp_fields';
  efactor?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  interval?: Maybe<Scalars['Float']['output']>;
  repetition?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  vocabularyWordId?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_words" */
export type UserWordsVarSampOrderBy = {
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type UserWordsVarianceFields = {
  __typename?: 'user_words_variance_fields';
  efactor?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  interval?: Maybe<Scalars['Float']['output']>;
  repetition?: Maybe<Scalars['Float']['output']>;
  subjectId?: Maybe<Scalars['Float']['output']>;
  userId?: Maybe<Scalars['Float']['output']>;
  vocabularyWordId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_words" */
export type UserWordsVarianceOrderBy = {
  efactor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  interval?: InputMaybe<OrderBy>;
  repetition?: InputMaybe<OrderBy>;
  subjectId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  vocabularyWordId?: InputMaybe<OrderBy>;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'users';
  /** An array relationship */
  addresses: Array<Addresses>;
  /** An aggregate relationship */
  addresses_aggregate: AddressesAggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['Int']['output']>;
  deviceOS?: Maybe<Scalars['String']['output']>;
  dob: Scalars['timestamptz']['output'];
  email: Scalars['String']['output'];
  emailVerifiedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  employee?: Maybe<Employees>;
  firstName: Scalars['String']['output'];
  goalId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  image?: Maybe<Scalars['String']['output']>;
  lastActive?: Maybe<Scalars['timestamptz']['output']>;
  lastLoggedOn: Scalars['timestamptz']['output'];
  lastName: Scalars['String']['output'];
  mobileVersion?: Maybe<Scalars['String']['output']>;
  password: Scalars['String']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  pushToken?: Maybe<Scalars['String']['output']>;
  socialLinks?: Maybe<Scalars['jsonb']['output']>;
  stripeId?: Maybe<Scalars['String']['output']>;
  subscribedUntil?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  teacher?: Maybe<Teachers>;
  timezone?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
  updatedBy?: Maybe<Scalars['Int']['output']>;
  writingNotifications?: Maybe<Array<Scalars['Int']['output']>>;
};


/** columns and relationships of "users" */
export type UsersAddressesArgs = {
  distinct_on?: InputMaybe<Array<AddressesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AddressesOrderBy>>;
  where?: InputMaybe<AddressesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAddressesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<AddressesOrderBy>>;
  where?: InputMaybe<AddressesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSocialLinksArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

export type UsersAggregate = {
  __typename?: 'users_aggregate';
  aggregate?: Maybe<UsersAggregateFields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type UsersAggregateFields = {
  __typename?: 'users_aggregate_fields';
  avg?: Maybe<UsersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UsersMaxFields>;
  min?: Maybe<UsersMinFields>;
  stddev?: Maybe<UsersStddevFields>;
  stddev_pop?: Maybe<UsersStddevPopFields>;
  stddev_samp?: Maybe<UsersStddevSampFields>;
  sum?: Maybe<UsersSumFields>;
  var_pop?: Maybe<UsersVarPopFields>;
  var_samp?: Maybe<UsersVarSampFields>;
  variance?: Maybe<UsersVarianceFields>;
};


/** aggregate fields of "users" */
export type UsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type UsersAppendInput = {
  socialLinks?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type UsersAvgFields = {
  __typename?: 'users_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  deletedBy?: Maybe<Scalars['Float']['output']>;
  goalId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  updatedBy?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type UsersBoolExp = {
  _and?: InputMaybe<Array<UsersBoolExp>>;
  _not?: InputMaybe<UsersBoolExp>;
  _or?: InputMaybe<Array<UsersBoolExp>>;
  addresses?: InputMaybe<AddressesBoolExp>;
  addresses_aggregate?: InputMaybe<AddressesAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  deletedAt?: InputMaybe<TimestamptzComparisonExp>;
  deletedBy?: InputMaybe<IntComparisonExp>;
  deviceOS?: InputMaybe<StringComparisonExp>;
  dob?: InputMaybe<TimestamptzComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  emailVerifiedAt?: InputMaybe<TimestamptzComparisonExp>;
  employee?: InputMaybe<EmployeesBoolExp>;
  firstName?: InputMaybe<StringComparisonExp>;
  goalId?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  image?: InputMaybe<StringComparisonExp>;
  lastActive?: InputMaybe<TimestamptzComparisonExp>;
  lastLoggedOn?: InputMaybe<TimestamptzComparisonExp>;
  lastName?: InputMaybe<StringComparisonExp>;
  mobileVersion?: InputMaybe<StringComparisonExp>;
  password?: InputMaybe<StringComparisonExp>;
  phone?: InputMaybe<StringComparisonExp>;
  pushToken?: InputMaybe<StringComparisonExp>;
  socialLinks?: InputMaybe<JsonbComparisonExp>;
  stripeId?: InputMaybe<StringComparisonExp>;
  subscribedUntil?: InputMaybe<TimestamptzComparisonExp>;
  teacher?: InputMaybe<TeachersBoolExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedBy?: InputMaybe<IntComparisonExp>;
  writingNotifications?: InputMaybe<IntArrayComparisonExp>;
};

/** unique or primary key constraints on table "users" */
export enum UsersConstraint {
  /** unique or primary key constraint on columns "email" */
  UsersEmailKey = 'users_email_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey',
  /** unique or primary key constraint on columns "stripe_id" */
  UsersStripeIdKey = 'users_stripe_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type UsersDeleteAtPathInput = {
  socialLinks?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type UsersDeleteElemInput = {
  socialLinks?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type UsersDeleteKeyInput = {
  socialLinks?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "users" */
export type UsersIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedBy?: InputMaybe<Scalars['Int']['input']>;
  goalId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  updatedBy?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "users" */
export type UsersInsertInput = {
  addresses?: InputMaybe<AddressesArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['Int']['input']>;
  deviceOS?: InputMaybe<Scalars['String']['input']>;
  dob?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailVerifiedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  employee?: InputMaybe<EmployeesObjRelInsertInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  goalId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  lastActive?: InputMaybe<Scalars['timestamptz']['input']>;
  lastLoggedOn?: InputMaybe<Scalars['timestamptz']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  mobileVersion?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  pushToken?: InputMaybe<Scalars['String']['input']>;
  socialLinks?: InputMaybe<Scalars['jsonb']['input']>;
  stripeId?: InputMaybe<Scalars['String']['input']>;
  subscribedUntil?: InputMaybe<Scalars['timestamptz']['input']>;
  teacher?: InputMaybe<TeachersObjRelInsertInput>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['Int']['input']>;
  writingNotifications?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** aggregate max on columns */
export type UsersMaxFields = {
  __typename?: 'users_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['Int']['output']>;
  deviceOS?: Maybe<Scalars['String']['output']>;
  dob?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  emailVerifiedAt?: Maybe<Scalars['timestamptz']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  goalId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  image?: Maybe<Scalars['String']['output']>;
  lastActive?: Maybe<Scalars['timestamptz']['output']>;
  lastLoggedOn?: Maybe<Scalars['timestamptz']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  mobileVersion?: Maybe<Scalars['String']['output']>;
  password?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  pushToken?: Maybe<Scalars['String']['output']>;
  stripeId?: Maybe<Scalars['String']['output']>;
  subscribedUntil?: Maybe<Scalars['timestamptz']['output']>;
  timezone?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['Int']['output']>;
  writingNotifications?: Maybe<Array<Scalars['Int']['output']>>;
};

/** aggregate min on columns */
export type UsersMinFields = {
  __typename?: 'users_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['Int']['output']>;
  deviceOS?: Maybe<Scalars['String']['output']>;
  dob?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  emailVerifiedAt?: Maybe<Scalars['timestamptz']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  goalId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  image?: Maybe<Scalars['String']['output']>;
  lastActive?: Maybe<Scalars['timestamptz']['output']>;
  lastLoggedOn?: Maybe<Scalars['timestamptz']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  mobileVersion?: Maybe<Scalars['String']['output']>;
  password?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  pushToken?: Maybe<Scalars['String']['output']>;
  stripeId?: Maybe<Scalars['String']['output']>;
  subscribedUntil?: Maybe<Scalars['timestamptz']['output']>;
  timezone?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['Int']['output']>;
  writingNotifications?: Maybe<Array<Scalars['Int']['output']>>;
};

/** response of any mutation on the table "users" */
export type UsersMutationResponse = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type UsersObjRelInsertInput = {
  data: UsersInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<UsersOnConflict>;
};

/** on_conflict condition type for table "users" */
export type UsersOnConflict = {
  constraint: UsersConstraint;
  update_columns?: Array<UsersUpdateColumn>;
  where?: InputMaybe<UsersBoolExp>;
};

/** Ordering options when selecting data from "users". */
export type UsersOrderBy = {
  addresses_aggregate?: InputMaybe<AddressesAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  deletedAt?: InputMaybe<OrderBy>;
  deletedBy?: InputMaybe<OrderBy>;
  deviceOS?: InputMaybe<OrderBy>;
  dob?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  emailVerifiedAt?: InputMaybe<OrderBy>;
  employee?: InputMaybe<EmployeesOrderBy>;
  firstName?: InputMaybe<OrderBy>;
  goalId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  image?: InputMaybe<OrderBy>;
  lastActive?: InputMaybe<OrderBy>;
  lastLoggedOn?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  mobileVersion?: InputMaybe<OrderBy>;
  password?: InputMaybe<OrderBy>;
  phone?: InputMaybe<OrderBy>;
  pushToken?: InputMaybe<OrderBy>;
  socialLinks?: InputMaybe<OrderBy>;
  stripeId?: InputMaybe<OrderBy>;
  subscribedUntil?: InputMaybe<OrderBy>;
  teacher?: InputMaybe<TeachersOrderBy>;
  timezone?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
  writingNotifications?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: users */
export type UsersPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type UsersPrependInput = {
  socialLinks?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "users" */
export enum UsersSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  DeviceOs = 'deviceOS',
  /** column name */
  Dob = 'dob',
  /** column name */
  Email = 'email',
  /** column name */
  EmailVerifiedAt = 'emailVerifiedAt',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  GoalId = 'goalId',
  /** column name */
  Id = 'id',
  /** column name */
  Image = 'image',
  /** column name */
  LastActive = 'lastActive',
  /** column name */
  LastLoggedOn = 'lastLoggedOn',
  /** column name */
  LastName = 'lastName',
  /** column name */
  MobileVersion = 'mobileVersion',
  /** column name */
  Password = 'password',
  /** column name */
  Phone = 'phone',
  /** column name */
  PushToken = 'pushToken',
  /** column name */
  SocialLinks = 'socialLinks',
  /** column name */
  StripeId = 'stripeId',
  /** column name */
  SubscribedUntil = 'subscribedUntil',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  WritingNotifications = 'writingNotifications'
}

/** input type for updating data in table "users" */
export type UsersSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['Int']['input']>;
  deviceOS?: InputMaybe<Scalars['String']['input']>;
  dob?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailVerifiedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  goalId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  lastActive?: InputMaybe<Scalars['timestamptz']['input']>;
  lastLoggedOn?: InputMaybe<Scalars['timestamptz']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  mobileVersion?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  pushToken?: InputMaybe<Scalars['String']['input']>;
  socialLinks?: InputMaybe<Scalars['jsonb']['input']>;
  stripeId?: InputMaybe<Scalars['String']['input']>;
  subscribedUntil?: InputMaybe<Scalars['timestamptz']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['Int']['input']>;
  writingNotifications?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** aggregate stddev on columns */
export type UsersStddevFields = {
  __typename?: 'users_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  deletedBy?: Maybe<Scalars['Float']['output']>;
  goalId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  updatedBy?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type UsersStddevPopFields = {
  __typename?: 'users_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  deletedBy?: Maybe<Scalars['Float']['output']>;
  goalId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  updatedBy?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type UsersStddevSampFields = {
  __typename?: 'users_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  deletedBy?: Maybe<Scalars['Float']['output']>;
  goalId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  updatedBy?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "users" */
export type UsersStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: UsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsersStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['Int']['input']>;
  deviceOS?: InputMaybe<Scalars['String']['input']>;
  dob?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailVerifiedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  goalId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  lastActive?: InputMaybe<Scalars['timestamptz']['input']>;
  lastLoggedOn?: InputMaybe<Scalars['timestamptz']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  mobileVersion?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  pushToken?: InputMaybe<Scalars['String']['input']>;
  socialLinks?: InputMaybe<Scalars['jsonb']['input']>;
  stripeId?: InputMaybe<Scalars['String']['input']>;
  subscribedUntil?: InputMaybe<Scalars['timestamptz']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['Int']['input']>;
  writingNotifications?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** aggregate sum on columns */
export type UsersSumFields = {
  __typename?: 'users_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  deletedBy?: Maybe<Scalars['Int']['output']>;
  goalId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  updatedBy?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "users" */
export enum UsersUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  DeviceOs = 'deviceOS',
  /** column name */
  Dob = 'dob',
  /** column name */
  Email = 'email',
  /** column name */
  EmailVerifiedAt = 'emailVerifiedAt',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  GoalId = 'goalId',
  /** column name */
  Id = 'id',
  /** column name */
  Image = 'image',
  /** column name */
  LastActive = 'lastActive',
  /** column name */
  LastLoggedOn = 'lastLoggedOn',
  /** column name */
  LastName = 'lastName',
  /** column name */
  MobileVersion = 'mobileVersion',
  /** column name */
  Password = 'password',
  /** column name */
  Phone = 'phone',
  /** column name */
  PushToken = 'pushToken',
  /** column name */
  SocialLinks = 'socialLinks',
  /** column name */
  StripeId = 'stripeId',
  /** column name */
  SubscribedUntil = 'subscribedUntil',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  WritingNotifications = 'writingNotifications'
}

export type UsersUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<UsersAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<UsersDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<UsersDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<UsersDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UsersIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<UsersPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsersSetInput>;
  /** filter the rows which have to be updated */
  where: UsersBoolExp;
};

/** aggregate var_pop on columns */
export type UsersVarPopFields = {
  __typename?: 'users_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  deletedBy?: Maybe<Scalars['Float']['output']>;
  goalId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  updatedBy?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type UsersVarSampFields = {
  __typename?: 'users_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  deletedBy?: Maybe<Scalars['Float']['output']>;
  goalId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  updatedBy?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type UsersVarianceFields = {
  __typename?: 'users_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  deletedBy?: Maybe<Scalars['Float']['output']>;
  goalId?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  updatedBy?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "vocabulary_sets" */
export type VocabularySets = {
  __typename?: 'vocabulary_sets';
  /** An object relationship */
  activitySet?: Maybe<ActivitySets>;
  activitySetId?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  /** An array relationship */
  vocabularyWords: Array<VocabularyWords>;
  /** An aggregate relationship */
  vocabularyWords_aggregate: VocabularyWordsAggregate;
};


/** columns and relationships of "vocabulary_sets" */
export type VocabularySetsVocabularyWordsArgs = {
  distinct_on?: InputMaybe<Array<VocabularyWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularyWordsOrderBy>>;
  where?: InputMaybe<VocabularyWordsBoolExp>;
};


/** columns and relationships of "vocabulary_sets" */
export type VocabularySetsVocabularyWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<VocabularyWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<VocabularyWordsOrderBy>>;
  where?: InputMaybe<VocabularyWordsBoolExp>;
};

/** aggregated selection of "vocabulary_sets" */
export type VocabularySetsAggregate = {
  __typename?: 'vocabulary_sets_aggregate';
  aggregate?: Maybe<VocabularySetsAggregateFields>;
  nodes: Array<VocabularySets>;
};

/** aggregate fields of "vocabulary_sets" */
export type VocabularySetsAggregateFields = {
  __typename?: 'vocabulary_sets_aggregate_fields';
  avg?: Maybe<VocabularySetsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<VocabularySetsMaxFields>;
  min?: Maybe<VocabularySetsMinFields>;
  stddev?: Maybe<VocabularySetsStddevFields>;
  stddev_pop?: Maybe<VocabularySetsStddevPopFields>;
  stddev_samp?: Maybe<VocabularySetsStddevSampFields>;
  sum?: Maybe<VocabularySetsSumFields>;
  var_pop?: Maybe<VocabularySetsVarPopFields>;
  var_samp?: Maybe<VocabularySetsVarSampFields>;
  variance?: Maybe<VocabularySetsVarianceFields>;
};


/** aggregate fields of "vocabulary_sets" */
export type VocabularySetsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VocabularySetsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type VocabularySetsAvgFields = {
  __typename?: 'vocabulary_sets_avg_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "vocabulary_sets". All fields are combined with a logical 'AND'. */
export type VocabularySetsBoolExp = {
  _and?: InputMaybe<Array<VocabularySetsBoolExp>>;
  _not?: InputMaybe<VocabularySetsBoolExp>;
  _or?: InputMaybe<Array<VocabularySetsBoolExp>>;
  activitySet?: InputMaybe<ActivitySetsBoolExp>;
  activitySetId?: InputMaybe<IntComparisonExp>;
  classSessionId?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  vocabularyWords?: InputMaybe<VocabularyWordsBoolExp>;
  vocabularyWords_aggregate?: InputMaybe<VocabularyWordsAggregateBoolExp>;
};

/** unique or primary key constraints on table "vocabulary_sets" */
export enum VocabularySetsConstraint {
  /** unique or primary key constraint on columns "id" */
  VocabularySetPkey = 'vocabulary_set_pkey',
  /** unique or primary key constraint on columns "activity_set_id", "created_by" */
  VocabularySetsActivitySetIdCreatedByKey = 'vocabulary_sets_activity_set_id_created_by_key'
}

/** input type for incrementing numeric columns in table "vocabulary_sets" */
export type VocabularySetsIncInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "vocabulary_sets" */
export type VocabularySetsInsertInput = {
  activitySet?: InputMaybe<ActivitySetsObjRelInsertInput>;
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  vocabularyWords?: InputMaybe<VocabularyWordsArrRelInsertInput>;
};

/** aggregate max on columns */
export type VocabularySetsMaxFields = {
  __typename?: 'vocabulary_sets_max_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type VocabularySetsMinFields = {
  __typename?: 'vocabulary_sets_min_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "vocabulary_sets" */
export type VocabularySetsMutationResponse = {
  __typename?: 'vocabulary_sets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<VocabularySets>;
};

/** input type for inserting object relation for remote table "vocabulary_sets" */
export type VocabularySetsObjRelInsertInput = {
  data: VocabularySetsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<VocabularySetsOnConflict>;
};

/** on_conflict condition type for table "vocabulary_sets" */
export type VocabularySetsOnConflict = {
  constraint: VocabularySetsConstraint;
  update_columns?: Array<VocabularySetsUpdateColumn>;
  where?: InputMaybe<VocabularySetsBoolExp>;
};

/** Ordering options when selecting data from "vocabulary_sets". */
export type VocabularySetsOrderBy = {
  activitySet?: InputMaybe<ActivitySetsOrderBy>;
  activitySetId?: InputMaybe<OrderBy>;
  classSessionId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  vocabularyWords_aggregate?: InputMaybe<VocabularyWordsAggregateOrderBy>;
};

/** primary key columns input for table: vocabulary_sets */
export type VocabularySetsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "vocabulary_sets" */
export enum VocabularySetsSelectColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  ClassSessionId = 'classSessionId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "vocabulary_sets" */
export type VocabularySetsSetInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type VocabularySetsStddevFields = {
  __typename?: 'vocabulary_sets_stddev_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type VocabularySetsStddevPopFields = {
  __typename?: 'vocabulary_sets_stddev_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type VocabularySetsStddevSampFields = {
  __typename?: 'vocabulary_sets_stddev_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "vocabulary_sets" */
export type VocabularySetsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: VocabularySetsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VocabularySetsStreamCursorValueInput = {
  activitySetId?: InputMaybe<Scalars['Int']['input']>;
  classSessionId?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type VocabularySetsSumFields = {
  __typename?: 'vocabulary_sets_sum_fields';
  activitySetId?: Maybe<Scalars['Int']['output']>;
  classSessionId?: Maybe<Scalars['Int']['output']>;
  createdBy?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "vocabulary_sets" */
export enum VocabularySetsUpdateColumn {
  /** column name */
  ActivitySetId = 'activitySetId',
  /** column name */
  ClassSessionId = 'classSessionId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type VocabularySetsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<VocabularySetsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VocabularySetsSetInput>;
  /** filter the rows which have to be updated */
  where: VocabularySetsBoolExp;
};

/** aggregate var_pop on columns */
export type VocabularySetsVarPopFields = {
  __typename?: 'vocabulary_sets_var_pop_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type VocabularySetsVarSampFields = {
  __typename?: 'vocabulary_sets_var_samp_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type VocabularySetsVarianceFields = {
  __typename?: 'vocabulary_sets_variance_fields';
  activitySetId?: Maybe<Scalars['Float']['output']>;
  classSessionId?: Maybe<Scalars['Float']['output']>;
  createdBy?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "vocabulary_words" */
export type VocabularyWords = {
  __typename?: 'vocabulary_words';
  createdBy: Scalars['Int']['output'];
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  defLanguage?: Maybe<Languages>;
  definition: Scalars['String']['output'];
  definitionLanguage?: Maybe<Scalars['Int']['output']>;
  definitionPronunciation?: Maybe<Scalars['String']['output']>;
  example?: Maybe<Scalars['String']['output']>;
  examplePronunciation?: Maybe<Scalars['String']['output']>;
  exampleTranslation?: Maybe<Scalars['String']['output']>;
  frequency?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** An object relationship */
  image?: Maybe<Images>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order: Scalars['Int']['output'];
  pos?: Maybe<PartsOfSpeechEnum>;
  pronunciation?: Maybe<Scalars['String']['output']>;
  synset?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  userWords: Array<UserWords>;
  /** An aggregate relationship */
  userWords_aggregate: UserWordsAggregate;
  /** An object relationship */
  vocabularySet?: Maybe<VocabularySets>;
  vocabularySetId?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  wLanguage?: Maybe<Languages>;
  word: Scalars['String']['output'];
  wordLanguage?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "vocabulary_words" */
export type VocabularyWordsUserWordsArgs = {
  distinct_on?: InputMaybe<Array<UserWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsOrderBy>>;
  where?: InputMaybe<UserWordsBoolExp>;
};


/** columns and relationships of "vocabulary_words" */
export type VocabularyWordsUserWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserWordsOrderBy>>;
  where?: InputMaybe<UserWordsBoolExp>;
};

/** aggregated selection of "vocabulary_words" */
export type VocabularyWordsAggregate = {
  __typename?: 'vocabulary_words_aggregate';
  aggregate?: Maybe<VocabularyWordsAggregateFields>;
  nodes: Array<VocabularyWords>;
};

export type VocabularyWordsAggregateBoolExp = {
  count?: InputMaybe<VocabularyWordsAggregateBoolExpCount>;
};

export type VocabularyWordsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<VocabularyWordsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<VocabularyWordsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "vocabulary_words" */
export type VocabularyWordsAggregateFields = {
  __typename?: 'vocabulary_words_aggregate_fields';
  avg?: Maybe<VocabularyWordsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<VocabularyWordsMaxFields>;
  min?: Maybe<VocabularyWordsMinFields>;
  stddev?: Maybe<VocabularyWordsStddevFields>;
  stddev_pop?: Maybe<VocabularyWordsStddevPopFields>;
  stddev_samp?: Maybe<VocabularyWordsStddevSampFields>;
  sum?: Maybe<VocabularyWordsSumFields>;
  var_pop?: Maybe<VocabularyWordsVarPopFields>;
  var_samp?: Maybe<VocabularyWordsVarSampFields>;
  variance?: Maybe<VocabularyWordsVarianceFields>;
};


/** aggregate fields of "vocabulary_words" */
export type VocabularyWordsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VocabularyWordsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "vocabulary_words" */
export type VocabularyWordsAggregateOrderBy = {
  avg?: InputMaybe<VocabularyWordsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VocabularyWordsMaxOrderBy>;
  min?: InputMaybe<VocabularyWordsMinOrderBy>;
  stddev?: InputMaybe<VocabularyWordsStddevOrderBy>;
  stddev_pop?: InputMaybe<VocabularyWordsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<VocabularyWordsStddevSampOrderBy>;
  sum?: InputMaybe<VocabularyWordsSumOrderBy>;
  var_pop?: InputMaybe<VocabularyWordsVarPopOrderBy>;
  var_samp?: InputMaybe<VocabularyWordsVarSampOrderBy>;
  variance?: InputMaybe<VocabularyWordsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "vocabulary_words" */
export type VocabularyWordsArrRelInsertInput = {
  data: Array<VocabularyWordsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<VocabularyWordsOnConflict>;
};

/** aggregate avg on columns */
export type VocabularyWordsAvgFields = {
  __typename?: 'vocabulary_words_avg_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  definitionLanguage?: Maybe<Scalars['Float']['output']>;
  frequency?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  vocabularySetId?: Maybe<Scalars['Float']['output']>;
  wordLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "vocabulary_words" */
export type VocabularyWordsAvgOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "vocabulary_words". All fields are combined with a logical 'AND'. */
export type VocabularyWordsBoolExp = {
  _and?: InputMaybe<Array<VocabularyWordsBoolExp>>;
  _not?: InputMaybe<VocabularyWordsBoolExp>;
  _or?: InputMaybe<Array<VocabularyWordsBoolExp>>;
  createdBy?: InputMaybe<IntComparisonExp>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  defLanguage?: InputMaybe<LanguagesBoolExp>;
  definition?: InputMaybe<StringComparisonExp>;
  definitionLanguage?: InputMaybe<IntComparisonExp>;
  definitionPronunciation?: InputMaybe<StringComparisonExp>;
  example?: InputMaybe<StringComparisonExp>;
  examplePronunciation?: InputMaybe<StringComparisonExp>;
  exampleTranslation?: InputMaybe<StringComparisonExp>;
  frequency?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  image?: InputMaybe<ImagesBoolExp>;
  imageId?: InputMaybe<IntComparisonExp>;
  order?: InputMaybe<IntComparisonExp>;
  pos?: InputMaybe<PartsOfSpeechEnumComparisonExp>;
  pronunciation?: InputMaybe<StringComparisonExp>;
  synset?: InputMaybe<StringComparisonExp>;
  userWords?: InputMaybe<UserWordsBoolExp>;
  userWords_aggregate?: InputMaybe<UserWordsAggregateBoolExp>;
  vocabularySet?: InputMaybe<VocabularySetsBoolExp>;
  vocabularySetId?: InputMaybe<IntComparisonExp>;
  wLanguage?: InputMaybe<LanguagesBoolExp>;
  word?: InputMaybe<StringComparisonExp>;
  wordLanguage?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "vocabulary_words" */
export enum VocabularyWordsConstraint {
  /** unique or primary key constraint on columns "id" */
  VocabularyWordsPkey = 'vocabulary_words_pkey'
}

/** input type for incrementing numeric columns in table "vocabulary_words" */
export type VocabularyWordsIncInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  definitionLanguage?: InputMaybe<Scalars['Int']['input']>;
  frequency?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  vocabularySetId?: InputMaybe<Scalars['Int']['input']>;
  wordLanguage?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "vocabulary_words" */
export type VocabularyWordsInsertInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  defLanguage?: InputMaybe<LanguagesObjRelInsertInput>;
  definition?: InputMaybe<Scalars['String']['input']>;
  definitionLanguage?: InputMaybe<Scalars['Int']['input']>;
  definitionPronunciation?: InputMaybe<Scalars['String']['input']>;
  example?: InputMaybe<Scalars['String']['input']>;
  examplePronunciation?: InputMaybe<Scalars['String']['input']>;
  exampleTranslation?: InputMaybe<Scalars['String']['input']>;
  frequency?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  image?: InputMaybe<ImagesObjRelInsertInput>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  pos?: InputMaybe<PartsOfSpeechEnum>;
  pronunciation?: InputMaybe<Scalars['String']['input']>;
  synset?: InputMaybe<Scalars['String']['input']>;
  userWords?: InputMaybe<UserWordsArrRelInsertInput>;
  vocabularySet?: InputMaybe<VocabularySetsObjRelInsertInput>;
  vocabularySetId?: InputMaybe<Scalars['Int']['input']>;
  wLanguage?: InputMaybe<LanguagesObjRelInsertInput>;
  word?: InputMaybe<Scalars['String']['input']>;
  wordLanguage?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type VocabularyWordsMaxFields = {
  __typename?: 'vocabulary_words_max_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  definition?: Maybe<Scalars['String']['output']>;
  definitionLanguage?: Maybe<Scalars['Int']['output']>;
  definitionPronunciation?: Maybe<Scalars['String']['output']>;
  example?: Maybe<Scalars['String']['output']>;
  examplePronunciation?: Maybe<Scalars['String']['output']>;
  exampleTranslation?: Maybe<Scalars['String']['output']>;
  frequency?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  pronunciation?: Maybe<Scalars['String']['output']>;
  synset?: Maybe<Scalars['String']['output']>;
  vocabularySetId?: Maybe<Scalars['Int']['output']>;
  word?: Maybe<Scalars['String']['output']>;
  wordLanguage?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "vocabulary_words" */
export type VocabularyWordsMaxOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  definition?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  definitionPronunciation?: InputMaybe<OrderBy>;
  example?: InputMaybe<OrderBy>;
  examplePronunciation?: InputMaybe<OrderBy>;
  exampleTranslation?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  pronunciation?: InputMaybe<OrderBy>;
  synset?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type VocabularyWordsMinFields = {
  __typename?: 'vocabulary_words_min_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  definition?: Maybe<Scalars['String']['output']>;
  definitionLanguage?: Maybe<Scalars['Int']['output']>;
  definitionPronunciation?: Maybe<Scalars['String']['output']>;
  example?: Maybe<Scalars['String']['output']>;
  examplePronunciation?: Maybe<Scalars['String']['output']>;
  exampleTranslation?: Maybe<Scalars['String']['output']>;
  frequency?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  pronunciation?: Maybe<Scalars['String']['output']>;
  synset?: Maybe<Scalars['String']['output']>;
  vocabularySetId?: Maybe<Scalars['Int']['output']>;
  word?: Maybe<Scalars['String']['output']>;
  wordLanguage?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "vocabulary_words" */
export type VocabularyWordsMinOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  definition?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  definitionPronunciation?: InputMaybe<OrderBy>;
  example?: InputMaybe<OrderBy>;
  examplePronunciation?: InputMaybe<OrderBy>;
  exampleTranslation?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  pronunciation?: InputMaybe<OrderBy>;
  synset?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "vocabulary_words" */
export type VocabularyWordsMutationResponse = {
  __typename?: 'vocabulary_words_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<VocabularyWords>;
};

/** input type for inserting object relation for remote table "vocabulary_words" */
export type VocabularyWordsObjRelInsertInput = {
  data: VocabularyWordsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<VocabularyWordsOnConflict>;
};

/** on_conflict condition type for table "vocabulary_words" */
export type VocabularyWordsOnConflict = {
  constraint: VocabularyWordsConstraint;
  update_columns?: Array<VocabularyWordsUpdateColumn>;
  where?: InputMaybe<VocabularyWordsBoolExp>;
};

/** Ordering options when selecting data from "vocabulary_words". */
export type VocabularyWordsOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  defLanguage?: InputMaybe<LanguagesOrderBy>;
  definition?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  definitionPronunciation?: InputMaybe<OrderBy>;
  example?: InputMaybe<OrderBy>;
  examplePronunciation?: InputMaybe<OrderBy>;
  exampleTranslation?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  image?: InputMaybe<ImagesOrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  pos?: InputMaybe<OrderBy>;
  pronunciation?: InputMaybe<OrderBy>;
  synset?: InputMaybe<OrderBy>;
  userWords_aggregate?: InputMaybe<UserWordsAggregateOrderBy>;
  vocabularySet?: InputMaybe<VocabularySetsOrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wLanguage?: InputMaybe<LanguagesOrderBy>;
  word?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vocabulary_words */
export type VocabularyWordsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "vocabulary_words" */
export enum VocabularyWordsSelectColumn {
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Definition = 'definition',
  /** column name */
  DefinitionLanguage = 'definitionLanguage',
  /** column name */
  DefinitionPronunciation = 'definitionPronunciation',
  /** column name */
  Example = 'example',
  /** column name */
  ExamplePronunciation = 'examplePronunciation',
  /** column name */
  ExampleTranslation = 'exampleTranslation',
  /** column name */
  Frequency = 'frequency',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  Order = 'order',
  /** column name */
  Pos = 'pos',
  /** column name */
  Pronunciation = 'pronunciation',
  /** column name */
  Synset = 'synset',
  /** column name */
  VocabularySetId = 'vocabularySetId',
  /** column name */
  Word = 'word',
  /** column name */
  WordLanguage = 'wordLanguage'
}

/** input type for updating data in table "vocabulary_words" */
export type VocabularyWordsSetInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  definition?: InputMaybe<Scalars['String']['input']>;
  definitionLanguage?: InputMaybe<Scalars['Int']['input']>;
  definitionPronunciation?: InputMaybe<Scalars['String']['input']>;
  example?: InputMaybe<Scalars['String']['input']>;
  examplePronunciation?: InputMaybe<Scalars['String']['input']>;
  exampleTranslation?: InputMaybe<Scalars['String']['input']>;
  frequency?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  pos?: InputMaybe<PartsOfSpeechEnum>;
  pronunciation?: InputMaybe<Scalars['String']['input']>;
  synset?: InputMaybe<Scalars['String']['input']>;
  vocabularySetId?: InputMaybe<Scalars['Int']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
  wordLanguage?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type VocabularyWordsStddevFields = {
  __typename?: 'vocabulary_words_stddev_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  definitionLanguage?: Maybe<Scalars['Float']['output']>;
  frequency?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  vocabularySetId?: Maybe<Scalars['Float']['output']>;
  wordLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "vocabulary_words" */
export type VocabularyWordsStddevOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type VocabularyWordsStddevPopFields = {
  __typename?: 'vocabulary_words_stddev_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  definitionLanguage?: Maybe<Scalars['Float']['output']>;
  frequency?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  vocabularySetId?: Maybe<Scalars['Float']['output']>;
  wordLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "vocabulary_words" */
export type VocabularyWordsStddevPopOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type VocabularyWordsStddevSampFields = {
  __typename?: 'vocabulary_words_stddev_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  definitionLanguage?: Maybe<Scalars['Float']['output']>;
  frequency?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  vocabularySetId?: Maybe<Scalars['Float']['output']>;
  wordLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "vocabulary_words" */
export type VocabularyWordsStddevSampOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "vocabulary_words" */
export type VocabularyWordsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: VocabularyWordsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VocabularyWordsStreamCursorValueInput = {
  createdBy?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  definition?: InputMaybe<Scalars['String']['input']>;
  definitionLanguage?: InputMaybe<Scalars['Int']['input']>;
  definitionPronunciation?: InputMaybe<Scalars['String']['input']>;
  example?: InputMaybe<Scalars['String']['input']>;
  examplePronunciation?: InputMaybe<Scalars['String']['input']>;
  exampleTranslation?: InputMaybe<Scalars['String']['input']>;
  frequency?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  imageId?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  pos?: InputMaybe<PartsOfSpeechEnum>;
  pronunciation?: InputMaybe<Scalars['String']['input']>;
  synset?: InputMaybe<Scalars['String']['input']>;
  vocabularySetId?: InputMaybe<Scalars['Int']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
  wordLanguage?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type VocabularyWordsSumFields = {
  __typename?: 'vocabulary_words_sum_fields';
  createdBy?: Maybe<Scalars['Int']['output']>;
  definitionLanguage?: Maybe<Scalars['Int']['output']>;
  frequency?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  imageId?: Maybe<Scalars['Int']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  vocabularySetId?: Maybe<Scalars['Int']['output']>;
  wordLanguage?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "vocabulary_words" */
export type VocabularyWordsSumOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** update columns of table "vocabulary_words" */
export enum VocabularyWordsUpdateColumn {
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Definition = 'definition',
  /** column name */
  DefinitionLanguage = 'definitionLanguage',
  /** column name */
  DefinitionPronunciation = 'definitionPronunciation',
  /** column name */
  Example = 'example',
  /** column name */
  ExamplePronunciation = 'examplePronunciation',
  /** column name */
  ExampleTranslation = 'exampleTranslation',
  /** column name */
  Frequency = 'frequency',
  /** column name */
  Id = 'id',
  /** column name */
  ImageId = 'imageId',
  /** column name */
  Order = 'order',
  /** column name */
  Pos = 'pos',
  /** column name */
  Pronunciation = 'pronunciation',
  /** column name */
  Synset = 'synset',
  /** column name */
  VocabularySetId = 'vocabularySetId',
  /** column name */
  Word = 'word',
  /** column name */
  WordLanguage = 'wordLanguage'
}

export type VocabularyWordsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<VocabularyWordsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VocabularyWordsSetInput>;
  /** filter the rows which have to be updated */
  where: VocabularyWordsBoolExp;
};

/** aggregate var_pop on columns */
export type VocabularyWordsVarPopFields = {
  __typename?: 'vocabulary_words_var_pop_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  definitionLanguage?: Maybe<Scalars['Float']['output']>;
  frequency?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  vocabularySetId?: Maybe<Scalars['Float']['output']>;
  wordLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "vocabulary_words" */
export type VocabularyWordsVarPopOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type VocabularyWordsVarSampFields = {
  __typename?: 'vocabulary_words_var_samp_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  definitionLanguage?: Maybe<Scalars['Float']['output']>;
  frequency?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  vocabularySetId?: Maybe<Scalars['Float']['output']>;
  wordLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "vocabulary_words" */
export type VocabularyWordsVarSampOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type VocabularyWordsVarianceFields = {
  __typename?: 'vocabulary_words_variance_fields';
  createdBy?: Maybe<Scalars['Float']['output']>;
  definitionLanguage?: Maybe<Scalars['Float']['output']>;
  frequency?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  imageId?: Maybe<Scalars['Float']['output']>;
  order?: Maybe<Scalars['Float']['output']>;
  vocabularySetId?: Maybe<Scalars['Float']['output']>;
  wordLanguage?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "vocabulary_words" */
export type VocabularyWordsVarianceOrderBy = {
  createdBy?: InputMaybe<OrderBy>;
  definitionLanguage?: InputMaybe<OrderBy>;
  frequency?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  imageId?: InputMaybe<OrderBy>;
  order?: InputMaybe<OrderBy>;
  vocabularySetId?: InputMaybe<OrderBy>;
  wordLanguage?: InputMaybe<OrderBy>;
};

/** columns and relationships of "wordnet.english_words" */
export type WordnetEnglishWords = {
  __typename?: 'wordnet_english_words';
  example?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** An object relationship */
  synset: WordnetSynsets;
  synsetId: Scalars['Int']['output'];
  synsetRank: Scalars['Int']['output'];
  word: Scalars['String']['output'];
  wordFrequency?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "wordnet.english_words" */
export type WordnetEnglishWordsAggregate = {
  __typename?: 'wordnet_english_words_aggregate';
  aggregate?: Maybe<WordnetEnglishWordsAggregateFields>;
  nodes: Array<WordnetEnglishWords>;
};

export type WordnetEnglishWordsAggregateBoolExp = {
  count?: InputMaybe<WordnetEnglishWordsAggregateBoolExpCount>;
};

export type WordnetEnglishWordsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<WordnetEnglishWordsBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "wordnet.english_words" */
export type WordnetEnglishWordsAggregateFields = {
  __typename?: 'wordnet_english_words_aggregate_fields';
  avg?: Maybe<WordnetEnglishWordsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<WordnetEnglishWordsMaxFields>;
  min?: Maybe<WordnetEnglishWordsMinFields>;
  stddev?: Maybe<WordnetEnglishWordsStddevFields>;
  stddev_pop?: Maybe<WordnetEnglishWordsStddevPopFields>;
  stddev_samp?: Maybe<WordnetEnglishWordsStddevSampFields>;
  sum?: Maybe<WordnetEnglishWordsSumFields>;
  var_pop?: Maybe<WordnetEnglishWordsVarPopFields>;
  var_samp?: Maybe<WordnetEnglishWordsVarSampFields>;
  variance?: Maybe<WordnetEnglishWordsVarianceFields>;
};


/** aggregate fields of "wordnet.english_words" */
export type WordnetEnglishWordsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "wordnet.english_words" */
export type WordnetEnglishWordsAggregateOrderBy = {
  avg?: InputMaybe<WordnetEnglishWordsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<WordnetEnglishWordsMaxOrderBy>;
  min?: InputMaybe<WordnetEnglishWordsMinOrderBy>;
  stddev?: InputMaybe<WordnetEnglishWordsStddevOrderBy>;
  stddev_pop?: InputMaybe<WordnetEnglishWordsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<WordnetEnglishWordsStddevSampOrderBy>;
  sum?: InputMaybe<WordnetEnglishWordsSumOrderBy>;
  var_pop?: InputMaybe<WordnetEnglishWordsVarPopOrderBy>;
  var_samp?: InputMaybe<WordnetEnglishWordsVarSampOrderBy>;
  variance?: InputMaybe<WordnetEnglishWordsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "wordnet.english_words" */
export type WordnetEnglishWordsArrRelInsertInput = {
  data: Array<WordnetEnglishWordsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<WordnetEnglishWordsOnConflict>;
};

/** aggregate avg on columns */
export type WordnetEnglishWordsAvgFields = {
  __typename?: 'wordnet_english_words_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  synsetRank?: Maybe<Scalars['Float']['output']>;
  wordFrequency?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "wordnet.english_words". All fields are combined with a logical 'AND'. */
export type WordnetEnglishWordsBoolExp = {
  _and?: InputMaybe<Array<WordnetEnglishWordsBoolExp>>;
  _not?: InputMaybe<WordnetEnglishWordsBoolExp>;
  _or?: InputMaybe<Array<WordnetEnglishWordsBoolExp>>;
  example?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<IntComparisonExp>;
  synset?: InputMaybe<WordnetSynsetsBoolExp>;
  synsetId?: InputMaybe<IntComparisonExp>;
  synsetRank?: InputMaybe<IntComparisonExp>;
  word?: InputMaybe<StringComparisonExp>;
  wordFrequency?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "wordnet.english_words" */
export enum WordnetEnglishWordsConstraint {
  /** unique or primary key constraint on columns "id" */
  EnglishWordsPkey = 'english_words_pkey'
}

/** input type for incrementing numeric columns in table "wordnet.english_words" */
export type WordnetEnglishWordsIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  synsetId?: InputMaybe<Scalars['Int']['input']>;
  synsetRank?: InputMaybe<Scalars['Int']['input']>;
  wordFrequency?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "wordnet.english_words" */
export type WordnetEnglishWordsInsertInput = {
  example?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  synset?: InputMaybe<WordnetSynsetsObjRelInsertInput>;
  synsetId?: InputMaybe<Scalars['Int']['input']>;
  synsetRank?: InputMaybe<Scalars['Int']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
  wordFrequency?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type WordnetEnglishWordsMaxFields = {
  __typename?: 'wordnet_english_words_max_fields';
  example?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  synsetId?: Maybe<Scalars['Int']['output']>;
  synsetRank?: Maybe<Scalars['Int']['output']>;
  word?: Maybe<Scalars['String']['output']>;
  wordFrequency?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsMaxOrderBy = {
  example?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type WordnetEnglishWordsMinFields = {
  __typename?: 'wordnet_english_words_min_fields';
  example?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  synsetId?: Maybe<Scalars['Int']['output']>;
  synsetRank?: Maybe<Scalars['Int']['output']>;
  word?: Maybe<Scalars['String']['output']>;
  wordFrequency?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsMinOrderBy = {
  example?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "wordnet.english_words" */
export type WordnetEnglishWordsMutationResponse = {
  __typename?: 'wordnet_english_words_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<WordnetEnglishWords>;
};

/** on_conflict condition type for table "wordnet.english_words" */
export type WordnetEnglishWordsOnConflict = {
  constraint: WordnetEnglishWordsConstraint;
  update_columns?: Array<WordnetEnglishWordsUpdateColumn>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};

/** Ordering options when selecting data from "wordnet.english_words". */
export type WordnetEnglishWordsOrderBy = {
  example?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  synset?: InputMaybe<WordnetSynsetsOrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  word?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: wordnet.english_words */
export type WordnetEnglishWordsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "wordnet.english_words" */
export enum WordnetEnglishWordsSelectColumn {
  /** column name */
  Example = 'example',
  /** column name */
  Id = 'id',
  /** column name */
  SynsetId = 'synsetId',
  /** column name */
  SynsetRank = 'synsetRank',
  /** column name */
  Word = 'word',
  /** column name */
  WordFrequency = 'wordFrequency'
}

/** input type for updating data in table "wordnet.english_words" */
export type WordnetEnglishWordsSetInput = {
  example?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  synsetId?: InputMaybe<Scalars['Int']['input']>;
  synsetRank?: InputMaybe<Scalars['Int']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
  wordFrequency?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type WordnetEnglishWordsStddevFields = {
  __typename?: 'wordnet_english_words_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  synsetRank?: Maybe<Scalars['Float']['output']>;
  wordFrequency?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type WordnetEnglishWordsStddevPopFields = {
  __typename?: 'wordnet_english_words_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  synsetRank?: Maybe<Scalars['Float']['output']>;
  wordFrequency?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type WordnetEnglishWordsStddevSampFields = {
  __typename?: 'wordnet_english_words_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  synsetRank?: Maybe<Scalars['Float']['output']>;
  wordFrequency?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "wordnet_english_words" */
export type WordnetEnglishWordsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: WordnetEnglishWordsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type WordnetEnglishWordsStreamCursorValueInput = {
  example?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  synsetId?: InputMaybe<Scalars['Int']['input']>;
  synsetRank?: InputMaybe<Scalars['Int']['input']>;
  word?: InputMaybe<Scalars['String']['input']>;
  wordFrequency?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type WordnetEnglishWordsSumFields = {
  __typename?: 'wordnet_english_words_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  synsetId?: Maybe<Scalars['Int']['output']>;
  synsetRank?: Maybe<Scalars['Int']['output']>;
  wordFrequency?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** update columns of table "wordnet.english_words" */
export enum WordnetEnglishWordsUpdateColumn {
  /** column name */
  Example = 'example',
  /** column name */
  Id = 'id',
  /** column name */
  SynsetId = 'synsetId',
  /** column name */
  SynsetRank = 'synsetRank',
  /** column name */
  Word = 'word',
  /** column name */
  WordFrequency = 'wordFrequency'
}

export type WordnetEnglishWordsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<WordnetEnglishWordsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<WordnetEnglishWordsSetInput>;
  /** filter the rows which have to be updated */
  where: WordnetEnglishWordsBoolExp;
};

/** aggregate var_pop on columns */
export type WordnetEnglishWordsVarPopFields = {
  __typename?: 'wordnet_english_words_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  synsetRank?: Maybe<Scalars['Float']['output']>;
  wordFrequency?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type WordnetEnglishWordsVarSampFields = {
  __typename?: 'wordnet_english_words_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  synsetRank?: Maybe<Scalars['Float']['output']>;
  wordFrequency?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type WordnetEnglishWordsVarianceFields = {
  __typename?: 'wordnet_english_words_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  synsetId?: Maybe<Scalars['Float']['output']>;
  synsetRank?: Maybe<Scalars['Float']['output']>;
  wordFrequency?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "wordnet.english_words" */
export type WordnetEnglishWordsVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  synsetId?: InputMaybe<OrderBy>;
  synsetRank?: InputMaybe<OrderBy>;
  wordFrequency?: InputMaybe<OrderBy>;
};

export type WordnetSearchWordnetEnglishArgs = {
  search?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "wordnet.synsets" */
export type WordnetSynsets = {
  __typename?: 'wordnet_synsets';
  antonym?: Maybe<Scalars['String']['output']>;
  definition: Scalars['String']['output'];
  /** An array relationship */
  englishWords: Array<WordnetEnglishWords>;
  /** An aggregate relationship */
  englishWords_aggregate: WordnetEnglishWordsAggregate;
  id: Scalars['Int']['output'];
  pos: Scalars['String']['output'];
  synset_id: Scalars['String']['output'];
};


/** columns and relationships of "wordnet.synsets" */
export type WordnetSynsetsEnglishWordsArgs = {
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};


/** columns and relationships of "wordnet.synsets" */
export type WordnetSynsetsEnglishWordsAggregateArgs = {
  distinct_on?: InputMaybe<Array<WordnetEnglishWordsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<WordnetEnglishWordsOrderBy>>;
  where?: InputMaybe<WordnetEnglishWordsBoolExp>;
};

/** aggregated selection of "wordnet.synsets" */
export type WordnetSynsetsAggregate = {
  __typename?: 'wordnet_synsets_aggregate';
  aggregate?: Maybe<WordnetSynsetsAggregateFields>;
  nodes: Array<WordnetSynsets>;
};

/** aggregate fields of "wordnet.synsets" */
export type WordnetSynsetsAggregateFields = {
  __typename?: 'wordnet_synsets_aggregate_fields';
  avg?: Maybe<WordnetSynsetsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<WordnetSynsetsMaxFields>;
  min?: Maybe<WordnetSynsetsMinFields>;
  stddev?: Maybe<WordnetSynsetsStddevFields>;
  stddev_pop?: Maybe<WordnetSynsetsStddevPopFields>;
  stddev_samp?: Maybe<WordnetSynsetsStddevSampFields>;
  sum?: Maybe<WordnetSynsetsSumFields>;
  var_pop?: Maybe<WordnetSynsetsVarPopFields>;
  var_samp?: Maybe<WordnetSynsetsVarSampFields>;
  variance?: Maybe<WordnetSynsetsVarianceFields>;
};


/** aggregate fields of "wordnet.synsets" */
export type WordnetSynsetsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<WordnetSynsetsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type WordnetSynsetsAvgFields = {
  __typename?: 'wordnet_synsets_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "wordnet.synsets". All fields are combined with a logical 'AND'. */
export type WordnetSynsetsBoolExp = {
  _and?: InputMaybe<Array<WordnetSynsetsBoolExp>>;
  _not?: InputMaybe<WordnetSynsetsBoolExp>;
  _or?: InputMaybe<Array<WordnetSynsetsBoolExp>>;
  antonym?: InputMaybe<StringComparisonExp>;
  definition?: InputMaybe<StringComparisonExp>;
  englishWords?: InputMaybe<WordnetEnglishWordsBoolExp>;
  englishWords_aggregate?: InputMaybe<WordnetEnglishWordsAggregateBoolExp>;
  id?: InputMaybe<IntComparisonExp>;
  pos?: InputMaybe<StringComparisonExp>;
  synset_id?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "wordnet.synsets" */
export enum WordnetSynsetsConstraint {
  /** unique or primary key constraint on columns "id" */
  SynsetsPkey = 'synsets_pkey',
  /** unique or primary key constraint on columns "synset_id" */
  SynsetsSynsetIdKey = 'synsets_synset_id_key'
}

/** input type for incrementing numeric columns in table "wordnet.synsets" */
export type WordnetSynsetsIncInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "wordnet.synsets" */
export type WordnetSynsetsInsertInput = {
  antonym?: InputMaybe<Scalars['String']['input']>;
  definition?: InputMaybe<Scalars['String']['input']>;
  englishWords?: InputMaybe<WordnetEnglishWordsArrRelInsertInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  pos?: InputMaybe<Scalars['String']['input']>;
  synset_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type WordnetSynsetsMaxFields = {
  __typename?: 'wordnet_synsets_max_fields';
  antonym?: Maybe<Scalars['String']['output']>;
  definition?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  pos?: Maybe<Scalars['String']['output']>;
  synset_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type WordnetSynsetsMinFields = {
  __typename?: 'wordnet_synsets_min_fields';
  antonym?: Maybe<Scalars['String']['output']>;
  definition?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  pos?: Maybe<Scalars['String']['output']>;
  synset_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "wordnet.synsets" */
export type WordnetSynsetsMutationResponse = {
  __typename?: 'wordnet_synsets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<WordnetSynsets>;
};

/** input type for inserting object relation for remote table "wordnet.synsets" */
export type WordnetSynsetsObjRelInsertInput = {
  data: WordnetSynsetsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<WordnetSynsetsOnConflict>;
};

/** on_conflict condition type for table "wordnet.synsets" */
export type WordnetSynsetsOnConflict = {
  constraint: WordnetSynsetsConstraint;
  update_columns?: Array<WordnetSynsetsUpdateColumn>;
  where?: InputMaybe<WordnetSynsetsBoolExp>;
};

/** Ordering options when selecting data from "wordnet.synsets". */
export type WordnetSynsetsOrderBy = {
  antonym?: InputMaybe<OrderBy>;
  definition?: InputMaybe<OrderBy>;
  englishWords_aggregate?: InputMaybe<WordnetEnglishWordsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  pos?: InputMaybe<OrderBy>;
  synset_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: wordnet.synsets */
export type WordnetSynsetsPkColumnsInput = {
  id: Scalars['Int']['input'];
};

/** select columns of table "wordnet.synsets" */
export enum WordnetSynsetsSelectColumn {
  /** column name */
  Antonym = 'antonym',
  /** column name */
  Definition = 'definition',
  /** column name */
  Id = 'id',
  /** column name */
  Pos = 'pos',
  /** column name */
  SynsetId = 'synset_id'
}

/** input type for updating data in table "wordnet.synsets" */
export type WordnetSynsetsSetInput = {
  antonym?: InputMaybe<Scalars['String']['input']>;
  definition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  pos?: InputMaybe<Scalars['String']['input']>;
  synset_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type WordnetSynsetsStddevFields = {
  __typename?: 'wordnet_synsets_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type WordnetSynsetsStddevPopFields = {
  __typename?: 'wordnet_synsets_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type WordnetSynsetsStddevSampFields = {
  __typename?: 'wordnet_synsets_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "wordnet_synsets" */
export type WordnetSynsetsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: WordnetSynsetsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type WordnetSynsetsStreamCursorValueInput = {
  antonym?: InputMaybe<Scalars['String']['input']>;
  definition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  pos?: InputMaybe<Scalars['String']['input']>;
  synset_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type WordnetSynsetsSumFields = {
  __typename?: 'wordnet_synsets_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "wordnet.synsets" */
export enum WordnetSynsetsUpdateColumn {
  /** column name */
  Antonym = 'antonym',
  /** column name */
  Definition = 'definition',
  /** column name */
  Id = 'id',
  /** column name */
  Pos = 'pos',
  /** column name */
  SynsetId = 'synset_id'
}

export type WordnetSynsetsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<WordnetSynsetsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<WordnetSynsetsSetInput>;
  /** filter the rows which have to be updated */
  where: WordnetSynsetsBoolExp;
};

/** aggregate var_pop on columns */
export type WordnetSynsetsVarPopFields = {
  __typename?: 'wordnet_synsets_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type WordnetSynsetsVarSampFields = {
  __typename?: 'wordnet_synsets_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type WordnetSynsetsVarianceFields = {
  __typename?: 'wordnet_synsets_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

export type ListeningFieldsOnActivityFragment = { __typename: 'listenings', id: number, instructions: string, audioKey: string, videoKey?: string | null, transcriptKey?: string | null };

export type ReadingFieldsOnActivityFragment = { __typename: 'readings', id: number, contentKey?: string | null, updatedAt: any, translationKey?: string | null };

export type VocabularyWordFieldsOnActivityFragment = { __typename: 'vocabulary_words', id: number, word: string, vocabularySetId?: number | null, example?: string | null, exampleTranslation?: string | null, wordLanguage?: number | null, examplePronunciation?: string | null, definitionLanguage?: number | null, order: number, definitionPronunciation?: string | null, pos?: PartsOfSpeechEnum | null, pronunciation?: string | null, definition: string, imageId?: number | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null };

export type VocabularyFieldsOnActivityFragment = { __typename: 'vocabulary_sets', id: number, createdAt: any, updatedAt: any, activitySetId?: number | null, vocabularyWords: Array<{ __typename: 'vocabulary_words', id: number, word: string, vocabularySetId?: number | null, example?: string | null, exampleTranslation?: string | null, wordLanguage?: number | null, examplePronunciation?: string | null, definitionLanguage?: number | null, order: number, definitionPronunciation?: string | null, pos?: PartsOfSpeechEnum | null, pronunciation?: string | null, definition: string, imageId?: number | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null }>, activitySet?: { __typename: 'activity_sets', id: number, title: string, description: string, subjectId: number } | null };

export type FitbFieldsOnActivityFragment = { __typename: 'fill_in_the_blanks', id: number, order: number, baseSentence: string, hint: string, translation?: string | null, explanation?: string | null, omission: string, audioUrl?: string | null, options: Array<{ __typename?: 'fill_in_the_blank_options', id: number, option: string }> };

export type MatchingFieldsOnActivityFragment = { __typename: 'matchings', id: number, order: number, matchingOptions: Array<{ __typename: 'matching_options', id: number, firstColumn: string, secondColumn: string }> };

export type MultipleChoiceFieldsOnActivityFragment = { __typename: 'multiple_choices', id: number, order: number, imageId?: number | null, isMultiSelect: boolean, prompt: string, explanation?: string | null, audioUrl?: string | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, multipleChoiceOptions: Array<{ __typename?: 'multiple_choice_options', id: number, isCorrectAnswer: boolean, option: string }> };

export type AnagramFieldsOnActivityFragment = { __typename: 'anagrams', id: number, order: number, imageId?: number | null, audio?: string | null, word: string, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null };

export type PhraseFieldsOnActivityFragment = { __typename: 'phrases', id: number, order: number, phrase: string, translation?: string | null, pronunciation?: string | null, isPronunciation?: boolean | null };

export type OpenAnswerFieldsOnActivityFragment = { __typename: 'open_answers', id: number, order: number, isSpellcheckEnabled: boolean, prompt: string, wordLimit: number };

export type ActivitySetBasicInfoFieldsFragment = { __typename: 'activity_sets', id: number, title: string, forkedFrom?: number | null, learnerLanguage?: number | null, description: string, level: CefrLevelsEnum, imageId?: number | null, subjectId: number, isPrivate: boolean, createdBy: number, createdAt: any, deletedAt?: any | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, subject: { __typename?: 'subjects', id: number, language?: { __typename?: 'languages', id: number, key: string } | null }, user: { __typename?: 'users', id: number, firstName: string, image?: string | null } };

export type ActivitySetFieldsFragment = { __typename: 'activity_sets', readingId?: number | null, listeningId?: number | null, vocabularyId?: number | null, id: number, title: string, forkedFrom?: number | null, learnerLanguage?: number | null, description: string, level: CefrLevelsEnum, imageId?: number | null, subjectId: number, isPrivate: boolean, createdBy: number, createdAt: any, deletedAt?: any | null, reading?: { __typename: 'readings', id: number, contentKey?: string | null, updatedAt: any, translationKey?: string | null } | null, listening?: { __typename: 'listenings', id: number, instructions: string, audioKey: string, videoKey?: string | null, transcriptKey?: string | null } | null, vocabularySet?: { __typename: 'vocabulary_sets', id: number, createdAt: any, updatedAt: any, activitySetId?: number | null, vocabularyWords: Array<{ __typename: 'vocabulary_words', id: number, word: string, vocabularySetId?: number | null, example?: string | null, exampleTranslation?: string | null, wordLanguage?: number | null, examplePronunciation?: string | null, definitionLanguage?: number | null, order: number, definitionPronunciation?: string | null, pos?: PartsOfSpeechEnum | null, pronunciation?: string | null, definition: string, imageId?: number | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null }>, activitySet?: { __typename: 'activity_sets', id: number, title: string, description: string, subjectId: number } | null } | null, anagrams: Array<{ __typename: 'anagrams', id: number, order: number, imageId?: number | null, audio?: string | null, word: string, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null }>, phrases: Array<{ __typename: 'phrases', id: number, order: number, phrase: string, translation?: string | null, pronunciation?: string | null, isPronunciation?: boolean | null }>, matchings: Array<{ __typename: 'matchings', id: number, order: number, matchingOptions: Array<{ __typename: 'matching_options', id: number, firstColumn: string, secondColumn: string }> }>, fillInTheBlanks: Array<{ __typename: 'fill_in_the_blanks', id: number, order: number, baseSentence: string, hint: string, translation?: string | null, explanation?: string | null, omission: string, audioUrl?: string | null, options: Array<{ __typename?: 'fill_in_the_blank_options', id: number, option: string }> }>, multipleChoices: Array<{ __typename: 'multiple_choices', id: number, order: number, imageId?: number | null, isMultiSelect: boolean, prompt: string, explanation?: string | null, audioUrl?: string | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, multipleChoiceOptions: Array<{ __typename?: 'multiple_choice_options', id: number, isCorrectAnswer: boolean, option: string }> }>, openAnswers: Array<{ __typename: 'open_answers', id: number, order: number, isSpellcheckEnabled: boolean, prompt: string, wordLimit: number }>, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, subject: { __typename?: 'subjects', id: number, language?: { __typename?: 'languages', id: number, key: string } | null }, user: { __typename?: 'users', id: number, firstName: string, image?: string | null } };

export type ActivitySearchFieldsFragment = { __typename: 'activity_sets', id: number, readingId?: number | null, vocabularyId?: number | null, listeningId?: number | null, createdAt: any, subjectId: number, isPrivate: boolean, description: string, title: string, level: CefrLevelsEnum, imageId?: number | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, anAgg: { __typename?: 'anagrams_aggregate', aggregate?: { __typename?: 'anagrams_aggregate_fields', count: number } | null }, fitbAgg: { __typename?: 'fill_in_the_blanks_aggregate', aggregate?: { __typename?: 'fill_in_the_blanks_aggregate_fields', count: number } | null }, oaAgg: { __typename?: 'open_answers_aggregate', aggregate?: { __typename?: 'open_answers_aggregate_fields', count: number } | null }, matchAgg: { __typename?: 'matchings_aggregate', aggregate?: { __typename?: 'matchings_aggregate_fields', count: number } | null }, mcAgg: { __typename?: 'multiple_choices_aggregate', aggregate?: { __typename?: 'multiple_choices_aggregate_fields', count: number } | null } };

export type GetActivitySetReadingIdQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type GetActivitySetReadingIdQuery = { __typename?: 'query_root', activitySet?: { __typename?: 'activity_sets', id: number, title: string, readingId?: number | null, listeningId?: number | null, listening?: { __typename?: 'listenings', id: number, audioKey: string, transcriptKey?: string | null } | null } | null };

export type GetActivitySetBasicInfoQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type GetActivitySetBasicInfoQuery = { __typename?: 'query_root', activitySet?: { __typename: 'activity_sets', id: number, title: string, forkedFrom?: number | null, learnerLanguage?: number | null, description: string, level: CefrLevelsEnum, imageId?: number | null, subjectId: number, isPrivate: boolean, createdBy: number, createdAt: any, deletedAt?: any | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, subject: { __typename?: 'subjects', id: number, language?: { __typename?: 'languages', id: number, key: string } | null }, user: { __typename?: 'users', id: number, firstName: string, image?: string | null } } | null };

export type GetActivitySetsQueryVariables = Exact<{
  where?: InputMaybe<ActivitySetsBoolExp>;
  orderBy?: InputMaybe<Array<ActivitySetsOrderBy> | ActivitySetsOrderBy>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetActivitySetsQuery = { __typename?: 'query_root', activitySets: Array<{ __typename: 'activity_sets', readingId?: number | null, listeningId?: number | null, vocabularyId?: number | null, id: number, title: string, forkedFrom?: number | null, learnerLanguage?: number | null, description: string, level: CefrLevelsEnum, imageId?: number | null, subjectId: number, isPrivate: boolean, createdBy: number, createdAt: any, deletedAt?: any | null, reading?: { __typename: 'readings', id: number, contentKey?: string | null, updatedAt: any, translationKey?: string | null } | null, listening?: { __typename: 'listenings', id: number, instructions: string, audioKey: string, videoKey?: string | null, transcriptKey?: string | null } | null, vocabularySet?: { __typename: 'vocabulary_sets', id: number, createdAt: any, updatedAt: any, activitySetId?: number | null, vocabularyWords: Array<{ __typename: 'vocabulary_words', id: number, word: string, vocabularySetId?: number | null, example?: string | null, exampleTranslation?: string | null, wordLanguage?: number | null, examplePronunciation?: string | null, definitionLanguage?: number | null, order: number, definitionPronunciation?: string | null, pos?: PartsOfSpeechEnum | null, pronunciation?: string | null, definition: string, imageId?: number | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null }>, activitySet?: { __typename: 'activity_sets', id: number, title: string, description: string, subjectId: number } | null } | null, anagrams: Array<{ __typename: 'anagrams', id: number, order: number, imageId?: number | null, audio?: string | null, word: string, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null }>, phrases: Array<{ __typename: 'phrases', id: number, order: number, phrase: string, translation?: string | null, pronunciation?: string | null, isPronunciation?: boolean | null }>, matchings: Array<{ __typename: 'matchings', id: number, order: number, matchingOptions: Array<{ __typename: 'matching_options', id: number, firstColumn: string, secondColumn: string }> }>, fillInTheBlanks: Array<{ __typename: 'fill_in_the_blanks', id: number, order: number, baseSentence: string, hint: string, translation?: string | null, explanation?: string | null, omission: string, audioUrl?: string | null, options: Array<{ __typename?: 'fill_in_the_blank_options', id: number, option: string }> }>, multipleChoices: Array<{ __typename: 'multiple_choices', id: number, order: number, imageId?: number | null, isMultiSelect: boolean, prompt: string, explanation?: string | null, audioUrl?: string | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, multipleChoiceOptions: Array<{ __typename?: 'multiple_choice_options', id: number, isCorrectAnswer: boolean, option: string }> }>, openAnswers: Array<{ __typename: 'open_answers', id: number, order: number, isSpellcheckEnabled: boolean, prompt: string, wordLimit: number }>, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, subject: { __typename?: 'subjects', id: number, language?: { __typename?: 'languages', id: number, key: string } | null }, user: { __typename?: 'users', id: number, firstName: string, image?: string | null } }> };

export type GetActivitySetTitlesQueryVariables = Exact<{
  where?: InputMaybe<ActivitySetsBoolExp>;
}>;


export type GetActivitySetTitlesQuery = { __typename?: 'query_root', activitySets: Array<{ __typename?: 'activity_sets', id: number, title: string }> };

export type GetActivitySetsSearchQueryVariables = Exact<{
  where?: InputMaybe<ActivitySetsBoolExp>;
  orderBy?: InputMaybe<Array<ActivitySetsOrderBy> | ActivitySetsOrderBy>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetActivitySetsSearchQuery = { __typename?: 'query_root', activitySets: Array<{ __typename: 'activity_sets', id: number, readingId?: number | null, vocabularyId?: number | null, listeningId?: number | null, createdAt: any, subjectId: number, isPrivate: boolean, description: string, title: string, level: CefrLevelsEnum, imageId?: number | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, anAgg: { __typename?: 'anagrams_aggregate', aggregate?: { __typename?: 'anagrams_aggregate_fields', count: number } | null }, fitbAgg: { __typename?: 'fill_in_the_blanks_aggregate', aggregate?: { __typename?: 'fill_in_the_blanks_aggregate_fields', count: number } | null }, oaAgg: { __typename?: 'open_answers_aggregate', aggregate?: { __typename?: 'open_answers_aggregate_fields', count: number } | null }, matchAgg: { __typename?: 'matchings_aggregate', aggregate?: { __typename?: 'matchings_aggregate_fields', count: number } | null }, mcAgg: { __typename?: 'multiple_choices_aggregate', aggregate?: { __typename?: 'multiple_choices_aggregate_fields', count: number } | null } }>, agg: { __typename?: 'activity_sets_aggregate', aggregate?: { __typename?: 'activity_sets_aggregate_fields', count: number } | null } };

export type GetActivitySetByPkQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type GetActivitySetByPkQuery = { __typename?: 'query_root', activitySet?: { __typename: 'activity_sets', readingId?: number | null, listeningId?: number | null, vocabularyId?: number | null, id: number, title: string, forkedFrom?: number | null, learnerLanguage?: number | null, description: string, level: CefrLevelsEnum, imageId?: number | null, subjectId: number, isPrivate: boolean, createdBy: number, createdAt: any, deletedAt?: any | null, reading?: { __typename: 'readings', id: number, contentKey?: string | null, updatedAt: any, translationKey?: string | null } | null, listening?: { __typename: 'listenings', id: number, instructions: string, audioKey: string, videoKey?: string | null, transcriptKey?: string | null } | null, vocabularySet?: { __typename: 'vocabulary_sets', id: number, createdAt: any, updatedAt: any, activitySetId?: number | null, vocabularyWords: Array<{ __typename: 'vocabulary_words', id: number, word: string, vocabularySetId?: number | null, example?: string | null, exampleTranslation?: string | null, wordLanguage?: number | null, examplePronunciation?: string | null, definitionLanguage?: number | null, order: number, definitionPronunciation?: string | null, pos?: PartsOfSpeechEnum | null, pronunciation?: string | null, definition: string, imageId?: number | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null }>, activitySet?: { __typename: 'activity_sets', id: number, title: string, description: string, subjectId: number } | null } | null, anagrams: Array<{ __typename: 'anagrams', id: number, order: number, imageId?: number | null, audio?: string | null, word: string, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null }>, phrases: Array<{ __typename: 'phrases', id: number, order: number, phrase: string, translation?: string | null, pronunciation?: string | null, isPronunciation?: boolean | null }>, matchings: Array<{ __typename: 'matchings', id: number, order: number, matchingOptions: Array<{ __typename: 'matching_options', id: number, firstColumn: string, secondColumn: string }> }>, fillInTheBlanks: Array<{ __typename: 'fill_in_the_blanks', id: number, order: number, baseSentence: string, hint: string, translation?: string | null, explanation?: string | null, omission: string, audioUrl?: string | null, options: Array<{ __typename?: 'fill_in_the_blank_options', id: number, option: string }> }>, multipleChoices: Array<{ __typename: 'multiple_choices', id: number, order: number, imageId?: number | null, isMultiSelect: boolean, prompt: string, explanation?: string | null, audioUrl?: string | null, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, multipleChoiceOptions: Array<{ __typename?: 'multiple_choice_options', id: number, isCorrectAnswer: boolean, option: string }> }>, openAnswers: Array<{ __typename: 'open_answers', id: number, order: number, isSpellcheckEnabled: boolean, prompt: string, wordLimit: number }>, image?: { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null } | null, subject: { __typename?: 'subjects', id: number, language?: { __typename?: 'languages', id: number, key: string } | null }, user: { __typename?: 'users', id: number, firstName: string, image?: string | null } } | null };

export type CreateActivitySetMutationVariables = Exact<{
  object: ActivitySetsInsertInput;
  onConflict?: InputMaybe<ActivitySetsOnConflict>;
}>;


export type CreateActivitySetMutation = { __typename?: 'mutation_root', activitySet?: { __typename?: 'activity_sets', id: number, vocabularyId?: number | null, readingId?: number | null, listeningId?: number | null, vocabularySet?: { __typename: 'vocabulary_sets', id: number, vocabularyWords: Array<{ __typename: 'vocabulary_words', id: number, word: string }> } | null } | null };

export type CreateActivitySetsMutationVariables = Exact<{
  objects: Array<ActivitySetsInsertInput> | ActivitySetsInsertInput;
  onConflict?: InputMaybe<ActivitySetsOnConflict>;
}>;


export type CreateActivitySetsMutation = { __typename?: 'mutation_root', activitySets?: { __typename?: 'activity_sets_mutation_response', returning: Array<{ __typename: 'activity_sets', id: number, reading?: { __typename: 'readings', id: number } | null }> } | null };

export type DeleteActivitySetMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteActivitySetMutation = { __typename?: 'mutation_root', activitySet?: { __typename?: 'activity_sets', id: number } | null };

export type UpdateActivitySetMutationVariables = Exact<{
  pkColumns: ActivitySetsPkColumnsInput;
  set?: InputMaybe<ActivitySetsSetInput>;
}>;


export type UpdateActivitySetMutation = { __typename?: 'mutation_root', activitySet?: { __typename?: 'activity_sets', id: number } | null };

export type UpdateManyActivitySetsMutationVariables = Exact<{
  updates: Array<ActivitySetsUpdates> | ActivitySetsUpdates;
}>;


export type UpdateManyActivitySetsMutation = { __typename?: 'mutation_root', activitySets?: Array<{ __typename?: 'activity_sets_mutation_response', returning: Array<{ __typename?: 'activity_sets', id: number }> } | null> | null };

export type CreateImageMutationVariables = Exact<{
  object: ImagesInsertInput;
  onConflict?: InputMaybe<ImagesOnConflict>;
}>;


export type CreateImageMutation = { __typename?: 'mutation_root', image?: { __typename?: 'images', id: number } | null };

export type ImageFieldsFragment = { __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null };

export type GetImagesQueryVariables = Exact<{
  where: ImagesBoolExp;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetImagesQuery = { __typename?: 'query_root', images: Array<{ __typename: 'images', id: number, imageUrl: string, photographerName: string, photographerUrl: string, height: number, width: number, synset?: string | null }> };

export const ImageFieldsFragmentDoc = gql`
    fragment ImageFields on images {
  id
  __typename
  imageUrl
  photographerName
  photographerUrl
  height
  width
  synset
}
    `;
export const ActivitySetBasicInfoFieldsFragmentDoc = gql`
    fragment ActivitySetBasicInfoFields on activity_sets {
  id
  __typename
  title
  forkedFrom
  learnerLanguage
  description
  level
  imageId
  image {
    ...ImageFields
  }
  subjectId
  subject {
    id
    language {
      id
      key
    }
  }
  isPrivate
  createdBy
  createdAt
  deletedAt
  user {
    id
    firstName
    image
  }
}
    ${ImageFieldsFragmentDoc}`;
export const ReadingFieldsOnActivityFragmentDoc = gql`
    fragment ReadingFieldsOnActivity on readings {
  __typename
  id
  contentKey
  updatedAt
  translationKey
}
    `;
export const ListeningFieldsOnActivityFragmentDoc = gql`
    fragment ListeningFieldsOnActivity on listenings {
  __typename
  id
  instructions
  audioKey
  videoKey
  transcriptKey
}
    `;
export const VocabularyWordFieldsOnActivityFragmentDoc = gql`
    fragment VocabularyWordFieldsOnActivity on vocabulary_words {
  __typename
  id
  word
  vocabularySetId
  example
  exampleTranslation
  wordLanguage
  examplePronunciation
  definitionLanguage
  order
  definitionPronunciation
  pos
  pronunciation
  definition
  imageId
  image {
    ...ImageFields
  }
}
    ${ImageFieldsFragmentDoc}`;
export const VocabularyFieldsOnActivityFragmentDoc = gql`
    fragment VocabularyFieldsOnActivity on vocabulary_sets {
  __typename
  id
  vocabularyWords {
    ...VocabularyWordFieldsOnActivity
  }
  createdAt
  updatedAt
  activitySetId
  activitySet {
    __typename
    id
    title
    description
    subjectId
  }
}
    ${VocabularyWordFieldsOnActivityFragmentDoc}`;
export const AnagramFieldsOnActivityFragmentDoc = gql`
    fragment AnagramFieldsOnActivity on anagrams {
  id
  __typename
  order
  imageId
  image {
    ...ImageFields
  }
  audio
  word
}
    ${ImageFieldsFragmentDoc}`;
export const PhraseFieldsOnActivityFragmentDoc = gql`
    fragment PhraseFieldsOnActivity on phrases {
  id
  __typename
  order
  phrase
  translation
  pronunciation
  isPronunciation
}
    `;
export const MatchingFieldsOnActivityFragmentDoc = gql`
    fragment MatchingFieldsOnActivity on matchings {
  id
  __typename
  order
  matchingOptions {
    id
    __typename
    firstColumn
    secondColumn
  }
}
    `;
export const FitbFieldsOnActivityFragmentDoc = gql`
    fragment FitbFieldsOnActivity on fill_in_the_blanks {
  id
  __typename
  order
  baseSentence
  hint
  translation
  explanation
  omission
  audioUrl
  options {
    id
    option
  }
}
    `;
export const MultipleChoiceFieldsOnActivityFragmentDoc = gql`
    fragment MultipleChoiceFieldsOnActivity on multiple_choices {
  id
  __typename
  order
  imageId
  image {
    ...ImageFields
  }
  isMultiSelect
  prompt
  explanation
  audioUrl
  multipleChoiceOptions {
    id
    isCorrectAnswer
    option
  }
}
    ${ImageFieldsFragmentDoc}`;
export const OpenAnswerFieldsOnActivityFragmentDoc = gql`
    fragment OpenAnswerFieldsOnActivity on open_answers {
  id
  __typename
  order
  isSpellcheckEnabled
  prompt
  wordLimit
}
    `;
export const ActivitySetFieldsFragmentDoc = gql`
    fragment ActivitySetFields on activity_sets {
  ...ActivitySetBasicInfoFields
  readingId
  reading {
    ...ReadingFieldsOnActivity
  }
  listeningId
  listening {
    ...ListeningFieldsOnActivity
  }
  vocabularyId
  vocabularySet {
    ...VocabularyFieldsOnActivity
  }
  anagrams {
    ...AnagramFieldsOnActivity
  }
  phrases {
    ...PhraseFieldsOnActivity
  }
  matchings {
    ...MatchingFieldsOnActivity
  }
  fillInTheBlanks {
    ...FitbFieldsOnActivity
  }
  multipleChoices {
    ...MultipleChoiceFieldsOnActivity
  }
  openAnswers {
    ...OpenAnswerFieldsOnActivity
  }
}
    ${ActivitySetBasicInfoFieldsFragmentDoc}
${ReadingFieldsOnActivityFragmentDoc}
${ListeningFieldsOnActivityFragmentDoc}
${VocabularyFieldsOnActivityFragmentDoc}
${AnagramFieldsOnActivityFragmentDoc}
${PhraseFieldsOnActivityFragmentDoc}
${MatchingFieldsOnActivityFragmentDoc}
${FitbFieldsOnActivityFragmentDoc}
${MultipleChoiceFieldsOnActivityFragmentDoc}
${OpenAnswerFieldsOnActivityFragmentDoc}`;
export const ActivitySearchFieldsFragmentDoc = gql`
    fragment ActivitySearchFields on activity_sets {
  id
  __typename
  readingId
  vocabularyId
  listeningId
  createdAt
  subjectId
  isPrivate
  description
  title
  level
  imageId
  image {
    ...ImageFields
  }
  anAgg: anagrams_aggregate {
    aggregate {
      count
    }
  }
  fitbAgg: fillInTheBlanks_aggregate {
    aggregate {
      count
    }
  }
  oaAgg: openAnswers_aggregate {
    aggregate {
      count
    }
  }
  matchAgg: matchings_aggregate {
    aggregate {
      count
    }
  }
  mcAgg: multipleChoices_aggregate {
    aggregate {
      count
    }
  }
}
    ${ImageFieldsFragmentDoc}`;
export const GetActivitySetReadingIdDocument = gql`
    query GetActivitySetReadingId($id: Int!) {
  activitySet: activity_sets_by_pk(id: $id) {
    id
    title
    readingId
    listeningId
    listening {
      id
      audioKey
      transcriptKey
    }
  }
}
    `;

/**
 * __useGetActivitySetReadingIdQuery__
 *
 * To run a query within a React component, call `useGetActivitySetReadingIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActivitySetReadingIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActivitySetReadingIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetActivitySetReadingIdQuery(baseOptions: Apollo.QueryHookOptions<GetActivitySetReadingIdQuery, GetActivitySetReadingIdQueryVariables> & ({ variables: GetActivitySetReadingIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActivitySetReadingIdQuery, GetActivitySetReadingIdQueryVariables>(GetActivitySetReadingIdDocument, options);
      }
export function useGetActivitySetReadingIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActivitySetReadingIdQuery, GetActivitySetReadingIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActivitySetReadingIdQuery, GetActivitySetReadingIdQueryVariables>(GetActivitySetReadingIdDocument, options);
        }
export function useGetActivitySetReadingIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetActivitySetReadingIdQuery, GetActivitySetReadingIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetActivitySetReadingIdQuery, GetActivitySetReadingIdQueryVariables>(GetActivitySetReadingIdDocument, options);
        }
export type GetActivitySetReadingIdQueryHookResult = ReturnType<typeof useGetActivitySetReadingIdQuery>;
export type GetActivitySetReadingIdLazyQueryHookResult = ReturnType<typeof useGetActivitySetReadingIdLazyQuery>;
export type GetActivitySetReadingIdSuspenseQueryHookResult = ReturnType<typeof useGetActivitySetReadingIdSuspenseQuery>;
export type GetActivitySetReadingIdQueryResult = Apollo.QueryResult<GetActivitySetReadingIdQuery, GetActivitySetReadingIdQueryVariables>;
export const GetActivitySetBasicInfoDocument = gql`
    query GetActivitySetBasicInfo($id: Int!) {
  activitySet: activity_sets_by_pk(id: $id) {
    ...ActivitySetBasicInfoFields
  }
}
    ${ActivitySetBasicInfoFieldsFragmentDoc}`;

/**
 * __useGetActivitySetBasicInfoQuery__
 *
 * To run a query within a React component, call `useGetActivitySetBasicInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActivitySetBasicInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActivitySetBasicInfoQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetActivitySetBasicInfoQuery(baseOptions: Apollo.QueryHookOptions<GetActivitySetBasicInfoQuery, GetActivitySetBasicInfoQueryVariables> & ({ variables: GetActivitySetBasicInfoQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActivitySetBasicInfoQuery, GetActivitySetBasicInfoQueryVariables>(GetActivitySetBasicInfoDocument, options);
      }
export function useGetActivitySetBasicInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActivitySetBasicInfoQuery, GetActivitySetBasicInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActivitySetBasicInfoQuery, GetActivitySetBasicInfoQueryVariables>(GetActivitySetBasicInfoDocument, options);
        }
export function useGetActivitySetBasicInfoSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetActivitySetBasicInfoQuery, GetActivitySetBasicInfoQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetActivitySetBasicInfoQuery, GetActivitySetBasicInfoQueryVariables>(GetActivitySetBasicInfoDocument, options);
        }
export type GetActivitySetBasicInfoQueryHookResult = ReturnType<typeof useGetActivitySetBasicInfoQuery>;
export type GetActivitySetBasicInfoLazyQueryHookResult = ReturnType<typeof useGetActivitySetBasicInfoLazyQuery>;
export type GetActivitySetBasicInfoSuspenseQueryHookResult = ReturnType<typeof useGetActivitySetBasicInfoSuspenseQuery>;
export type GetActivitySetBasicInfoQueryResult = Apollo.QueryResult<GetActivitySetBasicInfoQuery, GetActivitySetBasicInfoQueryVariables>;
export const GetActivitySetsDocument = gql`
    query GetActivitySets($where: activity_sets_bool_exp, $orderBy: [activity_sets_order_by!], $limit: Int, $offset: Int) {
  activitySets: activity_sets(
    where: $where
    limit: $limit
    offset: $offset
    order_by: $orderBy
  ) {
    ...ActivitySetFields
  }
}
    ${ActivitySetFieldsFragmentDoc}`;

/**
 * __useGetActivitySetsQuery__
 *
 * To run a query within a React component, call `useGetActivitySetsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActivitySetsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActivitySetsQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetActivitySetsQuery(baseOptions?: Apollo.QueryHookOptions<GetActivitySetsQuery, GetActivitySetsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActivitySetsQuery, GetActivitySetsQueryVariables>(GetActivitySetsDocument, options);
      }
export function useGetActivitySetsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActivitySetsQuery, GetActivitySetsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActivitySetsQuery, GetActivitySetsQueryVariables>(GetActivitySetsDocument, options);
        }
export function useGetActivitySetsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetActivitySetsQuery, GetActivitySetsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetActivitySetsQuery, GetActivitySetsQueryVariables>(GetActivitySetsDocument, options);
        }
export type GetActivitySetsQueryHookResult = ReturnType<typeof useGetActivitySetsQuery>;
export type GetActivitySetsLazyQueryHookResult = ReturnType<typeof useGetActivitySetsLazyQuery>;
export type GetActivitySetsSuspenseQueryHookResult = ReturnType<typeof useGetActivitySetsSuspenseQuery>;
export type GetActivitySetsQueryResult = Apollo.QueryResult<GetActivitySetsQuery, GetActivitySetsQueryVariables>;
export const GetActivitySetTitlesDocument = gql`
    query GetActivitySetTitles($where: activity_sets_bool_exp) {
  activitySets: activity_sets(where: $where) {
    id
    title
  }
}
    `;

/**
 * __useGetActivitySetTitlesQuery__
 *
 * To run a query within a React component, call `useGetActivitySetTitlesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActivitySetTitlesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActivitySetTitlesQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGetActivitySetTitlesQuery(baseOptions?: Apollo.QueryHookOptions<GetActivitySetTitlesQuery, GetActivitySetTitlesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActivitySetTitlesQuery, GetActivitySetTitlesQueryVariables>(GetActivitySetTitlesDocument, options);
      }
export function useGetActivitySetTitlesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActivitySetTitlesQuery, GetActivitySetTitlesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActivitySetTitlesQuery, GetActivitySetTitlesQueryVariables>(GetActivitySetTitlesDocument, options);
        }
export function useGetActivitySetTitlesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetActivitySetTitlesQuery, GetActivitySetTitlesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetActivitySetTitlesQuery, GetActivitySetTitlesQueryVariables>(GetActivitySetTitlesDocument, options);
        }
export type GetActivitySetTitlesQueryHookResult = ReturnType<typeof useGetActivitySetTitlesQuery>;
export type GetActivitySetTitlesLazyQueryHookResult = ReturnType<typeof useGetActivitySetTitlesLazyQuery>;
export type GetActivitySetTitlesSuspenseQueryHookResult = ReturnType<typeof useGetActivitySetTitlesSuspenseQuery>;
export type GetActivitySetTitlesQueryResult = Apollo.QueryResult<GetActivitySetTitlesQuery, GetActivitySetTitlesQueryVariables>;
export const GetActivitySetsSearchDocument = gql`
    query GetActivitySetsSearch($where: activity_sets_bool_exp, $orderBy: [activity_sets_order_by!], $limit: Int, $offset: Int) {
  activitySets: activity_sets(
    where: $where
    limit: $limit
    offset: $offset
    order_by: $orderBy
  ) {
    ...ActivitySearchFields
  }
  agg: activity_sets_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    ${ActivitySearchFieldsFragmentDoc}`;

/**
 * __useGetActivitySetsSearchQuery__
 *
 * To run a query within a React component, call `useGetActivitySetsSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActivitySetsSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActivitySetsSearchQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetActivitySetsSearchQuery(baseOptions?: Apollo.QueryHookOptions<GetActivitySetsSearchQuery, GetActivitySetsSearchQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActivitySetsSearchQuery, GetActivitySetsSearchQueryVariables>(GetActivitySetsSearchDocument, options);
      }
export function useGetActivitySetsSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActivitySetsSearchQuery, GetActivitySetsSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActivitySetsSearchQuery, GetActivitySetsSearchQueryVariables>(GetActivitySetsSearchDocument, options);
        }
export function useGetActivitySetsSearchSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetActivitySetsSearchQuery, GetActivitySetsSearchQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetActivitySetsSearchQuery, GetActivitySetsSearchQueryVariables>(GetActivitySetsSearchDocument, options);
        }
export type GetActivitySetsSearchQueryHookResult = ReturnType<typeof useGetActivitySetsSearchQuery>;
export type GetActivitySetsSearchLazyQueryHookResult = ReturnType<typeof useGetActivitySetsSearchLazyQuery>;
export type GetActivitySetsSearchSuspenseQueryHookResult = ReturnType<typeof useGetActivitySetsSearchSuspenseQuery>;
export type GetActivitySetsSearchQueryResult = Apollo.QueryResult<GetActivitySetsSearchQuery, GetActivitySetsSearchQueryVariables>;
export const GetActivitySetByPkDocument = gql`
    query GetActivitySetByPk($id: Int!) {
  activitySet: activity_sets_by_pk(id: $id) {
    ...ActivitySetFields
  }
}
    ${ActivitySetFieldsFragmentDoc}`;

/**
 * __useGetActivitySetByPkQuery__
 *
 * To run a query within a React component, call `useGetActivitySetByPkQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActivitySetByPkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActivitySetByPkQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetActivitySetByPkQuery(baseOptions: Apollo.QueryHookOptions<GetActivitySetByPkQuery, GetActivitySetByPkQueryVariables> & ({ variables: GetActivitySetByPkQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActivitySetByPkQuery, GetActivitySetByPkQueryVariables>(GetActivitySetByPkDocument, options);
      }
export function useGetActivitySetByPkLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActivitySetByPkQuery, GetActivitySetByPkQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActivitySetByPkQuery, GetActivitySetByPkQueryVariables>(GetActivitySetByPkDocument, options);
        }
export function useGetActivitySetByPkSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetActivitySetByPkQuery, GetActivitySetByPkQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetActivitySetByPkQuery, GetActivitySetByPkQueryVariables>(GetActivitySetByPkDocument, options);
        }
export type GetActivitySetByPkQueryHookResult = ReturnType<typeof useGetActivitySetByPkQuery>;
export type GetActivitySetByPkLazyQueryHookResult = ReturnType<typeof useGetActivitySetByPkLazyQuery>;
export type GetActivitySetByPkSuspenseQueryHookResult = ReturnType<typeof useGetActivitySetByPkSuspenseQuery>;
export type GetActivitySetByPkQueryResult = Apollo.QueryResult<GetActivitySetByPkQuery, GetActivitySetByPkQueryVariables>;
export const CreateActivitySetDocument = gql`
    mutation CreateActivitySet($object: activity_sets_insert_input!, $onConflict: activity_sets_on_conflict) {
  activitySet: insert_activity_sets_one(object: $object, on_conflict: $onConflict) {
    id
    vocabularyId
    readingId
    listeningId
    vocabularySet {
      id
      __typename
      vocabularyWords {
        id
        __typename
        word
      }
    }
  }
}
    `;
export type CreateActivitySetMutationFn = Apollo.MutationFunction<CreateActivitySetMutation, CreateActivitySetMutationVariables>;

/**
 * __useCreateActivitySetMutation__
 *
 * To run a mutation, you first call `useCreateActivitySetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateActivitySetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createActivitySetMutation, { data, loading, error }] = useCreateActivitySetMutation({
 *   variables: {
 *      object: // value for 'object'
 *      onConflict: // value for 'onConflict'
 *   },
 * });
 */
export function useCreateActivitySetMutation(baseOptions?: Apollo.MutationHookOptions<CreateActivitySetMutation, CreateActivitySetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateActivitySetMutation, CreateActivitySetMutationVariables>(CreateActivitySetDocument, options);
      }
export type CreateActivitySetMutationHookResult = ReturnType<typeof useCreateActivitySetMutation>;
export type CreateActivitySetMutationResult = Apollo.MutationResult<CreateActivitySetMutation>;
export type CreateActivitySetMutationOptions = Apollo.BaseMutationOptions<CreateActivitySetMutation, CreateActivitySetMutationVariables>;
export const CreateActivitySetsDocument = gql`
    mutation CreateActivitySets($objects: [activity_sets_insert_input!]!, $onConflict: activity_sets_on_conflict) {
  activitySets: insert_activity_sets(objects: $objects, on_conflict: $onConflict) {
    returning {
      id
      __typename
      reading {
        __typename
        id
      }
    }
  }
}
    `;
export type CreateActivitySetsMutationFn = Apollo.MutationFunction<CreateActivitySetsMutation, CreateActivitySetsMutationVariables>;

/**
 * __useCreateActivitySetsMutation__
 *
 * To run a mutation, you first call `useCreateActivitySetsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateActivitySetsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createActivitySetsMutation, { data, loading, error }] = useCreateActivitySetsMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *      onConflict: // value for 'onConflict'
 *   },
 * });
 */
export function useCreateActivitySetsMutation(baseOptions?: Apollo.MutationHookOptions<CreateActivitySetsMutation, CreateActivitySetsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateActivitySetsMutation, CreateActivitySetsMutationVariables>(CreateActivitySetsDocument, options);
      }
export type CreateActivitySetsMutationHookResult = ReturnType<typeof useCreateActivitySetsMutation>;
export type CreateActivitySetsMutationResult = Apollo.MutationResult<CreateActivitySetsMutation>;
export type CreateActivitySetsMutationOptions = Apollo.BaseMutationOptions<CreateActivitySetsMutation, CreateActivitySetsMutationVariables>;
export const DeleteActivitySetDocument = gql`
    mutation DeleteActivitySet($id: Int!) {
  activitySet: delete_activity_sets_by_pk(id: $id) {
    id
  }
}
    `;
export type DeleteActivitySetMutationFn = Apollo.MutationFunction<DeleteActivitySetMutation, DeleteActivitySetMutationVariables>;

/**
 * __useDeleteActivitySetMutation__
 *
 * To run a mutation, you first call `useDeleteActivitySetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteActivitySetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteActivitySetMutation, { data, loading, error }] = useDeleteActivitySetMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteActivitySetMutation(baseOptions?: Apollo.MutationHookOptions<DeleteActivitySetMutation, DeleteActivitySetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteActivitySetMutation, DeleteActivitySetMutationVariables>(DeleteActivitySetDocument, options);
      }
export type DeleteActivitySetMutationHookResult = ReturnType<typeof useDeleteActivitySetMutation>;
export type DeleteActivitySetMutationResult = Apollo.MutationResult<DeleteActivitySetMutation>;
export type DeleteActivitySetMutationOptions = Apollo.BaseMutationOptions<DeleteActivitySetMutation, DeleteActivitySetMutationVariables>;
export const UpdateActivitySetDocument = gql`
    mutation UpdateActivitySet($pkColumns: activity_sets_pk_columns_input!, $set: activity_sets_set_input) {
  activitySet: update_activity_sets_by_pk(pk_columns: $pkColumns, _set: $set) {
    id
  }
}
    `;
export type UpdateActivitySetMutationFn = Apollo.MutationFunction<UpdateActivitySetMutation, UpdateActivitySetMutationVariables>;

/**
 * __useUpdateActivitySetMutation__
 *
 * To run a mutation, you first call `useUpdateActivitySetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateActivitySetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateActivitySetMutation, { data, loading, error }] = useUpdateActivitySetMutation({
 *   variables: {
 *      pkColumns: // value for 'pkColumns'
 *      set: // value for 'set'
 *   },
 * });
 */
export function useUpdateActivitySetMutation(baseOptions?: Apollo.MutationHookOptions<UpdateActivitySetMutation, UpdateActivitySetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateActivitySetMutation, UpdateActivitySetMutationVariables>(UpdateActivitySetDocument, options);
      }
export type UpdateActivitySetMutationHookResult = ReturnType<typeof useUpdateActivitySetMutation>;
export type UpdateActivitySetMutationResult = Apollo.MutationResult<UpdateActivitySetMutation>;
export type UpdateActivitySetMutationOptions = Apollo.BaseMutationOptions<UpdateActivitySetMutation, UpdateActivitySetMutationVariables>;
export const UpdateManyActivitySetsDocument = gql`
    mutation UpdateManyActivitySets($updates: [activity_sets_updates!]!) {
  activitySets: update_activity_sets_many(updates: $updates) {
    returning {
      id
    }
  }
}
    `;
export type UpdateManyActivitySetsMutationFn = Apollo.MutationFunction<UpdateManyActivitySetsMutation, UpdateManyActivitySetsMutationVariables>;

/**
 * __useUpdateManyActivitySetsMutation__
 *
 * To run a mutation, you first call `useUpdateManyActivitySetsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyActivitySetsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyActivitySetsMutation, { data, loading, error }] = useUpdateManyActivitySetsMutation({
 *   variables: {
 *      updates: // value for 'updates'
 *   },
 * });
 */
export function useUpdateManyActivitySetsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateManyActivitySetsMutation, UpdateManyActivitySetsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateManyActivitySetsMutation, UpdateManyActivitySetsMutationVariables>(UpdateManyActivitySetsDocument, options);
      }
export type UpdateManyActivitySetsMutationHookResult = ReturnType<typeof useUpdateManyActivitySetsMutation>;
export type UpdateManyActivitySetsMutationResult = Apollo.MutationResult<UpdateManyActivitySetsMutation>;
export type UpdateManyActivitySetsMutationOptions = Apollo.BaseMutationOptions<UpdateManyActivitySetsMutation, UpdateManyActivitySetsMutationVariables>;
export const CreateImageDocument = gql`
    mutation CreateImage($object: images_insert_input!, $onConflict: images_on_conflict) {
  image: insert_images_one(object: $object, on_conflict: $onConflict) {
    id
  }
}
    `;
export type CreateImageMutationFn = Apollo.MutationFunction<CreateImageMutation, CreateImageMutationVariables>;

/**
 * __useCreateImageMutation__
 *
 * To run a mutation, you first call `useCreateImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createImageMutation, { data, loading, error }] = useCreateImageMutation({
 *   variables: {
 *      object: // value for 'object'
 *      onConflict: // value for 'onConflict'
 *   },
 * });
 */
export function useCreateImageMutation(baseOptions?: Apollo.MutationHookOptions<CreateImageMutation, CreateImageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateImageMutation, CreateImageMutationVariables>(CreateImageDocument, options);
      }
export type CreateImageMutationHookResult = ReturnType<typeof useCreateImageMutation>;
export type CreateImageMutationResult = Apollo.MutationResult<CreateImageMutation>;
export type CreateImageMutationOptions = Apollo.BaseMutationOptions<CreateImageMutation, CreateImageMutationVariables>;
export const GetImagesDocument = gql`
    query GetImages($where: images_bool_exp!, $limit: Int, $offset: Int) {
  images(where: $where, limit: $limit, offset: $offset) {
    ...ImageFields
  }
}
    ${ImageFieldsFragmentDoc}`;

/**
 * __useGetImagesQuery__
 *
 * To run a query within a React component, call `useGetImagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetImagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetImagesQuery({
 *   variables: {
 *      where: // value for 'where'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetImagesQuery(baseOptions: Apollo.QueryHookOptions<GetImagesQuery, GetImagesQueryVariables> & ({ variables: GetImagesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetImagesQuery, GetImagesQueryVariables>(GetImagesDocument, options);
      }
export function useGetImagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetImagesQuery, GetImagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetImagesQuery, GetImagesQueryVariables>(GetImagesDocument, options);
        }
export function useGetImagesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetImagesQuery, GetImagesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetImagesQuery, GetImagesQueryVariables>(GetImagesDocument, options);
        }
export type GetImagesQueryHookResult = ReturnType<typeof useGetImagesQuery>;
export type GetImagesLazyQueryHookResult = ReturnType<typeof useGetImagesLazyQuery>;
export type GetImagesSuspenseQueryHookResult = ReturnType<typeof useGetImagesSuspenseQuery>;
export type GetImagesQueryResult = Apollo.QueryResult<GetImagesQuery, GetImagesQueryVariables>;